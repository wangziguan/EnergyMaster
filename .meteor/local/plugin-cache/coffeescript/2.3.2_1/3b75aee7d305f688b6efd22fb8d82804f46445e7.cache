{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar Spacebars,\n    Template,\n    func,\n    helpers,\n    isActive,\n    name,\n    hasProp = {}.hasOwnProperty;\n\nif (!(Package.templating && Package.spacebars)) {\n  return;\n}\n\nTemplate = Package.templating.Template;\nSpacebars = Package.spacebars.Spacebars;\n\nisActive = function (type) {\n  var inverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var helperName;\n  helperName = 'is';\n\n  if (inverse) {\n    helperName += 'Not';\n  }\n\n  helperName += \"Active\" + type;\n  return function () {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var className, isPath, name, path, pattern, ref, regex, result, t;\n\n    if (Match.test(options, Spacebars.kw)) {\n      options = options.hash;\n    }\n\n    if (Match.test(attributes, Spacebars.kw)) {\n      attributes = attributes.hash;\n    }\n\n    if (Match.test(options, String)) {\n      if (share.config.equals('regex', true)) {\n        options = {\n          regex: options\n        };\n      } else if (type === 'Path') {\n        options = {\n          path: options\n        };\n      } else {\n        options = {\n          name: options\n        };\n      }\n    }\n\n    options = _.defaults(attributes, options);\n    pattern = Match.ObjectIncluding({\n      \"class\": Match.Optional(String),\n      className: Match.Optional(String),\n      regex: Match.Optional(Match.OneOf(RegExp, String)),\n      name: Match.Optional(String),\n      path: Match.Optional(String)\n    });\n    check(options, pattern);\n    var _options = options;\n    regex = _options.regex;\n    name = _options.name;\n    path = _options.path;\n    className = (ref = options.class) != null ? ref : options.className;\n\n    if (type === 'Path') {\n      name = null;\n    } else {\n      path = null;\n    }\n\n    if (!(regex || name || path)) {\n      t = type === 'Route' ? 'name' : type;\n      t = t.toLowerCase();\n      console.error(\"Invalid argument, \" + helperName + \" takes \\\"\" + t + \"\\\", \" + (t + \"=\\\"\" + t + \"\\\" or regex=\\\"regex\\\"\"));\n      return false;\n    }\n\n    if (Match.test(regex, String)) {\n      if (share.config.equals('caseSensitive', false)) {\n        regex = new RegExp(regex, 'i');\n      } else {\n        regex = new RegExp(regex);\n      }\n    }\n\n    if (regex == null) {\n      regex = name || path;\n    }\n\n    if (inverse) {\n      if (className == null) {\n        className = share.config.get('disabledClass');\n      }\n    } else {\n      if (className == null) {\n        className = share.config.get('activeClass');\n      }\n    }\n\n    if (type === 'Path') {\n      isPath = true;\n    }\n\n    if (isPath) {\n      result = ActiveRoute.path(regex);\n    } else {\n      options = _.defaults(attributes, attributes.data);\n      result = ActiveRoute.name(regex, _.omit(options, ['class', 'className', 'data', 'regex', 'name', 'path']));\n    }\n\n    if (inverse) {\n      result = !result;\n    }\n\n    if (result) {\n      return className;\n    } else {\n      return false;\n    }\n  };\n};\n\nhelpers = {\n  isActiveRoute: isActive('Route'),\n  isActivePath: isActive('Path'),\n  isNotActiveRoute: isActive('Route', true),\n  isNotActivePath: isActive('Path', true)\n};\n\nfor (name in meteorBabelHelpers.sanitizeForInObject(helpers)) {\n  if (!hasProp.call(helpers, name)) continue;\n  func = helpers[name];\n  Template.registerHelper(name, func);\n}","sourceMap":{"version":3,"sources":["/packages/zimme_active-route/client/helpers.coffee","/client/helpers.coffee"],"names":["Spacebars","Template","func","helpers","isActive","name","hasProp","hasOwnProperty","Package","templating","spacebars","type","inverse","helperName","options","attributes","className","isPath","path","pattern","ref","regex","result","t","Match","test","kw","hash","String","share","config","equals","_","defaults","ObjectIncluding","Optional","OneOf","RegExp","check","class","toLowerCase","console","error","get","ActiveRoute","data","omit","isActiveRoute","isActivePath","isNotActiveRoute","isNotActivePath","call","registerHelper"],"mappings":"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","file":"packages/zimme:active-route/client/helpers.coffee.map","sourcesContent":["return unless Package.templating and Package.spacebars\n\nTemplate = Package.templating.Template\nSpacebars = Package.spacebars.Spacebars\n\nisActive = (type, inverse = false) ->\n  helperName = 'is'\n  helperName += 'Not' if inverse\n  helperName += \"Active#{type}\"\n\n  (options = {}, attributes = {}) ->\n    if Match.test options, Spacebars.kw\n      options = options.hash\n\n    if Match.test attributes, Spacebars.kw\n      attributes = attributes.hash\n\n    if Match.test options, String\n      if share.config.equals 'regex', true\n        options =\n          regex: options\n\n      else if type is 'Path'\n        options =\n          path: options\n\n      else\n        options =\n          name: options\n\n    options = _.defaults attributes, options\n\n    pattern = Match.ObjectIncluding\n      class: Match.Optional String\n      className: Match.Optional String\n      regex: Match.Optional Match.OneOf RegExp, String\n      name: Match.Optional String\n      path: Match.Optional String\n\n    check options, pattern\n\n    {regex, name, path} = options\n\n    className = options.class ? options.className\n\n    if type is 'Path'\n      name = null\n\n    else\n      path = null\n\n    unless regex or name or path\n      t = if type is 'Route' then 'name' else type\n      t = t.toLowerCase()\n      console.error \"Invalid argument, #{helperName} takes \\\"#{t}\\\", \" +\n        \"#{t}=\\\"#{t}\\\" or regex=\\\"regex\\\"\"\n      return false\n\n    if Match.test regex, String\n      if share.config.equals 'caseSensitive', false\n        regex = new RegExp regex, 'i'\n\n      else\n        regex = new RegExp regex\n\n    regex ?= name or path\n\n    if inverse\n      className ?= share.config.get 'disabledClass'\n    else\n      className ?= share.config.get 'activeClass'\n\n    isPath = true if type is 'Path'\n\n    if isPath\n      result = ActiveRoute.path regex\n\n    else\n      options = _.defaults attributes, attributes.data\n      result = ActiveRoute.name regex, _.omit options, [\n        'class', 'className', 'data'\n        'regex', 'name', 'path'\n      ]\n\n    result = not result if inverse\n\n    if result then className else false\n\nhelpers =\n  isActiveRoute: isActive 'Route'\n\n  isActivePath: isActive 'Path'\n\n  isNotActiveRoute: isActive 'Route', true\n\n  isNotActivePath: isActive 'Path', true\n\nTemplate.registerHelper name, func for own name, func of helpers\n","var Spacebars, Template, func, helpers, isActive, name,\n  hasProp = {}.hasOwnProperty;\n\nif (!(Package.templating && Package.spacebars)) {\n  return;\n}\n\nTemplate = Package.templating.Template;\n\nSpacebars = Package.spacebars.Spacebars;\n\nisActive = function(type, inverse = false) {\n  var helperName;\n  helperName = 'is';\n  if (inverse) {\n    helperName += 'Not';\n  }\n  helperName += `Active${type}`;\n  return function(options = {}, attributes = {}) {\n    var className, isPath, name, path, pattern, ref, regex, result, t;\n    if (Match.test(options, Spacebars.kw)) {\n      options = options.hash;\n    }\n    if (Match.test(attributes, Spacebars.kw)) {\n      attributes = attributes.hash;\n    }\n    if (Match.test(options, String)) {\n      if (share.config.equals('regex', true)) {\n        options = {\n          regex: options\n        };\n      } else if (type === 'Path') {\n        options = {\n          path: options\n        };\n      } else {\n        options = {\n          name: options\n        };\n      }\n    }\n    options = _.defaults(attributes, options);\n    pattern = Match.ObjectIncluding({\n      class: Match.Optional(String),\n      className: Match.Optional(String),\n      regex: Match.Optional(Match.OneOf(RegExp, String)),\n      name: Match.Optional(String),\n      path: Match.Optional(String)\n    });\n    check(options, pattern);\n    ({regex, name, path} = options);\n    className = (ref = options.class) != null ? ref : options.className;\n    if (type === 'Path') {\n      name = null;\n    } else {\n      path = null;\n    }\n    if (!(regex || name || path)) {\n      t = type === 'Route' ? 'name' : type;\n      t = t.toLowerCase();\n      console.error(`Invalid argument, ${helperName} takes \"${t}\", ` + `${t}=\"${t}\" or regex=\"regex\"`);\n      return false;\n    }\n    if (Match.test(regex, String)) {\n      if (share.config.equals('caseSensitive', false)) {\n        regex = new RegExp(regex, 'i');\n      } else {\n        regex = new RegExp(regex);\n      }\n    }\n    if (regex == null) {\n      regex = name || path;\n    }\n    if (inverse) {\n      if (className == null) {\n        className = share.config.get('disabledClass');\n      }\n    } else {\n      if (className == null) {\n        className = share.config.get('activeClass');\n      }\n    }\n    if (type === 'Path') {\n      isPath = true;\n    }\n    if (isPath) {\n      result = ActiveRoute.path(regex);\n    } else {\n      options = _.defaults(attributes, attributes.data);\n      result = ActiveRoute.name(regex, _.omit(options, ['class', 'className', 'data', 'regex', 'name', 'path']));\n    }\n    if (inverse) {\n      result = !result;\n    }\n    if (result) {\n      return className;\n    } else {\n      return false;\n    }\n  };\n};\n\nhelpers = {\n  isActiveRoute: isActive('Route'),\n  isActivePath: isActive('Path'),\n  isNotActiveRoute: isActive('Route', true),\n  isNotActivePath: isActive('Path', true)\n};\n\nfor (name in helpers) {\n  if (!hasProp.call(helpers, name)) continue;\n  func = helpers[name];\n  Template.registerHelper(name, func);\n}\n"]}}