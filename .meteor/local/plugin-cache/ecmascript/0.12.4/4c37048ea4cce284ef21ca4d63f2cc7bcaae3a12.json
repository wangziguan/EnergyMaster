{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/utility.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/aldeed:autoform/utility.js","filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/utility.js","passPerPreset":false,"envName":"development","cwd":"/home/wangziguan/wzg/EnergyMaster","root":"/home/wangziguan/wzg/EnergyMaster","plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/utility.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/aldeed:autoform/utility.js"}},"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nlet MongoObject;\nmodule.link(\"mongo-object\", {\n  default(v) {\n    MongoObject = v;\n  }\n\n}, 0);\n\n/* global Utility:true, AutoForm, moment */\nUtility = {\n  componentTypeList: ['afArrayField', 'afEachArrayItem', 'afFieldInput', 'afFormGroup', 'afObjectField', 'afQuickField', 'afQuickFields', 'autoForm', 'quickForm'],\n\n  /**\n   * @method Utility.cleanNulls\n   * @private\n   * @param {Object} doc - Source object\n   * @returns {Object}\n   *\n   * Returns an object in which all properties with null, undefined, or empty\n   * string values have been removed, recursively.\n   */\n  cleanNulls: function cleanNulls(doc, isArray, keepEmptyStrings) {\n    var newDoc = isArray ? [] : {};\n\n    _.each(doc, function (val, key) {\n      if (!_.isArray(val) && isBasicObject(val)) {\n        val = cleanNulls(val, false, keepEmptyStrings); // recurse into plain objects\n\n        if (!_.isEmpty(val)) {\n          newDoc[key] = val;\n        }\n      } else if (_.isArray(val)) {\n        val = cleanNulls(val, true, keepEmptyStrings); // recurse into non-typed arrays\n\n        if (!_.isEmpty(val)) {\n          newDoc[key] = val;\n        }\n      } else if (!Utility.isNullUndefinedOrEmptyString(val)) {\n        newDoc[key] = val;\n      } else if (keepEmptyStrings && typeof val === 'string' && val.length === 0) {\n        newDoc[key] = val;\n      }\n    });\n\n    return newDoc;\n  },\n\n  /**\n   * @method Utility.reportNulls\n   * @private\n   * @param {Object} flatDoc - An object with no properties that are also objects.\n   * @returns {Object} An object in which the keys represent the keys in the\n   * original object that were null, undefined, or empty strings, and the value\n   * of each key is \"\".\n   */\n  reportNulls: function reportNulls(flatDoc, keepEmptyStrings) {\n    var nulls = {}; // Loop through the flat doc\n\n    _.each(flatDoc, function (val, key) {\n      // If value is undefined, null, or an empty string, report this as null so it will be unset\n      if (val === null) {\n        nulls[key] = '';\n      } else if (val === void 0) {\n        nulls[key] = '';\n      } else if (!keepEmptyStrings && typeof val === 'string' && val.length === 0) {\n        nulls[key] = '';\n      } // If value is an array in which all the values recursively are undefined, null, or an empty string, report this as null so it will be unset\n      else if (_.isArray(val) && Utility.cleanNulls(val, true, keepEmptyStrings).length === 0) {\n          nulls[key] = '';\n        }\n    });\n\n    return nulls;\n  },\n\n  /**\n   * @method Utility.docToModifier\n   * @private\n   * @param {Object} doc - An object to be converted into a MongoDB modifier\n   * @param {Object} [options] - Options\n   * @param {Boolean} [options.keepEmptyStrings] - Pass `true` to keep empty strings in the $set. Otherwise $unset them.\n   * @param {Boolean} [options.keepArrays] - Pass `true` to $set entire arrays. Otherwise the modifier will $set individual array items.\n   * @returns {Object} A MongoDB modifier.\n   *\n   * Converts an object into a modifier by flattening it, putting keys with\n   * null, undefined, and empty string values into `modifier.$unset`, and\n   * putting the rest of the keys into `modifier.$set`.\n   */\n  docToModifier: function docToModifier(doc, options) {\n    var modifier = {},\n        mDoc,\n        flatDoc,\n        nulls;\n    options = options || {}; // Flatten doc\n\n    mDoc = new MongoObject(doc);\n    flatDoc = mDoc.getFlatObject({\n      keepArrays: !!options.keepArrays\n    }); // Get a list of null, undefined, and empty string values so we can unset them instead\n\n    nulls = Utility.reportNulls(flatDoc, !!options.keepEmptyStrings);\n    flatDoc = Utility.cleanNulls(flatDoc, false, !!options.keepEmptyStrings);\n\n    if (!_.isEmpty(flatDoc)) {\n      modifier.$set = flatDoc;\n    }\n\n    if (!_.isEmpty(nulls)) {\n      modifier.$unset = nulls;\n    }\n\n    return modifier;\n  },\n\n  /**\n   * @method Utility.getSelectValues\n   * @private\n   * @param {Element} select - DOM Element from which to get current values\n   * @returns {string[]}\n   *\n   * Gets a string array of all the selected values in a given `select` DOM element.\n   */\n  getSelectValues: function getSelectValues(select) {\n    var result = [];\n    var options = select && select.options || [];\n    var opt;\n\n    for (var i = 0, ln = options.length; i < ln; i++) {\n      opt = options[i];\n\n      if (opt.selected) {\n        result.push(opt.value || opt.text);\n      }\n    }\n\n    return result;\n  },\n\n  /*\n   * Get select options\n   */\n  getSelectOptions: function getSelectOptions(defs, hash) {\n    var schemaType = defs.type;\n    var selectOptions = hash.options; // Handle options=\"allowed\"\n\n    if (selectOptions === 'allowed') {\n      selectOptions = _.map(defs.allowedValues, function (v) {\n        var label = v;\n\n        if (hash.capitalize && v.length > 0 && schemaType === String) {\n          label = v.charAt(0).toUpperCase() + v.slice(1).toLowerCase();\n        }\n\n        return {\n          label: label,\n          value: v\n        };\n      });\n    } // Hashtable\n    else if (_.isObject(selectOptions) && !_.isArray(selectOptions)) {\n        selectOptions = _.map(selectOptions, function (v, k) {\n          return {\n            label: v,\n            value: schemaType(k)\n          };\n        });\n      }\n\n    return selectOptions;\n  },\n\n  /**\n   * @method Utility.lookup\n   * @private\n   * @param {Any} obj\n   * @returns {Any}\n   *\n   * If `obj` is a string, returns the value of the property with that\n   * name on the `window` object. Otherwise returns `obj`.\n   */\n  lookup: function lookup(obj) {\n    var ref = window,\n        arr;\n\n    if (typeof obj === 'string') {\n      arr = obj.split('.');\n\n      while (arr.length && (ref = ref[arr.shift()]));\n\n      if (!ref) {\n        throw new Error(obj + ' is not in the window scope');\n      }\n\n      return ref;\n    }\n\n    return obj;\n  },\n\n  /**\n   * @method Utility.getFieldDefinition\n   * @private\n   * @param {SimpleSchema} ss\n   * @param {String} name\n   * @return {Object} Schema definitions object\n   *\n   * Returns the schema definitions object from a SimpleSchema instance, grabbing the first\n   * type definition out of potentially multiple.\n   */\n  getFieldDefinition(ss, name) {\n    const def = ss.getDefinition(name);\n    if (!def) return;\n    return (0, _objectSpread2.default)({}, def, def.type && def.type[0] || {});\n  },\n\n  /**\n   * @method Utility.objAffectsKey\n   * @private\n   * @param  {Object} obj\n   * @param  {String} key\n   * @return {Boolean}\n   * @todo should make this a static method in MongoObject\n   */\n  objAffectsKey: function objAffectsKey(obj, key) {\n    var mDoc = new MongoObject(obj);\n    return mDoc.affectsKey(key);\n  },\n\n  /**\n   * @method Utility.expandObj\n   * @private\n   * @param  {Object} doc\n   * @return {Object}\n   *\n   * Takes a flat object and returns an expanded version of it.\n   */\n  expandObj: function expandObj(doc) {\n    var newDoc = {},\n        subkeys,\n        subkey,\n        subkeylen,\n        nextPiece,\n        current;\n\n    _.each(doc, function (val, key) {\n      subkeys = key.split('.');\n      subkeylen = subkeys.length;\n      current = newDoc;\n\n      for (var i = 0; i < subkeylen; i++) {\n        subkey = subkeys[i];\n\n        if (typeof current[subkey] !== 'undefined' && !_.isObject(current[subkey])) {\n          break; // already set for some reason; leave it alone\n        }\n\n        if (i === subkeylen - 1) {\n          // last iteration; time to set the value\n          current[subkey] = val;\n        } else {\n          // see if the next piece is a number\n          nextPiece = subkeys[i + 1];\n          nextPiece = parseInt(nextPiece, 10);\n\n          if (isNaN(nextPiece) && !_.isObject(current[subkey])) {\n            current[subkey] = {};\n          } else if (!isNaN(nextPiece) && !_.isArray(current[subkey])) {\n            current[subkey] = [];\n          }\n        }\n\n        current = current[subkey];\n      }\n    });\n\n    return newDoc;\n  },\n\n  /**\n   * @method Utility.compactArrays\n   * @private\n   * @param  {Object} obj\n   * @return {undefined}\n   *\n   * Edits the object by reference, compacting any arrays at any level recursively.\n   */\n  compactArrays: function compactArrays(obj) {\n    if (_.isObject(obj)) {\n      _.each(obj, function (val, key) {\n        if (_.isArray(val)) {\n          obj[key] = _.without(val, void 0, null);\n\n          _.each(obj[key], function (arrayItem) {\n            compactArrays(arrayItem);\n          });\n        } else if (!(val instanceof Date) && _.isObject(val)) {\n          // recurse into objects\n          compactArrays(val);\n        }\n      });\n    }\n  },\n\n  /**\n   * @method Utility.bubbleEmpty\n   * @private\n   * @param  {Object} obj\n   * @return {undefined}\n   *\n   * Edits the object by reference.\n   */\n  bubbleEmpty: function bubbleEmpty(obj, keepEmptyStrings) {\n    if (_.isObject(obj)) {\n      _.each(obj, function (val, key) {\n        if (_.isArray(val)) {\n          _.each(val, function (arrayItem) {\n            bubbleEmpty(arrayItem);\n          });\n        } else if (isBasicObject(val)) {\n          var allEmpty = _.all(val, function (prop) {\n            return prop === void 0 || prop === null || !keepEmptyStrings && typeof prop === 'string' && prop.length === 0;\n          });\n\n          if (_.isEmpty(val) || allEmpty) {\n            obj[key] = null;\n          } else {\n            // recurse into objects\n            bubbleEmpty(val);\n          }\n        }\n      });\n    }\n  },\n\n  /**\n   * @method Utility.isNullUndefinedOrEmptyString\n   * @private\n   * @param  {Any} val\n   * @return {Boolean}\n   *\n   * Returns `true` if the value is null, undefined, or an empty string\n   */\n  isNullUndefinedOrEmptyString: function isNullUndefinedOrEmptyString(val) {\n    return val === void 0 || val === null || typeof val === 'string' && val.length === 0;\n  },\n\n  /**\n   * @method Utility.isValidDateString\n   * @private\n   * @param  {String}  dateString\n   * @return {Boolean}\n   *\n   * Returns `true` if dateString is a \"valid date string\"\n   */\n  isValidDateString: function isValidDateString(dateString) {\n    var m = moment(dateString, 'YYYY-MM-DD', true);\n    return m && m.isValid();\n  },\n\n  /**\n   * @method Utility.isValidTimeString\n   * @private\n   * @param  {String}  timeString\n   * @return {Boolean}\n   *\n   * Returns `true` if timeString is a \"valid time string\"\n   */\n  isValidTimeString: function isValidTimeString(timeString) {\n    if (typeof timeString !== 'string') {\n      return false;\n    } // this reg ex actually allows a few invalid hours/minutes/seconds, but\n    // we can catch that when parsing\n\n\n    var regEx = /^[0-2][0-9]:[0-5][0-9](:[0-5][0-9](\\.[0-9]{1,3})?)?$/;\n    return regEx.test(timeString);\n  },\n\n  /**\n   * @method  Utility.isValidNormalizedForcedUtcGlobalDateAndTimeString\n   * @private\n   * @param  {String} dateString\n   * @return {Boolean}\n   *\n   * Returns true if dateString is a \"valid normalized forced-UTC global date and time string\"\n   */\n  isValidNormalizedForcedUtcGlobalDateAndTimeString: function isValidNormalizedForcedUtcGlobalDateAndTimeString(dateString) {\n    if (typeof dateString !== 'string') {\n      return false;\n    }\n\n    var datePart = dateString.substring(0, 10);\n    var tPart = dateString.substring(10, 11);\n    var timePart = dateString.substring(11, dateString.length - 1);\n    var zPart = dateString.substring(dateString.length - 1);\n    return Utility.isValidDateString(datePart) && tPart === 'T' && Utility.isValidTimeString(timePart) && zPart === 'Z';\n  },\n\n  /**\n   * @method  Utility.isValidNormalizedLocalDateAndTimeString\n   * @private\n   * @param  {String} dtString\n   * @return {Boolean}\n   *\n   * Returns true if dtString is a \"valid normalized local date and time string\"\n   */\n  isValidNormalizedLocalDateAndTimeString: function isValidNormalizedLocalDateAndTimeString(dtString) {\n    if (typeof dtString !== 'string') {\n      return false;\n    }\n\n    var datePart = dtString.substring(0, 10);\n    var tPart = dtString.substring(10, 11);\n    var timePart = dtString.substring(11, dtString.length);\n    return Utility.isValidDateString(datePart) && tPart === 'T' && Utility.isValidTimeString(timePart);\n  },\n\n  /**\n   * @method Utility.getComponentContext\n   * @private\n   * @param  {Object} context A context (`this`) object\n   * @param {String} name The name of the helper or component we're calling from.\n   * @return {Object} Normalized context object\n   *\n   * Returns an object with `atts` and `defs` properties, normalized from whatever object is passed in.\n   * This helps deal with the fact that we have to pass the ancestor autoform's context to different\n   * helpers and components in different ways, but in all cases we want to get access to it and throw\n   * an error if we can't find an autoform context.\n   */\n  getComponentContext: function autoFormGetComponentContext(context, name) {\n    var atts,\n        defs = {},\n        formComponentAttributes,\n        fieldAttributes,\n        fieldAttributesForComponentType,\n        ss;\n    atts = _.clone(context || {});\n    ss = AutoForm.getFormSchema();\n    defs = Utility.getFieldDefinition(ss, atts.name);\n    if (!defs) return; // Look up the tree if we're in a helper, checking to see if any ancestor components\n    // had a <componentType>-attribute specified.\n\n    formComponentAttributes = AutoForm.findAttributesWithPrefix(name + '-'); // Get any field-specific attributes defined in the schema.\n    // They can be in autoform.attrName or autoform.componentType.attrName, with\n    // the latter overriding the former.\n\n    fieldAttributes = _.clone(defs.autoform) || {};\n    fieldAttributesForComponentType = fieldAttributes[name] || {};\n    fieldAttributes = _.omit(fieldAttributes, Utility.componentTypeList);\n    fieldAttributes = _.extend({}, fieldAttributes, fieldAttributesForComponentType); // \"autoform\" option in the schema provides default atts\n\n    atts = _.extend({}, formComponentAttributes, fieldAttributes, atts); // eval any attribute that is provided as a function\n\n    var evaluatedAtts = {};\n\n    _.each(atts, function (v, k) {\n      if (typeof v === 'function') {\n        evaluatedAtts[k] = v.call({\n          name: atts.name\n        });\n      } else {\n        evaluatedAtts[k] = v;\n      }\n    });\n\n    return {\n      atts: evaluatedAtts,\n      defs: defs\n    };\n  },\n\n  /**\n   * @method Utility.stringToArray\n   * @private\n   * @param {String|Array} s A variable that might be a string or an array.\n   * @param {String} errorMessage Error message to use if it's not a string or an array.\n   * @return {Array} The array, building it from a comma-delimited string if necessary.\n   */\n  stringToArray: function stringToArray(s, errorMessage) {\n    if (typeof s === 'string') {\n      return s.replace(/ /g, '').split(',');\n    } else if (!_.isArray(s)) {\n      throw new Error(errorMessage);\n    } else {\n      return s;\n    }\n  },\n\n  /**\n   * @method Utility.addClass\n   * @private\n   * @param {Object} atts An object that might have a \"class\" property\n   * @param {String} klass The class string to add\n   * @return {Object} The object with klass added to the \"class\" property, creating the property if necessary\n   */\n  addClass: function addClass(atts, klass) {\n    if (typeof atts['class'] === 'string') {\n      atts['class'] += ' ' + klass;\n    } else {\n      atts['class'] = klass;\n    }\n\n    return atts;\n  },\n\n  /**\n   * @method Utility.getFormTypeDef\n   * @private\n   * @param {String} formType The form type\n   * @return {Object} The definition. Throws an error if type hasn't been defined.\n   */\n  getFormTypeDef: function getFormTypeDef(formType) {\n    var ftd = AutoForm._formTypeDefinitions[formType];\n\n    if (!ftd) {\n      throw new Error('AutoForm: Form type \"' + formType + '\" has not been defined');\n    }\n\n    return ftd;\n  },\n  checkTemplate: function checkTemplate(template) {\n    return !!(template && template.view && template.view._domrange && !template.view.isDestroyed);\n  },\n\n  // This is copied from mongo-object to avoid a direct dep on that package\n  makeKeyGeneric(key) {\n    if (typeof key !== 'string') return null;\n    return key.replace(/\\.[0-9]+(?=\\.|$)/g, '.$');\n  }\n\n}; // getPrototypeOf polyfill\n\nif (typeof Object.getPrototypeOf !== 'function') {\n  if (typeof ''.__proto__ === 'object') {\n    Object.getPrototypeOf = function (object) {\n      return object.__proto__;\n    };\n  } else {\n    Object.getPrototypeOf = function (object) {\n      // May break if the constructor has been tampered with\n      return object.constructor.prototype;\n    };\n  }\n}\n/* Tests whether \"obj\" is an Object as opposed to\n * something that inherits from Object\n *\n * @param {any} obj\n * @returns {Boolean}\n */\n\n\nvar isBasicObject = function (obj) {\n  return _.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n};","map":{"version":3,"sources":["packages/aldeed:autoform/utility.js"],"names":["MongoObject","module","link","default","v","Utility","componentTypeList","cleanNulls","doc","isArray","keepEmptyStrings","newDoc","_","each","val","key","isBasicObject","isEmpty","isNullUndefinedOrEmptyString","length","reportNulls","flatDoc","nulls","docToModifier","options","modifier","mDoc","getFlatObject","keepArrays","$set","$unset","getSelectValues","select","result","opt","i","ln","selected","push","value","text","getSelectOptions","defs","hash","schemaType","type","selectOptions","map","allowedValues","label","capitalize","String","charAt","toUpperCase","slice","toLowerCase","isObject","k","lookup","obj","ref","window","arr","split","shift","Error","getFieldDefinition","ss","name","def","getDefinition","objAffectsKey","affectsKey","expandObj","subkeys","subkey","subkeylen","nextPiece","current","parseInt","isNaN","compactArrays","without","arrayItem","Date","bubbleEmpty","allEmpty","all","prop","isValidDateString","dateString","m","moment","isValid","isValidTimeString","timeString","regEx","test","isValidNormalizedForcedUtcGlobalDateAndTimeString","datePart","substring","tPart","timePart","zPart","isValidNormalizedLocalDateAndTimeString","dtString","getComponentContext","autoFormGetComponentContext","context","atts","formComponentAttributes","fieldAttributes","fieldAttributesForComponentType","clone","AutoForm","getFormSchema","findAttributesWithPrefix","autoform","omit","extend","evaluatedAtts","call","stringToArray","s","errorMessage","replace","addClass","klass","getFormTypeDef","formType","ftd","_formTypeDefinitions","checkTemplate","template","view","_domrange","isDestroyed","makeKeyGeneric","Object","getPrototypeOf","__proto__","object","constructor","prototype"],"mappings":"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","sourcesContent":["import MongoObject from 'mongo-object';\n\n/* global Utility:true, AutoForm, moment */\n\nUtility = {\n  componentTypeList: ['afArrayField', 'afEachArrayItem', 'afFieldInput', 'afFormGroup', 'afObjectField', 'afQuickField', 'afQuickFields', 'autoForm', 'quickForm'],\n  /**\n   * @method Utility.cleanNulls\n   * @private\n   * @param {Object} doc - Source object\n   * @returns {Object}\n   *\n   * Returns an object in which all properties with null, undefined, or empty\n   * string values have been removed, recursively.\n   */\n  cleanNulls: function cleanNulls(doc, isArray, keepEmptyStrings) {\n    var newDoc = isArray ? [] : {};\n    _.each(doc, function(val, key) {\n      if (!_.isArray(val) && isBasicObject(val)) {\n        val = cleanNulls(val, false, keepEmptyStrings); // recurse into plain objects\n        if (!_.isEmpty(val)) {\n          newDoc[key] = val;\n        }\n      } else if (_.isArray(val)) {\n        val = cleanNulls(val, true, keepEmptyStrings); // recurse into non-typed arrays\n        if (!_.isEmpty(val)) {\n          newDoc[key] = val;\n        }\n      } else if (!Utility.isNullUndefinedOrEmptyString(val)) {\n        newDoc[key] = val;\n      } else if (keepEmptyStrings && typeof val === 'string' && val.length === 0) {\n        newDoc[key] = val;\n      }\n    });\n    return newDoc;\n  },\n  /**\n   * @method Utility.reportNulls\n   * @private\n   * @param {Object} flatDoc - An object with no properties that are also objects.\n   * @returns {Object} An object in which the keys represent the keys in the\n   * original object that were null, undefined, or empty strings, and the value\n   * of each key is \"\".\n   */\n  reportNulls: function reportNulls(flatDoc, keepEmptyStrings) {\n    var nulls = {};\n    // Loop through the flat doc\n    _.each(flatDoc, function(val, key) {\n      // If value is undefined, null, or an empty string, report this as null so it will be unset\n      if (val === null) {\n        nulls[key] = '';\n      } else if (val === void 0) {\n        nulls[key] = '';\n      } else if (!keepEmptyStrings && typeof val === 'string' && val.length === 0) {\n        nulls[key] = '';\n      }\n      // If value is an array in which all the values recursively are undefined, null, or an empty string, report this as null so it will be unset\n      else if (_.isArray(val) && Utility.cleanNulls(val, true, keepEmptyStrings).length === 0) {\n        nulls[key] = '';\n      }\n    });\n    return nulls;\n  },\n  /**\n   * @method Utility.docToModifier\n   * @private\n   * @param {Object} doc - An object to be converted into a MongoDB modifier\n   * @param {Object} [options] - Options\n   * @param {Boolean} [options.keepEmptyStrings] - Pass `true` to keep empty strings in the $set. Otherwise $unset them.\n   * @param {Boolean} [options.keepArrays] - Pass `true` to $set entire arrays. Otherwise the modifier will $set individual array items.\n   * @returns {Object} A MongoDB modifier.\n   *\n   * Converts an object into a modifier by flattening it, putting keys with\n   * null, undefined, and empty string values into `modifier.$unset`, and\n   * putting the rest of the keys into `modifier.$set`.\n   */\n  docToModifier: function docToModifier(doc, options) {\n    var modifier = {}, mDoc, flatDoc, nulls;\n    options = options || {};\n\n    // Flatten doc\n    mDoc = new MongoObject(doc);\n    flatDoc = mDoc.getFlatObject({ keepArrays: !!options.keepArrays });\n    // Get a list of null, undefined, and empty string values so we can unset them instead\n    nulls = Utility.reportNulls(flatDoc, !!options.keepEmptyStrings);\n    flatDoc = Utility.cleanNulls(flatDoc, false, !!options.keepEmptyStrings);\n\n    if (!_.isEmpty(flatDoc)) {\n      modifier.$set = flatDoc;\n    }\n    if (!_.isEmpty(nulls)) {\n      modifier.$unset = nulls;\n    }\n    return modifier;\n  },\n  /**\n   * @method Utility.getSelectValues\n   * @private\n   * @param {Element} select - DOM Element from which to get current values\n   * @returns {string[]}\n   *\n   * Gets a string array of all the selected values in a given `select` DOM element.\n   */\n  getSelectValues: function getSelectValues(select) {\n    var result = [];\n    var options = select && select.options || [];\n    var opt;\n\n    for (var i = 0, ln = options.length; i < ln; i++) {\n      opt = options[i];\n\n      if (opt.selected) {\n        result.push(opt.value || opt.text);\n      }\n    }\n    return result;\n  },\n  /*\n   * Get select options\n   */\n  getSelectOptions: function getSelectOptions(defs, hash) {\n    var schemaType = defs.type;\n    var selectOptions = hash.options;\n\n    // Handle options=\"allowed\"\n    if (selectOptions === 'allowed') {\n      selectOptions = _.map(defs.allowedValues, function(v) {\n        var label = v;\n        if (hash.capitalize && v.length > 0 && schemaType === String) {\n          label = v.charAt(0).toUpperCase() + v.slice(1).toLowerCase();\n        }\n\n        return { label: label, value: v };\n      });\n    }\n\n    // Hashtable\n    else if (_.isObject(selectOptions) && !_.isArray(selectOptions)) {\n      selectOptions = _.map(selectOptions, function(v, k) {\n        return { label: v, value: schemaType(k) };\n      });\n    }\n\n    return selectOptions;\n  },\n  /**\n   * @method Utility.lookup\n   * @private\n   * @param {Any} obj\n   * @returns {Any}\n   *\n   * If `obj` is a string, returns the value of the property with that\n   * name on the `window` object. Otherwise returns `obj`.\n   */\n  lookup: function lookup(obj) {\n    var ref = window, arr;\n    if (typeof obj === 'string') {\n      arr = obj.split('.');\n      while (arr.length && (ref = ref[arr.shift()]));\n      if (!ref) {\n        throw new Error(obj + ' is not in the window scope');\n      }\n      return ref;\n    }\n    return obj;\n  },\n  /**\n   * @method Utility.getFieldDefinition\n   * @private\n   * @param {SimpleSchema} ss\n   * @param {String} name\n   * @return {Object} Schema definitions object\n   *\n   * Returns the schema definitions object from a SimpleSchema instance, grabbing the first\n   * type definition out of potentially multiple.\n   */\n  getFieldDefinition(ss, name) {\n    const def = ss.getDefinition(name);\n    if (!def) return;\n\n    return {\n      ...def,\n      ...(def.type && def.type[0]) || {},\n    };\n  },\n  /**\n   * @method Utility.objAffectsKey\n   * @private\n   * @param  {Object} obj\n   * @param  {String} key\n   * @return {Boolean}\n   * @todo should make this a static method in MongoObject\n   */\n  objAffectsKey: function objAffectsKey(obj, key) {\n    var mDoc = new MongoObject(obj);\n    return mDoc.affectsKey(key);\n  },\n  /**\n   * @method Utility.expandObj\n   * @private\n   * @param  {Object} doc\n   * @return {Object}\n   *\n   * Takes a flat object and returns an expanded version of it.\n   */\n  expandObj: function expandObj(doc) {\n    var newDoc = {}, subkeys, subkey, subkeylen, nextPiece, current;\n    _.each(doc, function(val, key) {\n      subkeys = key.split('.');\n      subkeylen = subkeys.length;\n      current = newDoc;\n      for (var i = 0; i < subkeylen; i++) {\n        subkey = subkeys[i];\n        if (typeof current[subkey] !== 'undefined' && !_.isObject(current[subkey])) {\n          break; // already set for some reason; leave it alone\n        }\n        if (i === subkeylen - 1) {\n          // last iteration; time to set the value\n          current[subkey] = val;\n        } else {\n          // see if the next piece is a number\n          nextPiece = subkeys[i + 1];\n          nextPiece = parseInt(nextPiece, 10);\n          if (isNaN(nextPiece) && !_.isObject(current[subkey])) {\n            current[subkey] = {};\n          } else if (!isNaN(nextPiece) && !_.isArray(current[subkey])) {\n            current[subkey] = [];\n          }\n        }\n        current = current[subkey];\n      }\n    });\n    return newDoc;\n  },\n  /**\n   * @method Utility.compactArrays\n   * @private\n   * @param  {Object} obj\n   * @return {undefined}\n   *\n   * Edits the object by reference, compacting any arrays at any level recursively.\n   */\n  compactArrays: function compactArrays(obj) {\n    if (_.isObject(obj)) {\n      _.each(obj, function (val, key) {\n        if (_.isArray(val)) {\n          obj[key] = _.without(val, void 0, null);\n          _.each(obj[key], function (arrayItem) {\n            compactArrays(arrayItem);\n          });\n        } else if (!(val instanceof Date) && _.isObject(val)) {\n          // recurse into objects\n          compactArrays(val);\n        }\n      });\n    }\n  },\n  /**\n   * @method Utility.bubbleEmpty\n   * @private\n   * @param  {Object} obj\n   * @return {undefined}\n   *\n   * Edits the object by reference.\n   */\n  bubbleEmpty: function bubbleEmpty(obj, keepEmptyStrings) {\n    if (_.isObject(obj)) {\n      _.each(obj, function (val, key) {\n        if (_.isArray(val)) {\n          _.each(val, function (arrayItem) {\n            bubbleEmpty(arrayItem);\n          });\n        } else if (isBasicObject(val)) {\n          var allEmpty = _.all(val, function (prop) {\n            return (prop === void 0 || prop === null || (!keepEmptyStrings && typeof prop === 'string' && prop.length === 0));\n          });\n          if (_.isEmpty(val) || allEmpty) {\n            obj[key] = null;\n          } else {\n            // recurse into objects\n            bubbleEmpty(val);\n          }\n        }\n      });\n    }\n  },\n  /**\n   * @method Utility.isNullUndefinedOrEmptyString\n   * @private\n   * @param  {Any} val\n   * @return {Boolean}\n   *\n   * Returns `true` if the value is null, undefined, or an empty string\n   */\n  isNullUndefinedOrEmptyString: function isNullUndefinedOrEmptyString(val) {\n    return (val === void 0 || val === null || (typeof val === 'string' && val.length === 0));\n  },\n  /**\n   * @method Utility.isValidDateString\n   * @private\n   * @param  {String}  dateString\n   * @return {Boolean}\n   *\n   * Returns `true` if dateString is a \"valid date string\"\n   */\n  isValidDateString: function isValidDateString(dateString) {\n    var m = moment(dateString, 'YYYY-MM-DD', true);\n    return m && m.isValid();\n  },\n  /**\n   * @method Utility.isValidTimeString\n   * @private\n   * @param  {String}  timeString\n   * @return {Boolean}\n   *\n   * Returns `true` if timeString is a \"valid time string\"\n   */\n  isValidTimeString: function isValidTimeString(timeString) {\n    if (typeof timeString !== 'string') {\n      return false;\n    }\n\n    // this reg ex actually allows a few invalid hours/minutes/seconds, but\n    // we can catch that when parsing\n    var regEx = /^[0-2][0-9]:[0-5][0-9](:[0-5][0-9](\\.[0-9]{1,3})?)?$/;\n    return regEx.test(timeString);\n  },\n  /**\n   * @method  Utility.isValidNormalizedForcedUtcGlobalDateAndTimeString\n   * @private\n   * @param  {String} dateString\n   * @return {Boolean}\n   *\n   * Returns true if dateString is a \"valid normalized forced-UTC global date and time string\"\n   */\n  isValidNormalizedForcedUtcGlobalDateAndTimeString: function isValidNormalizedForcedUtcGlobalDateAndTimeString(dateString) {\n    if (typeof dateString !== 'string') {\n      return false;\n    }\n\n    var datePart = dateString.substring(0, 10);\n    var tPart = dateString.substring(10, 11);\n    var timePart = dateString.substring(11, dateString.length - 1);\n    var zPart = dateString.substring(dateString.length - 1);\n    return Utility.isValidDateString(datePart) && tPart === 'T' && Utility.isValidTimeString(timePart) && zPart === 'Z';\n  },\n  /**\n   * @method  Utility.isValidNormalizedLocalDateAndTimeString\n   * @private\n   * @param  {String} dtString\n   * @return {Boolean}\n   *\n   * Returns true if dtString is a \"valid normalized local date and time string\"\n   */\n  isValidNormalizedLocalDateAndTimeString: function isValidNormalizedLocalDateAndTimeString(dtString) {\n    if (typeof dtString !== 'string') {\n      return false;\n    }\n\n    var datePart = dtString.substring(0, 10);\n    var tPart = dtString.substring(10, 11);\n    var timePart = dtString.substring(11, dtString.length);\n    return Utility.isValidDateString(datePart) && tPart === 'T' && Utility.isValidTimeString(timePart);\n  },\n  /**\n   * @method Utility.getComponentContext\n   * @private\n   * @param  {Object} context A context (`this`) object\n   * @param {String} name The name of the helper or component we're calling from.\n   * @return {Object} Normalized context object\n   *\n   * Returns an object with `atts` and `defs` properties, normalized from whatever object is passed in.\n   * This helps deal with the fact that we have to pass the ancestor autoform's context to different\n   * helpers and components in different ways, but in all cases we want to get access to it and throw\n   * an error if we can't find an autoform context.\n   */\n  getComponentContext: function autoFormGetComponentContext(context, name) {\n    var atts, defs = {}, formComponentAttributes, fieldAttributes, fieldAttributesForComponentType, ss;\n\n    atts = _.clone(context || {});\n    ss = AutoForm.getFormSchema();\n\n    defs = Utility.getFieldDefinition(ss, atts.name);\n    if (!defs) return;\n\n    // Look up the tree if we're in a helper, checking to see if any ancestor components\n    // had a <componentType>-attribute specified.\n    formComponentAttributes = AutoForm.findAttributesWithPrefix(name + '-');\n\n    // Get any field-specific attributes defined in the schema.\n    // They can be in autoform.attrName or autoform.componentType.attrName, with\n    // the latter overriding the former.\n    fieldAttributes = _.clone(defs.autoform) || {};\n    fieldAttributesForComponentType = fieldAttributes[name] || {};\n    fieldAttributes = _.omit(fieldAttributes, Utility.componentTypeList);\n    fieldAttributes = _.extend({}, fieldAttributes, fieldAttributesForComponentType);\n\n    // \"autoform\" option in the schema provides default atts\n    atts = _.extend({}, formComponentAttributes, fieldAttributes, atts);\n\n    // eval any attribute that is provided as a function\n    var evaluatedAtts = {};\n    _.each(atts, function (v, k) {\n      if (typeof v === 'function') {\n        evaluatedAtts[k] = v.call({\n          name: atts.name\n        });\n      } else {\n        evaluatedAtts[k] = v;\n      }\n    });\n\n    return {\n      atts: evaluatedAtts,\n      defs: defs\n    };\n  },\n  /**\n   * @method Utility.stringToArray\n   * @private\n   * @param {String|Array} s A variable that might be a string or an array.\n   * @param {String} errorMessage Error message to use if it's not a string or an array.\n   * @return {Array} The array, building it from a comma-delimited string if necessary.\n   */\n  stringToArray: function stringToArray(s, errorMessage) {\n    if (typeof s === 'string') {\n      return s.replace(/ /g, '').split(',');\n    } else if (!_.isArray(s)) {\n      throw new Error(errorMessage);\n    } else {\n      return s;\n    }\n  },\n  /**\n   * @method Utility.addClass\n   * @private\n   * @param {Object} atts An object that might have a \"class\" property\n   * @param {String} klass The class string to add\n   * @return {Object} The object with klass added to the \"class\" property, creating the property if necessary\n   */\n  addClass: function addClass(atts, klass) {\n    if (typeof atts['class'] === 'string') {\n      atts['class'] += ' ' + klass;\n    } else {\n      atts['class'] = klass;\n    }\n    return atts;\n  },\n  /**\n   * @method Utility.getFormTypeDef\n   * @private\n   * @param {String} formType The form type\n   * @return {Object} The definition. Throws an error if type hasn't been defined.\n   */\n  getFormTypeDef: function getFormTypeDef(formType) {\n    var ftd = AutoForm._formTypeDefinitions[formType];\n    if (!ftd) {\n      throw new Error('AutoForm: Form type \"' + formType + '\" has not been defined');\n    }\n    return ftd;\n  },\n  checkTemplate: function checkTemplate(template) {\n    return !!(template &&\n            template.view &&\n            template.view._domrange &&\n            !template.view.isDestroyed);\n  },\n  // This is copied from mongo-object to avoid a direct dep on that package\n  makeKeyGeneric(key) {\n    if (typeof key !== 'string') return null;\n    return key.replace(/\\.[0-9]+(?=\\.|$)/g, '.$');\n  },\n};\n\n// getPrototypeOf polyfill\nif (typeof Object.getPrototypeOf !== 'function') {\n  if (typeof ''.__proto__ === 'object') {\n    Object.getPrototypeOf = function(object) {\n      return object.__proto__;\n    };\n  } else {\n    Object.getPrototypeOf = function(object) {\n      // May break if the constructor has been tampered with\n      return object.constructor.prototype;\n    };\n  }\n}\n\n/* Tests whether \"obj\" is an Object as opposed to\n * something that inherits from Object\n *\n * @param {any} obj\n * @returns {Boolean}\n */\nvar isBasicObject = function(obj) {\n  return _.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n};\n"]},"sourceType":"script","hash":"4c37048ea4cce284ef21ca4d63f2cc7bcaae3a12"}
