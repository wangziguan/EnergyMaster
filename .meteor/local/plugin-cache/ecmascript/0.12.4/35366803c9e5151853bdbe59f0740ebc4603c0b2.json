{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/autoform-inputs.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/aldeed:autoform/autoform-inputs.js","filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/autoform-inputs.js","passPerPreset":false,"envName":"development","cwd":"/home/wangziguan/wzg/EnergyMaster","root":"/home/wangziguan/wzg/EnergyMaster","plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-arrow-functions","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoped-functions","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-block-scoping","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-classes","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-computed-properties","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-destructuring","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-for-of","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-object-super","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-shorthand-properties","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-spread","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-sticky-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"transform-typeof-symbol","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"transform-unicode-regex","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-property-literals","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{}}],"presets":[],"generatorOpts":{"filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/autoform-inputs.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/aldeed:autoform/autoform-inputs.js"}},"code":"/* global AutoForm, getInputValue:true, getAllFieldsInForm:true, getInputData:true, updateTrackedFieldValue:true, updateAllTrackedFieldValues:true, getFlatDocOfFieldValues:true */\ngetFlatDocOfFieldValues = function () {\n  function getFlatDocOfFieldValues(fields, ss) {\n    var doc = {};\n    fields.each(function () {\n      var fieldName,\n          val = AutoForm.getInputValue(this, ss);\n\n      if (val !== void 0) {\n        // Get the field/schema key name\n        fieldName = $(this).attr('data-schema-key');\n        doc[fieldName] = val;\n      }\n    });\n    return doc;\n  }\n\n  return getFlatDocOfFieldValues;\n}();\n/*\n * package scope functions\n */\n\n/*\n * Gets the value that should be shown/selected in the input. Returns\n * a string, a boolean, or an array of strings. The value used,\n * in order of preference, is one of:\n * * The `value` attribute provided\n * * The value that is set in the `doc` provided on the containing autoForm\n * * The `defaultValue` from the schema\n */\n\n\ngetInputValue = function () {\n  function getInputValue(atts, value, mDoc, schemaDefaultValue, fieldDefaultValue, typeDefs) {\n    if (typeof value === 'undefined') {\n      // Get the value for this key in the current document\n      if (mDoc) {\n        var valueInfo = mDoc.getInfoForKey(atts.name);\n\n        if (valueInfo) {\n          value = valueInfo.value;\n        } else {\n          value = fieldDefaultValue;\n        }\n      } // Only if there is no current document, use the schema defaultValue\n      else {\n          // Use the field default value if provided\n          if (typeof fieldDefaultValue !== 'undefined') {\n            value = fieldDefaultValue;\n          } // Or use the defaultValue in the schema\n          else {\n              value = schemaDefaultValue;\n            }\n        }\n    } // Change null or undefined to an empty string\n\n\n    value = value === null || value === void 0 ? '' : value; // If the component expects the value to be an array, and it's not, make it one\n\n    if (typeDefs.valueIsArray && !_.isArray(value)) {\n      if (typeof value === 'string') {\n        value = value.split(',');\n      } else {\n        value = [value];\n      }\n    } // At this point we have a value or an array of values.\n    // Run through the components valueIn function if we have one.\n    // It should then be in whatever format the component expects.\n\n\n    if (typeof typeDefs.valueIn === 'function') {\n      value = typeDefs.valueIn(value, atts);\n    }\n\n    return value;\n  }\n\n  return getInputValue;\n}();\n/*\n * Builds the data context that the input component will have.\n */\n\n\ngetInputData = function () {\n  function getInputData(defs, hash, value, label, formType) {\n    /*\n     * Get HTML attributes\n     */\n    // We don't want to alter the original hash, so we clone it and\n    // remove some stuff that should not be HTML attributes.\n    var inputAtts = _.omit(hash, 'type', 'value', 'noselect', 'options', 'template', 'defaultValue', 'data'); // Add required if required\n\n\n    if (typeof inputAtts.required === 'undefined' && !defs.optional) {\n      inputAtts.required = '';\n    } // Add data-schema-key to every type of element\n\n\n    inputAtts['data-schema-key'] = inputAtts.name; // Set placeholder to label from schema if requested.\n    // We check hash.placeholder instead of inputAtts.placeholder because\n    // we're setting inputAtts.placeholder, so it wouldn't be the same on\n    // subsequent reactive runs of this function.\n\n    if (hash.placeholder === 'schemaLabel') {\n      inputAtts.placeholder = label;\n    } // To enable reactively toggling boolean attributes\n    // in a simple way, we add the attributes to the HTML\n    // only if their value is `true`. That is, unlike in\n    // HTML, their mere presence does not matter.\n\n\n    _.each(['disabled', 'readonly', 'checked', 'required', 'autofocus'], function (booleanProp) {\n      if (!_.has(hash, booleanProp)) {\n        return;\n      } // For historical reasons, we treat the string \"true\" and an empty string as `true`, too.\n      // But an empty string value results in the cleanest rendered output for boolean props,\n      // so we standardize as that.\n\n\n      if (hash[booleanProp] === true || hash[booleanProp] === 'true' || hash[booleanProp] === '') {\n        inputAtts[booleanProp] = '';\n      } else {\n        // If the value is anything else, we don't render it\n        delete inputAtts[booleanProp];\n      }\n    });\n    /*\n     * Set up the context. This is the object that becomes `this` in the\n     * input type template.\n     */\n\n\n    var inputTypeContext = {\n      name: inputAtts.name,\n      schemaType: defs.type,\n      min: defs.min,\n      max: defs.max,\n      value: value,\n      atts: inputAtts,\n      selectOptions: AutoForm.Utility.getSelectOptions(defs, hash)\n    };\n    /*\n     * Merge data property from the field schema with the context.\n     * We do not want these turned into HTML attributes.\n     */\n\n    if (hash.data) _.extend(inputTypeContext, hash.data); // Before returning the context, we allow the registered form type to\n    // adjust it if necessary.\n\n    var ftd = Utility.getFormTypeDef(formType);\n\n    if (typeof ftd.adjustInputContext === 'function') {\n      inputTypeContext = ftd.adjustInputContext(inputTypeContext);\n    }\n\n    return inputTypeContext;\n  }\n\n  return getInputData;\n}();\n\nfunction markChanged(template, fieldName) {\n  // We always want to be sure to wait for DOM updates to\n  // finish before we indicate that values have changed.\n  // Using a value of 0 here did not work, but 100 seems to\n  // work in testing. We'll need to keep an eye on this.\n  // Not an ideal solution.\n  setTimeout(function () {\n    // Template or view may have disappeared while\n    // we waited to run this\n    if (template && template.view && template.view._domrange && !template.view.isDestroyed && template.formValues[fieldName]) {\n      template.formValues[fieldName].changed();\n      template.formValues[fieldName].requestInProgress = false;\n    }\n  }, 100);\n}\n\nupdateTrackedFieldValue = function () {\n  function updateTrackedFieldValue(template, fieldName) {\n    if (!template) return;\n    template.formValues = template.formValues || {};\n\n    if (!template.formValues[fieldName]) {\n      template.formValues[fieldName] = new Tracker.Dependency();\n    } // In case we call updateTrackedFieldValue from multiple places at once,\n    // call .changed() only once\n\n\n    if (template.formValues[fieldName].requestInProgress) {\n      return;\n    }\n\n    template.formValues[fieldName].requestInProgress = true;\n    markChanged(template, fieldName); // To properly handle array fields, we'll mark the ancestors as changed, too\n    // XXX Might be a more elegant way to handle this\n\n    var dotPos = fieldName.lastIndexOf('.');\n\n    while (dotPos !== -1) {\n      fieldName = fieldName.slice(0, dotPos);\n\n      if (!template.formValues[fieldName]) {\n        template.formValues[fieldName] = new Tracker.Dependency();\n      }\n\n      markChanged(template, fieldName);\n      dotPos = fieldName.lastIndexOf('.');\n    }\n  }\n\n  return updateTrackedFieldValue;\n}();\n\nupdateAllTrackedFieldValues = function () {\n  function updateAllTrackedFieldValues(template) {\n    if (template && template.formValues) {\n      _.each(template.formValues, function (o, fieldName) {\n        updateTrackedFieldValue(template, fieldName);\n      });\n    }\n  }\n\n  return updateAllTrackedFieldValues;\n}();\n\ngetAllFieldsInForm = function () {\n  function getAllFieldsInForm(template) {\n    // Get all elements with `data-schema-key` attribute, unless disabled\n    return template.$('[data-schema-key]').not('[disabled]'); // Exclude fields in sub-forms, since they will belong to a different AutoForm and schema.\n    // TODO need some selector/filter that actually works correctly for excluding subforms\n    // return template.$('[data-schema-key]').not(\"[disabled]\").not(template.$('form form [data-schema-key]'));\n  }\n\n  return getAllFieldsInForm;\n}();","map":{"version":3,"sources":["packages/aldeed:autoform/autoform-inputs.js"],"names":["getFlatDocOfFieldValues","fields","ss","doc","each","fieldName","val","AutoForm","getInputValue","$","attr","atts","value","mDoc","schemaDefaultValue","fieldDefaultValue","typeDefs","valueInfo","getInfoForKey","name","valueIsArray","_","isArray","split","valueIn","getInputData","defs","hash","label","formType","inputAtts","omit","required","optional","placeholder","booleanProp","has","inputTypeContext","schemaType","type","min","max","selectOptions","Utility","getSelectOptions","data","extend","ftd","getFormTypeDef","adjustInputContext","markChanged","template","setTimeout","view","_domrange","isDestroyed","formValues","changed","requestInProgress","updateTrackedFieldValue","Tracker","Dependency","dotPos","lastIndexOf","slice","updateAllTrackedFieldValues","o","getAllFieldsInForm","not"],"mappings":"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","sourcesContent":["/* global AutoForm, getInputValue:true, getAllFieldsInForm:true, getInputData:true, updateTrackedFieldValue:true, updateAllTrackedFieldValues:true, getFlatDocOfFieldValues:true */\n\ngetFlatDocOfFieldValues = function getFlatDocOfFieldValues(fields, ss) {\n  var doc = {};\n  fields.each(function () {\n    var fieldName, val = AutoForm.getInputValue(this, ss);\n    if (val !== void 0) {\n      // Get the field/schema key name\n      fieldName = $(this).attr('data-schema-key');\n      doc[fieldName] = val;\n    }\n  });\n  return doc;\n};\n\n/*\n * package scope functions\n */\n\n/*\n * Gets the value that should be shown/selected in the input. Returns\n * a string, a boolean, or an array of strings. The value used,\n * in order of preference, is one of:\n * * The `value` attribute provided\n * * The value that is set in the `doc` provided on the containing autoForm\n * * The `defaultValue` from the schema\n */\ngetInputValue = function getInputValue(atts, value, mDoc, schemaDefaultValue, fieldDefaultValue, typeDefs) {\n\n  if (typeof value === 'undefined') {\n    // Get the value for this key in the current document\n    if (mDoc) {\n      var valueInfo = mDoc.getInfoForKey(atts.name);\n      if (valueInfo) {\n        value = valueInfo.value;\n      } else {\n        value = fieldDefaultValue;\n      }\n    }\n\n    // Only if there is no current document, use the schema defaultValue\n    else {\n      // Use the field default value if provided\n      if (typeof fieldDefaultValue !== 'undefined') {\n        value = fieldDefaultValue;\n      }\n      // Or use the defaultValue in the schema\n      else {\n        value = schemaDefaultValue;\n      }\n    }\n  }\n\n  // Change null or undefined to an empty string\n  value = (value === null || value === void 0) ? '' : value;\n\n  // If the component expects the value to be an array, and it's not, make it one\n  if (typeDefs.valueIsArray && !_.isArray(value)) {\n    if (typeof value === 'string') {\n      value = value.split(',');\n    } else {\n      value = [value];\n    }\n  }\n\n  // At this point we have a value or an array of values.\n  // Run through the components valueIn function if we have one.\n  // It should then be in whatever format the component expects.\n  if (typeof typeDefs.valueIn === 'function') {\n    value = typeDefs.valueIn(value, atts);\n  }\n\n  return value;\n};\n\n/*\n * Builds the data context that the input component will have.\n */\ngetInputData = function getInputData(defs, hash, value, label, formType) {\n\n  /*\n   * Get HTML attributes\n   */\n\n  // We don't want to alter the original hash, so we clone it and\n  // remove some stuff that should not be HTML attributes.\n  var inputAtts = _.omit(hash,\n    'type',\n    'value',\n    'noselect',\n    'options',\n    'template',\n    'defaultValue',\n    'data');\n\n  // Add required if required\n  if (typeof inputAtts.required === 'undefined' && !defs.optional) {\n    inputAtts.required = '';\n  }\n\n   // Add data-schema-key to every type of element\n  inputAtts['data-schema-key'] = inputAtts.name;\n\n  // Set placeholder to label from schema if requested.\n  // We check hash.placeholder instead of inputAtts.placeholder because\n  // we're setting inputAtts.placeholder, so it wouldn't be the same on\n  // subsequent reactive runs of this function.\n  if (hash.placeholder === 'schemaLabel') {\n    inputAtts.placeholder = label;\n  }\n\n  // To enable reactively toggling boolean attributes\n  // in a simple way, we add the attributes to the HTML\n  // only if their value is `true`. That is, unlike in\n  // HTML, their mere presence does not matter.\n  _.each(['disabled', 'readonly', 'checked', 'required', 'autofocus'], function (booleanProp) {\n    if (!_.has(hash, booleanProp)) {\n      return;\n    }\n\n    // For historical reasons, we treat the string \"true\" and an empty string as `true`, too.\n    // But an empty string value results in the cleanest rendered output for boolean props,\n    // so we standardize as that.\n    if (hash[booleanProp] === true || hash[booleanProp] === 'true' || hash[booleanProp] === '') {\n      inputAtts[booleanProp] = '';\n    } else {\n      // If the value is anything else, we don't render it\n      delete inputAtts[booleanProp];\n    }\n  });\n\n  /*\n   * Set up the context. This is the object that becomes `this` in the\n   * input type template.\n   */\n\n  var inputTypeContext = {\n    name: inputAtts.name,\n    schemaType: defs.type,\n    min: defs.min,\n    max: defs.max,\n    value: value,\n    atts: inputAtts,\n    selectOptions: AutoForm.Utility.getSelectOptions(defs, hash)\n  };\n\n  /*\n   * Merge data property from the field schema with the context.\n   * We do not want these turned into HTML attributes.\n   */\n  if (hash.data) _.extend(inputTypeContext, hash.data);\n\n  // Before returning the context, we allow the registered form type to\n  // adjust it if necessary.\n  var ftd = Utility.getFormTypeDef(formType);\n  if (typeof ftd.adjustInputContext === 'function') {\n    inputTypeContext = ftd.adjustInputContext(inputTypeContext);\n  }\n\n  return inputTypeContext;\n};\n\nfunction markChanged(template, fieldName) {\n  // We always want to be sure to wait for DOM updates to\n  // finish before we indicate that values have changed.\n  // Using a value of 0 here did not work, but 100 seems to\n  // work in testing. We'll need to keep an eye on this.\n  // Not an ideal solution.\n  setTimeout(function () {\n    // Template or view may have disappeared while\n    // we waited to run this\n    if (template &&\n        template.view &&\n        template.view._domrange &&\n        !template.view.isDestroyed &&\n        template.formValues[fieldName]) {\n\n      template.formValues[fieldName].changed();\n      template.formValues[fieldName].requestInProgress = false;\n\n    }\n  }, 100);\n}\n\nupdateTrackedFieldValue = function updateTrackedFieldValue(template, fieldName) {\n  if (!template) return;\n\n  template.formValues = template.formValues || {};\n  if (!template.formValues[fieldName]) {\n    template.formValues[fieldName] = new Tracker.Dependency();\n  }\n  // In case we call updateTrackedFieldValue from multiple places at once,\n  // call .changed() only once\n  if (template.formValues[fieldName].requestInProgress) {\n    return;\n  }\n  template.formValues[fieldName].requestInProgress = true;\n\n  markChanged(template, fieldName);\n\n  // To properly handle array fields, we'll mark the ancestors as changed, too\n  // XXX Might be a more elegant way to handle this\n  var dotPos = fieldName.lastIndexOf('.');\n  while (dotPos !== -1) {\n    fieldName = fieldName.slice(0, dotPos);\n\n    if (!template.formValues[fieldName]) {\n      template.formValues[fieldName] = new Tracker.Dependency();\n    }\n\n    markChanged(template, fieldName);\n\n    dotPos = fieldName.lastIndexOf('.');\n  }\n};\n\nupdateAllTrackedFieldValues = function updateAllTrackedFieldValues(template) {\n  if (template && template.formValues) {\n    _.each(template.formValues, function (o, fieldName) {\n      updateTrackedFieldValue(template, fieldName);\n    });\n  }\n};\n\ngetAllFieldsInForm = function getAllFieldsInForm(template) {\n  // Get all elements with `data-schema-key` attribute, unless disabled\n  return template.$('[data-schema-key]').not('[disabled]');\n  // Exclude fields in sub-forms, since they will belong to a different AutoForm and schema.\n  // TODO need some selector/filter that actually works correctly for excluding subforms\n  // return template.$('[data-schema-key]').not(\"[disabled]\").not(template.$('form form [data-schema-key]'));\n};\n"]},"sourceType":"script","hash":"35366803c9e5151853bdbe59f0740ebc4603c0b2"}
