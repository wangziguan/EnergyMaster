{"metadata":{},"options":{"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/wangziguan/wzg/EnergyMaster/packages/accounts-password/password_server.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/accounts-password/password_server.js","filename":"/home/wangziguan/wzg/EnergyMaster/packages/accounts-password/password_server.js","passPerPreset":false,"envName":"development","cwd":"/home/wangziguan/wzg/EnergyMaster","root":"/home/wangziguan/wzg/EnergyMaster","plugins":[{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"syntax-flow","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"transform-flow-strip-types","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"transform-runtime","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"transform-modules-commonjs","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"_exploded":true,"_verified":true,"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"presets":[],"generatorOpts":{"filename":"/home/wangziguan/wzg/EnergyMaster/packages/accounts-password/password_server.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/accounts-password/password_server.js"}},"code":"/// BCRYPT\nvar bcrypt = NpmModuleBcrypt;\nvar bcryptHash = Meteor.wrapAsync(bcrypt.hash);\nvar bcryptCompare = Meteor.wrapAsync(bcrypt.compare); // User records have a 'services.password.bcrypt' field on them to hold\n// their hashed passwords (unless they have a 'services.password.srp'\n// field, in which case they will be upgraded to bcrypt the next time\n// they log in).\n//\n// When the client sends a password to the server, it can either be a\n// string (the plaintext password) or an object with keys 'digest' and\n// 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends\n// password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients\n// that don't have access to SHA can just send plaintext passwords as\n// strings.\n//\n// When the server receives a plaintext password as a string, it always\n// hashes it with SHA256 before passing it into bcrypt. When the server\n// receives a password as an object, it asserts that the algorithm is\n// \"sha-256\" and then passes the digest to bcrypt.\n\nAccounts._bcryptRounds = () => Accounts._options.bcryptRounds || 10; // Given a 'password' from the client, extract the string that we should\n// bcrypt. 'password' can be one of:\n//  - String (the plaintext password)\n//  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".\n//\n\n\nvar getPasswordString = function (password) {\n  if (typeof password === \"string\") {\n    password = SHA256(password);\n  } else {\n    // 'password' is an object\n    if (password.algorithm !== \"sha-256\") {\n      throw new Error(\"Invalid password hash algorithm. \" + \"Only 'sha-256' is allowed.\");\n    }\n\n    password = password.digest;\n  }\n\n  return password;\n}; // Use bcrypt to hash the password for storage in the database.\n// `password` can be a string (in which case it will be run through\n// SHA256 before bcrypt) or an object with properties `digest` and\n// `algorithm` (in which case we bcrypt `password.digest`).\n//\n\n\nvar hashPassword = function (password) {\n  password = getPasswordString(password);\n  return bcryptHash(password, Accounts._bcryptRounds());\n}; // Extract the number of rounds used in the specified bcrypt hash.\n\n\nconst getRoundsFromBcryptHash = hash => {\n  let rounds;\n\n  if (hash) {\n    const hashSegments = hash.split('$');\n\n    if (hashSegments.length > 2) {\n      rounds = parseInt(hashSegments[2], 10);\n    }\n  }\n\n  return rounds;\n}; // Check whether the provided password matches the bcrypt'ed password in\n// the database user record. `password` can be a string (in which case\n// it will be run through SHA256 before bcrypt) or an object with\n// properties `digest` and `algorithm` (in which case we bcrypt\n// `password.digest`).\n//\n\n\nAccounts._checkPassword = function (user, password) {\n  var result = {\n    userId: user._id\n  };\n  const formattedPassword = getPasswordString(password);\n  const hash = user.services.password.bcrypt;\n  const hashRounds = getRoundsFromBcryptHash(hash);\n\n  if (!bcryptCompare(formattedPassword, hash)) {\n    result.error = handleError(\"Incorrect password\", false);\n  } else if (hash && Accounts._bcryptRounds() != hashRounds) {\n    // The password checks out, but the user's bcrypt hash needs to be updated.\n    Meteor.defer(() => {\n      Meteor.users.update({\n        _id: user._id\n      }, {\n        $set: {\n          'services.password.bcrypt': bcryptHash(formattedPassword, Accounts._bcryptRounds())\n        }\n      });\n    });\n  }\n\n  return result;\n};\n\nvar checkPassword = Accounts._checkPassword; ///\n/// ERROR HANDLER\n///\n\nconst handleError = (msg, throwError = true) => {\n  const error = new Meteor.Error(403, Accounts._options.ambiguousErrorMessages ? \"Something went wrong. Please check your credentials.\" : msg);\n\n  if (throwError) {\n    throw error;\n  }\n\n  return error;\n}; ///\n/// LOGIN\n///\n\n\nAccounts._findUserByQuery = function (query) {\n  var user = null;\n\n  if (query.id) {\n    user = Meteor.users.findOne({\n      _id: query.id\n    });\n  } else {\n    var fieldName;\n    var fieldValue;\n\n    if (query.username) {\n      fieldName = 'username';\n      fieldValue = query.username;\n    } else if (query.email) {\n      fieldName = 'emails.address';\n      fieldValue = query.email;\n    } else {\n      throw new Error(\"shouldn't happen (validation missed something)\");\n    }\n\n    var selector = {};\n    selector[fieldName] = fieldValue;\n    user = Meteor.users.findOne(selector); // If user is not found, try a case insensitive lookup\n\n    if (!user) {\n      selector = selectorForFastCaseInsensitiveLookup(fieldName, fieldValue);\n      var candidateUsers = Meteor.users.find(selector).fetch(); // No match if multiple candidates are found\n\n      if (candidateUsers.length === 1) {\n        user = candidateUsers[0];\n      }\n    }\n  }\n\n  return user;\n};\n/**\n * @summary Finds the user with the specified username.\n * First tries to match username case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} username The username to look for\n * @returns {Object} A user if found, else null\n * @importFromPackage accounts-base\n */\n\n\nAccounts.findUserByUsername = function (username) {\n  return Accounts._findUserByQuery({\n    username: username\n  });\n};\n/**\n * @summary Finds the user with the specified email.\n * First tries to match email case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} email The email address to look for\n * @returns {Object} A user if found, else null\n * @importFromPackage accounts-base\n */\n\n\nAccounts.findUserByEmail = function (email) {\n  return Accounts._findUserByQuery({\n    email: email\n  });\n}; // Generates a MongoDB selector that can be used to perform a fast case\n// insensitive lookup for the given fieldName and string. Since MongoDB does\n// not support case insensitive indexes, and case insensitive regex queries\n// are slow, we construct a set of prefix selectors for all permutations of\n// the first 4 characters ourselves. We first attempt to matching against\n// these, and because 'prefix expression' regex queries do use indexes (see\n// http://docs.mongodb.org/v2.6/reference/operator/query/regex/#index-use),\n// this has been found to greatly improve performance (from 1200ms to 5ms in a\n// test with 1.000.000 users).\n\n\nvar selectorForFastCaseInsensitiveLookup = function (fieldName, string) {\n  // Performance seems to improve up to 4 prefix characters\n  var prefix = string.substring(0, Math.min(string.length, 4));\n\n  var orClause = _.map(generateCasePermutationsForString(prefix), function (prefixPermutation) {\n    var selector = {};\n    selector[fieldName] = new RegExp('^' + Meteor._escapeRegExp(prefixPermutation));\n    return selector;\n  });\n\n  var caseInsensitiveClause = {};\n  caseInsensitiveClause[fieldName] = new RegExp('^' + Meteor._escapeRegExp(string) + '$', 'i');\n  return {\n    $and: [{\n      $or: orClause\n    }, caseInsensitiveClause]\n  };\n}; // Generates permutations of all case variations of a given string.\n\n\nvar generateCasePermutationsForString = function (string) {\n  var permutations = [''];\n\n  for (var i = 0; i < string.length; i++) {\n    var ch = string.charAt(i);\n    permutations = _.flatten(_.map(permutations, function (prefix) {\n      var lowerCaseChar = ch.toLowerCase();\n      var upperCaseChar = ch.toUpperCase(); // Don't add unneccesary permutations when ch is not a letter\n\n      if (lowerCaseChar === upperCaseChar) {\n        return [prefix + ch];\n      } else {\n        return [prefix + lowerCaseChar, prefix + upperCaseChar];\n      }\n    }));\n  }\n\n  return permutations;\n};\n\nvar checkForCaseInsensitiveDuplicates = function (fieldName, displayName, fieldValue, ownUserId) {\n  // Some tests need the ability to add users with the same case insensitive\n  // value, hence the _skipCaseInsensitiveChecksForTest check\n  var skipCheck = _.has(Accounts._skipCaseInsensitiveChecksForTest, fieldValue);\n\n  if (fieldValue && !skipCheck) {\n    var matchedUsers = Meteor.users.find(selectorForFastCaseInsensitiveLookup(fieldName, fieldValue)).fetch();\n\n    if (matchedUsers.length > 0 && ( // If we don't have a userId yet, any match we find is a duplicate\n    !ownUserId || // Otherwise, check to see if there are multiple matches or a match\n    // that is not us\n    matchedUsers.length > 1 || matchedUsers[0]._id !== ownUserId)) {\n      handleError(displayName + \" already exists.\");\n    }\n  }\n}; // XXX maybe this belongs in the check package\n\n\nvar NonEmptyString = Match.Where(function (x) {\n  check(x, String);\n  return x.length > 0;\n});\nvar userQueryValidator = Match.Where(function (user) {\n  check(user, {\n    id: Match.Optional(NonEmptyString),\n    username: Match.Optional(NonEmptyString),\n    email: Match.Optional(NonEmptyString)\n  });\n  if (_.keys(user).length !== 1) throw new Match.Error(\"User property must have exactly one field\");\n  return true;\n});\nvar passwordValidator = Match.OneOf(String, {\n  digest: String,\n  algorithm: String\n}); // Handler to login with a password.\n//\n// The Meteor client sets options.password to an object with keys\n// 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").\n//\n// For other DDP clients which don't have access to SHA, the handler\n// also accepts the plaintext password in options.password as a string.\n//\n// (It might be nice if servers could turn the plaintext password\n// option off. Or maybe it should be opt-in, not opt-out?\n// Accounts.config option?)\n//\n// Note that neither password option is secure without SSL.\n//\n\nAccounts.registerLoginHandler(\"password\", function (options) {\n  if (!options.password || options.srp) return undefined; // don't handle\n\n  check(options, {\n    user: userQueryValidator,\n    password: passwordValidator\n  });\n\n  var user = Accounts._findUserByQuery(options.user);\n\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  if (!user.services || !user.services.password || !(user.services.password.bcrypt || user.services.password.srp)) {\n    handleError(\"User has no password set\");\n  }\n\n  if (!user.services.password.bcrypt) {\n    if (typeof options.password === \"string\") {\n      // The client has presented a plaintext password, and the user is\n      // not upgraded to bcrypt yet. We don't attempt to tell the client\n      // to upgrade to bcrypt, because it might be a standalone DDP\n      // client doesn't know how to do such a thing.\n      var verifier = user.services.password.srp;\n      var newVerifier = SRP.generateVerifier(options.password, {\n        identity: verifier.identity,\n        salt: verifier.salt\n      });\n\n      if (verifier.verifier !== newVerifier.verifier) {\n        return {\n          userId: Accounts._options.ambiguousErrorMessages ? null : user._id,\n          error: handleError(\"Incorrect password\", false)\n        };\n      }\n\n      return {\n        userId: user._id\n      };\n    } else {\n      // Tell the client to use the SRP upgrade process.\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n        format: 'srp',\n        identity: user.services.password.srp.identity\n      }));\n    }\n  }\n\n  return checkPassword(user, options.password);\n}); // Handler to login using the SRP upgrade path. To use this login\n// handler, the client must provide:\n//   - srp: H(identity + \":\" + password)\n//   - password: a string or an object with properties 'digest' and 'algorithm'\n//\n// We use `options.srp` to verify that the client knows the correct\n// password without doing a full SRP flow. Once we've checked that, we\n// upgrade the user to bcrypt and remove the SRP information from the\n// user document.\n//\n// The client ends up using this login handler after trying the normal\n// login handler (above), which throws an error telling the client to\n// try the SRP upgrade path.\n//\n// XXX COMPAT WITH 0.8.1.3\n\nAccounts.registerLoginHandler(\"password\", function (options) {\n  if (!options.srp || !options.password) {\n    return undefined; // don't handle\n  }\n\n  check(options, {\n    user: userQueryValidator,\n    srp: String,\n    password: passwordValidator\n  });\n\n  var user = Accounts._findUserByQuery(options.user);\n\n  if (!user) {\n    handleError(\"User not found\");\n  } // Check to see if another simultaneous login has already upgraded\n  // the user record to bcrypt.\n\n\n  if (user.services && user.services.password && user.services.password.bcrypt) {\n    return checkPassword(user, options.password);\n  }\n\n  if (!(user.services && user.services.password && user.services.password.srp)) {\n    handleError(\"User has no password set\");\n  }\n\n  var v1 = user.services.password.srp.verifier;\n  var v2 = SRP.generateVerifier(null, {\n    hashedIdentityAndPassword: options.srp,\n    salt: user.services.password.srp.salt\n  }).verifier;\n\n  if (v1 !== v2) {\n    return {\n      userId: Accounts._options.ambiguousErrorMessages ? null : user._id,\n      error: handleError(\"Incorrect password\", false)\n    };\n  } // Upgrade to bcrypt on successful login.\n\n\n  var salted = hashPassword(options.password);\n  Meteor.users.update(user._id, {\n    $unset: {\n      'services.password.srp': 1\n    },\n    $set: {\n      'services.password.bcrypt': salted\n    }\n  });\n  return {\n    userId: user._id\n  };\n}); ///\n/// CHANGING\n///\n\n/**\n * @summary Change a user's username. Use this instead of updating the\n * database directly. The operation will fail if there is an existing user\n * with a username only differing in case.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newUsername A new username for the user.\n * @importFromPackage accounts-base\n */\n\nAccounts.setUsername = function (userId, newUsername) {\n  check(userId, NonEmptyString);\n  check(newUsername, NonEmptyString);\n  var user = Meteor.users.findOne(userId);\n\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  var oldUsername = user.username; // Perform a case insensitive check for duplicates before update\n\n  checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $set: {\n      username: newUsername\n    }\n  }); // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n\n  try {\n    checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({\n      _id: user._id\n    }, {\n      $set: {\n        username: oldUsername\n      }\n    });\n    throw ex;\n  }\n}; // Let the user change their own password if they know the old\n// password. `oldPassword` and `newPassword` should be objects with keys\n// `digest` and `algorithm` (representing the SHA256 of the password).\n//\n// XXX COMPAT WITH 0.8.1.3\n// Like the login method, if the user hasn't been upgraded from SRP to\n// bcrypt yet, then this method will throw an 'old password format'\n// error. The client should call the SRP upgrade login handler and then\n// retry this method again.\n//\n// UNLIKE the login method, there is no way to avoid getting SRP upgrade\n// errors thrown. The reasoning for this is that clients using this\n// method directly will need to be updated anyway because we no longer\n// support the SRP flow that they would have been doing to use this\n// method previously.\n\n\nMeteor.methods({\n  changePassword: function (oldPassword, newPassword) {\n    check(oldPassword, passwordValidator);\n    check(newPassword, passwordValidator);\n\n    if (!this.userId) {\n      throw new Meteor.Error(401, \"Must be logged in\");\n    }\n\n    var user = Meteor.users.findOne(this.userId);\n\n    if (!user) {\n      handleError(\"User not found\");\n    }\n\n    if (!user.services || !user.services.password || !user.services.password.bcrypt && !user.services.password.srp) {\n      handleError(\"User has no password set\");\n    }\n\n    if (!user.services.password.bcrypt) {\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n        format: 'srp',\n        identity: user.services.password.srp.identity\n      }));\n    }\n\n    var result = checkPassword(user, oldPassword);\n\n    if (result.error) {\n      throw result.error;\n    }\n\n    var hashed = hashPassword(newPassword); // It would be better if this removed ALL existing tokens and replaced\n    // the token for the current connection with a new one, but that would\n    // be tricky, so we'll settle for just replacing all tokens other than\n    // the one for the current connection.\n\n    var currentToken = Accounts._getLoginToken(this.connection.id);\n\n    Meteor.users.update({\n      _id: this.userId\n    }, {\n      $set: {\n        'services.password.bcrypt': hashed\n      },\n      $pull: {\n        'services.resume.loginTokens': {\n          hashedToken: {\n            $ne: currentToken\n          }\n        }\n      },\n      $unset: {\n        'services.password.reset': 1\n      }\n    });\n    return {\n      passwordChanged: true\n    };\n  }\n}); // Force change the users password.\n\n/**\n * @summary Forcibly change the password for a user.\n * @locus Server\n * @param {String} userId The id of the user to update.\n * @param {String} newPassword A new password for the user.\n * @param {Object} [options]\n * @param {Object} options.logout Logout all current connections with this userId (default: true)\n * @importFromPackage accounts-base\n */\n\nAccounts.setPassword = function (userId, newPlaintextPassword, options) {\n  options = _.extend({\n    logout: true\n  }, options);\n  var user = Meteor.users.findOne(userId);\n\n  if (!user) {\n    throw new Meteor.Error(403, \"User not found\");\n  }\n\n  var update = {\n    $unset: {\n      'services.password.srp': 1,\n      // XXX COMPAT WITH 0.8.1.3\n      'services.password.reset': 1\n    },\n    $set: {\n      'services.password.bcrypt': hashPassword(newPlaintextPassword)\n    }\n  };\n\n  if (options.logout) {\n    update.$unset['services.resume.loginTokens'] = 1;\n  }\n\n  Meteor.users.update({\n    _id: user._id\n  }, update);\n}; ///\n/// RESETTING VIA EMAIL\n///\n// Method called by a user to request a password reset email. This is\n// the start of the reset process.\n\n\nMeteor.methods({\n  forgotPassword: function (options) {\n    check(options, {\n      email: String\n    });\n    var user = Accounts.findUserByEmail(options.email);\n\n    if (!user) {\n      handleError(\"User not found\");\n    }\n\n    const emails = _.pluck(user.emails || [], 'address');\n\n    const caseSensitiveEmail = _.find(emails, email => {\n      return email.toLowerCase() === options.email.toLowerCase();\n    });\n\n    Accounts.sendResetPasswordEmail(user._id, caseSensitiveEmail);\n  }\n});\n/**\n * @summary Generates a reset token and saves it into the database.\n * @locus Server\n * @param {String} userId The id of the user to generate the reset token for.\n * @param {String} email Which address of the user to generate the reset token for. This address must be in the user's `emails` list. If `null`, defaults to the first email in the list.\n * @param {String} reason `resetPassword` or `enrollAccount`.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token} values.\n * @importFromPackage accounts-base\n */\n\nAccounts.generateResetToken = function (userId, email, reason, extraTokenData) {\n  // Make sure the user exists, and email is one of their addresses.\n  var user = Meteor.users.findOne(userId);\n\n  if (!user) {\n    handleError(\"Can't find user\");\n  } // pick the first email if we weren't passed an email.\n\n\n  if (!email && user.emails && user.emails[0]) {\n    email = user.emails[0].address;\n  } // make sure we have a valid email\n\n\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email)) {\n    handleError(\"No such email for user.\");\n  }\n\n  var token = Random.secret();\n  var tokenRecord = {\n    token: token,\n    email: email,\n    when: new Date()\n  };\n\n  if (reason === 'resetPassword') {\n    tokenRecord.reason = 'reset';\n  } else if (reason === 'enrollAccount') {\n    tokenRecord.reason = 'enroll';\n  } else if (reason) {\n    // fallback so that this function can be used for unknown reasons as well\n    tokenRecord.reason = reason;\n  }\n\n  if (extraTokenData) {\n    _.extend(tokenRecord, extraTokenData);\n  }\n\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $set: {\n      'services.password.reset': tokenRecord\n    }\n  }); // before passing to template, update user object with new token\n\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n  return {\n    email,\n    user,\n    token\n  };\n};\n/**\n * @summary Generates an e-mail verification token and saves it into the database.\n * @locus Server\n * @param {String} userId The id of the user to generate the  e-mail verification token for.\n * @param {String} email Which address of the user to generate the e-mail verification token for. This address must be in the user's `emails` list. If `null`, defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token} values.\n * @importFromPackage accounts-base\n */\n\n\nAccounts.generateVerificationToken = function (userId, email, extraTokenData) {\n  // Make sure the user exists, and email is one of their addresses.\n  var user = Meteor.users.findOne(userId);\n\n  if (!user) {\n    handleError(\"Can't find user\");\n  } // pick the first unverified email if we weren't passed an email.\n\n\n  if (!email) {\n    var emailRecord = _.find(user.emails || [], function (e) {\n      return !e.verified;\n    });\n\n    email = (emailRecord || {}).address;\n\n    if (!email) {\n      handleError(\"That user has no unverified email addresses.\");\n    }\n  } // make sure we have a valid email\n\n\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email)) {\n    handleError(\"No such email for user.\");\n  }\n\n  var token = Random.secret();\n  var tokenRecord = {\n    token: token,\n    // TODO: This should probably be renamed to \"email\" to match reset token record.\n    address: email,\n    when: new Date()\n  };\n\n  if (extraTokenData) {\n    _.extend(tokenRecord, extraTokenData);\n  }\n\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $push: {\n      'services.email.verificationTokens': tokenRecord\n    }\n  }); // before passing to template, update user object with new token\n\n  Meteor._ensure(user, 'services', 'email');\n\n  if (!user.services.email.verificationTokens) {\n    user.services.email.verificationTokens = [];\n  }\n\n  user.services.email.verificationTokens.push(tokenRecord);\n  return {\n    email,\n    user,\n    token\n  };\n};\n/**\n * @summary Creates options for email sending for reset password and enroll account emails.\n * You can use this function when customizing a reset password or enroll account email sending.\n * @locus Server\n * @param {Object} email Which address of the user's to send the email to.\n * @param {Object} user The user object to generate options for.\n * @param {String} url URL to which user is directed to confirm the email.\n * @param {String} reason `resetPassword` or `enrollAccount`.\n * @returns {Object} Options which can be passed to `Email.send`.\n * @importFromPackage accounts-base\n */\n\n\nAccounts.generateOptionsForEmail = function (email, user, url, reason) {\n  var options = {\n    to: email,\n    from: Accounts.emailTemplates[reason].from ? Accounts.emailTemplates[reason].from(user) : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates[reason].subject(user)\n  };\n\n  if (typeof Accounts.emailTemplates[reason].text === 'function') {\n    options.text = Accounts.emailTemplates[reason].text(user, url);\n  }\n\n  if (typeof Accounts.emailTemplates[reason].html === 'function') {\n    options.html = Accounts.emailTemplates[reason].html(user, url);\n  }\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  return options;\n}; // send the user an email with a link that when opened allows the user\n// to set a new password, without the old password.\n\n/**\n * @summary Send an email with a link the user can use to reset their password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\n\n\nAccounts.sendResetPasswordEmail = function (userId, email, extraTokenData) {\n  const {\n    email: realEmail,\n    user,\n    token\n  } = Accounts.generateResetToken(userId, email, 'resetPassword', extraTokenData);\n  const url = Accounts.urls.resetPassword(token);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'resetPassword');\n  Email.send(options);\n  return {\n    email: realEmail,\n    user,\n    token,\n    url,\n    options\n  };\n}; // send the user an email informing them that their account was created, with\n// a link that when opened both marks their email as verified and forces them\n// to choose their password. The email must be one of the addresses in the\n// user's emails field, or undefined to pick the first email automatically.\n//\n// This is not called automatically. It must be called manually if you\n// want to use enrollment emails.\n\n/**\n * @summary Send an email with a link the user can use to set their initial password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\n\n\nAccounts.sendEnrollmentEmail = function (userId, email, extraTokenData) {\n  const {\n    email: realEmail,\n    user,\n    token\n  } = Accounts.generateResetToken(userId, email, 'enrollAccount', extraTokenData);\n  const url = Accounts.urls.enrollAccount(token);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'enrollAccount');\n  Email.send(options);\n  return {\n    email: realEmail,\n    user,\n    token,\n    url,\n    options\n  };\n}; // Take token from sendResetPasswordEmail or sendEnrollmentEmail, change\n// the users password, and log them in.\n\n\nMeteor.methods({\n  resetPassword: function (token, newPassword) {\n    var self = this;\n    return Accounts._loginMethod(self, \"resetPassword\", arguments, \"password\", function () {\n      check(token, String);\n      check(newPassword, passwordValidator);\n      var user = Meteor.users.findOne({\n        \"services.password.reset.token\": token\n      });\n\n      if (!user) {\n        throw new Meteor.Error(403, \"Token expired\");\n      }\n\n      var when = user.services.password.reset.when;\n      var reason = user.services.password.reset.reason;\n\n      var tokenLifetimeMs = Accounts._getPasswordResetTokenLifetimeMs();\n\n      if (reason === \"enroll\") {\n        tokenLifetimeMs = Accounts._getPasswordEnrollTokenLifetimeMs();\n      }\n\n      var currentTimeMs = Date.now();\n      if (currentTimeMs - when > tokenLifetimeMs) throw new Meteor.Error(403, \"Token expired\");\n      var email = user.services.password.reset.email;\n      if (!_.include(_.pluck(user.emails || [], 'address'), email)) return {\n        userId: user._id,\n        error: new Meteor.Error(403, \"Token has invalid email address\")\n      };\n      var hashed = hashPassword(newPassword); // NOTE: We're about to invalidate tokens on the user, who we might be\n      // logged in as. Make sure to avoid logging ourselves out if this\n      // happens. But also make sure not to leave the connection in a state\n      // of having a bad token set if things fail.\n\n      var oldToken = Accounts._getLoginToken(self.connection.id);\n\n      Accounts._setLoginToken(user._id, self.connection, null);\n\n      var resetToOldToken = function () {\n        Accounts._setLoginToken(user._id, self.connection, oldToken);\n      };\n\n      try {\n        // Update the user record by:\n        // - Changing the password to the new one\n        // - Forgetting about the reset token that was just used\n        // - Verifying their email, since they got the password reset via email.\n        var affectedRecords = Meteor.users.update({\n          _id: user._id,\n          'emails.address': email,\n          'services.password.reset.token': token\n        }, {\n          $set: {\n            'services.password.bcrypt': hashed,\n            'emails.$.verified': true\n          },\n          $unset: {\n            'services.password.reset': 1,\n            'services.password.srp': 1\n          }\n        });\n        if (affectedRecords !== 1) return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Invalid email\")\n        };\n      } catch (err) {\n        resetToOldToken();\n        throw err;\n      } // Replace all valid login tokens with new ones (changing\n      // password should invalidate existing sessions).\n\n\n      Accounts._clearAllLoginTokens(user._id);\n\n      return {\n        userId: user._id\n      };\n    });\n  }\n}); ///\n/// EMAIL VERIFICATION\n///\n// send the user an email with a link that when opened marks that\n// address as verified\n\n/**\n * @summary Send an email with a link the user can use verify their email address.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\n\nAccounts.sendVerificationEmail = function (userId, email, extraTokenData) {\n  // XXX Also generate a link using which someone can delete this\n  // account if they own said address but weren't those who created\n  // this account.\n  const {\n    email: realEmail,\n    user,\n    token\n  } = Accounts.generateVerificationToken(userId, email, extraTokenData);\n  const url = Accounts.urls.verifyEmail(token);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'verifyEmail');\n  Email.send(options);\n  return {\n    email: realEmail,\n    user,\n    token,\n    url,\n    options\n  };\n}; // Take token from sendVerificationEmail, mark the email as verified,\n// and log them in.\n\n\nMeteor.methods({\n  verifyEmail: function (token) {\n    var self = this;\n    return Accounts._loginMethod(self, \"verifyEmail\", arguments, \"password\", function () {\n      check(token, String);\n      var user = Meteor.users.findOne({\n        'services.email.verificationTokens.token': token\n      });\n      if (!user) throw new Meteor.Error(403, \"Verify email link expired\");\n\n      var tokenRecord = _.find(user.services.email.verificationTokens, function (t) {\n        return t.token == token;\n      });\n\n      if (!tokenRecord) return {\n        userId: user._id,\n        error: new Meteor.Error(403, \"Verify email link expired\")\n      };\n\n      var emailsRecord = _.find(user.emails, function (e) {\n        return e.address == tokenRecord.address;\n      });\n\n      if (!emailsRecord) return {\n        userId: user._id,\n        error: new Meteor.Error(403, \"Verify email link is for unknown address\")\n      }; // By including the address in the query, we can use 'emails.$' in the\n      // modifier to get a reference to the specific object in the emails\n      // array. See\n      // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)\n      // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull\n\n      Meteor.users.update({\n        _id: user._id,\n        'emails.address': tokenRecord.address\n      }, {\n        $set: {\n          'emails.$.verified': true\n        },\n        $pull: {\n          'services.email.verificationTokens': {\n            address: tokenRecord.address\n          }\n        }\n      });\n      return {\n        userId: user._id\n      };\n    });\n  }\n});\n/**\n * @summary Add an email address for a user. Use this instead of directly\n * updating the database. The operation will fail if there is a different user\n * with an email only differing in case. If the specified user has an existing\n * email only differing in case however, we replace it.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newEmail A new email address for the user.\n * @param {Boolean} [verified] Optional - whether the new email address should\n * be marked as verified. Defaults to false.\n * @importFromPackage accounts-base\n */\n\nAccounts.addEmail = function (userId, newEmail, verified) {\n  check(userId, NonEmptyString);\n  check(newEmail, NonEmptyString);\n  check(verified, Match.Optional(Boolean));\n\n  if (_.isUndefined(verified)) {\n    verified = false;\n  }\n\n  var user = Meteor.users.findOne(userId);\n  if (!user) throw new Meteor.Error(403, \"User not found\"); // Allow users to change their own email to a version with a different case\n  // We don't have to call checkForCaseInsensitiveDuplicates to do a case\n  // insensitive check across all emails in the database here because: (1) if\n  // there is no case-insensitive duplicate between this user and other users,\n  // then we are OK and (2) if this would create a conflict with other users\n  // then there would already be a case-insensitive duplicate and we can't fix\n  // that in this code anyway.\n\n  var caseInsensitiveRegExp = new RegExp('^' + Meteor._escapeRegExp(newEmail) + '$', 'i');\n\n  var didUpdateOwnEmail = _.any(user.emails, function (email, index) {\n    if (caseInsensitiveRegExp.test(email.address)) {\n      Meteor.users.update({\n        _id: user._id,\n        'emails.address': email.address\n      }, {\n        $set: {\n          'emails.$.address': newEmail,\n          'emails.$.verified': verified\n        }\n      });\n      return true;\n    }\n\n    return false;\n  }); // In the other updates below, we have to do another call to\n  // checkForCaseInsensitiveDuplicates to make sure that no conflicting values\n  // were added to the database in the meantime. We don't have to do this for\n  // the case where the user is updating their email address to one that is the\n  // same as before, but only different because of capitalization. Read the\n  // big comment above to understand why.\n\n\n  if (didUpdateOwnEmail) {\n    return;\n  } // Perform a case insensitive check for duplicates before update\n\n\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $addToSet: {\n      emails: {\n        address: newEmail,\n        verified: verified\n      }\n    }\n  }); // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n\n  try {\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({\n      _id: user._id\n    }, {\n      $pull: {\n        emails: {\n          address: newEmail\n        }\n      }\n    });\n    throw ex;\n  }\n};\n/**\n * @summary Remove an email address for a user. Use this instead of updating\n * the database directly.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} email The email address to remove.\n * @importFromPackage accounts-base\n */\n\n\nAccounts.removeEmail = function (userId, email) {\n  check(userId, NonEmptyString);\n  check(email, NonEmptyString);\n  var user = Meteor.users.findOne(userId);\n  if (!user) throw new Meteor.Error(403, \"User not found\");\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $pull: {\n      emails: {\n        address: email\n      }\n    }\n  });\n}; ///\n/// CREATING USERS\n///\n// Shared createUser function called from the createUser method, both\n// if originates in client or server code. Calls user provided hooks,\n// does the actual user insertion.\n//\n// returns the user id\n\n\nvar createUser = function (options) {\n  // Unknown keys allowed, because a onCreateUserHook can take arbitrary\n  // options.\n  check(options, Match.ObjectIncluding({\n    username: Match.Optional(String),\n    email: Match.Optional(String),\n    password: Match.Optional(passwordValidator)\n  }));\n  var username = options.username;\n  var email = options.email;\n  if (!username && !email) throw new Meteor.Error(400, \"Need to set a username or email\");\n  var user = {\n    services: {}\n  };\n\n  if (options.password) {\n    var hashed = hashPassword(options.password);\n    user.services.password = {\n      bcrypt: hashed\n    };\n  }\n\n  if (username) user.username = username;\n  if (email) user.emails = [{\n    address: email,\n    verified: false\n  }]; // Perform a case insensitive check before insert\n\n  checkForCaseInsensitiveDuplicates('username', 'Username', username);\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', email);\n  var userId = Accounts.insertUserDoc(options, user); // Perform another check after insert, in case a matching user has been\n  // inserted in the meantime\n\n  try {\n    checkForCaseInsensitiveDuplicates('username', 'Username', username, userId);\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', email, userId);\n  } catch (ex) {\n    // Remove inserted user if the check fails\n    Meteor.users.remove(userId);\n    throw ex;\n  }\n\n  return userId;\n}; // method for create user. Requests come from the client.\n\n\nMeteor.methods({\n  createUser: function (options) {\n    var self = this;\n    return Accounts._loginMethod(self, \"createUser\", arguments, \"password\", function () {\n      // createUser() above does more checking.\n      check(options, Object);\n      if (Accounts._options.forbidClientAccountCreation) return {\n        error: new Meteor.Error(403, \"Signups forbidden\")\n      }; // Create user. result contains id and token.\n\n      var userId = createUser(options); // safety belt. createUser is supposed to throw on error. send 500 error\n      // instead of sending a verification email with empty userid.\n\n      if (!userId) throw new Error(\"createUser failed to insert new user\"); // If `Accounts._options.sendVerificationEmail` is set, register\n      // a token to verify the user's primary email, and send it to\n      // that address.\n\n      if (options.email && Accounts._options.sendVerificationEmail) Accounts.sendVerificationEmail(userId, options.email); // client gets logged in as the new user afterwards.\n\n      return {\n        userId: userId\n      };\n    });\n  }\n}); // Create user directly on the server.\n//\n// Unlike the client version, this does not log you in as this user\n// after creation.\n//\n// returns userId or throws an error if it can't create\n//\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,\n// which is always empty when called from the createUser method? eg, \"admin:\n// true\", which we want to prevent the client from setting, but which a custom\n// method calling Accounts.createUser could set?\n//\n\nAccounts.createUser = function (options, callback) {\n  options = _.clone(options); // XXX allow an optional callback?\n\n  if (callback) {\n    throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");\n  }\n\n  return createUser(options);\n}; ///\n/// PASSWORD-SPECIFIC INDEXES ON USERS\n///\n\n\nMeteor.users._ensureIndex('services.email.verificationTokens.token', {\n  unique: 1,\n  sparse: 1\n});\n\nMeteor.users._ensureIndex('services.password.reset.token', {\n  unique: 1,\n  sparse: 1\n});","map":{"version":3,"sources":["packages/accounts-password/password_server.js"],"names":["bcrypt","NpmModuleBcrypt","bcryptHash","Meteor","wrapAsync","hash","bcryptCompare","compare","Accounts","_bcryptRounds","_options","bcryptRounds","getPasswordString","password","SHA256","algorithm","Error","digest","hashPassword","getRoundsFromBcryptHash","rounds","hashSegments","split","length","parseInt","_checkPassword","user","result","userId","_id","formattedPassword","services","hashRounds","error","handleError","defer","users","update","$set","checkPassword","msg","throwError","ambiguousErrorMessages","_findUserByQuery","query","id","findOne","fieldName","fieldValue","username","email","selector","selectorForFastCaseInsensitiveLookup","candidateUsers","find","fetch","findUserByUsername","findUserByEmail","string","prefix","substring","Math","min","orClause","_","map","generateCasePermutationsForString","prefixPermutation","RegExp","_escapeRegExp","caseInsensitiveClause","$and","$or","permutations","i","ch","charAt","flatten","lowerCaseChar","toLowerCase","upperCaseChar","toUpperCase","checkForCaseInsensitiveDuplicates","displayName","ownUserId","skipCheck","has","_skipCaseInsensitiveChecksForTest","matchedUsers","NonEmptyString","Match","Where","x","check","String","userQueryValidator","Optional","keys","passwordValidator","OneOf","registerLoginHandler","options","srp","undefined","verifier","newVerifier","SRP","generateVerifier","identity","salt","EJSON","stringify","format","v1","v2","hashedIdentityAndPassword","salted","$unset","setUsername","newUsername","oldUsername","ex","methods","changePassword","oldPassword","newPassword","hashed","currentToken","_getLoginToken","connection","$pull","hashedToken","$ne","passwordChanged","setPassword","newPlaintextPassword","extend","logout","forgotPassword","emails","pluck","caseSensitiveEmail","sendResetPasswordEmail","generateResetToken","reason","extraTokenData","address","contains","token","Random","secret","tokenRecord","when","Date","_ensure","reset","generateVerificationToken","emailRecord","e","verified","$push","verificationTokens","push","generateOptionsForEmail","url","to","from","emailTemplates","subject","text","html","headers","realEmail","urls","resetPassword","Email","send","sendEnrollmentEmail","enrollAccount","self","_loginMethod","arguments","tokenLifetimeMs","_getPasswordResetTokenLifetimeMs","_getPasswordEnrollTokenLifetimeMs","currentTimeMs","now","include","oldToken","_setLoginToken","resetToOldToken","affectedRecords","err","_clearAllLoginTokens","sendVerificationEmail","verifyEmail","t","emailsRecord","addEmail","newEmail","Boolean","isUndefined","caseInsensitiveRegExp","didUpdateOwnEmail","any","index","test","$addToSet","removeEmail","createUser","ObjectIncluding","insertUserDoc","remove","Object","forbidClientAccountCreation","callback","clone","_ensureIndex","unique","sparse"],"mappings":"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","sourcesContent":["/// BCRYPT\n\nvar bcrypt = NpmModuleBcrypt;\nvar bcryptHash = Meteor.wrapAsync(bcrypt.hash);\nvar bcryptCompare = Meteor.wrapAsync(bcrypt.compare);\n\n// User records have a 'services.password.bcrypt' field on them to hold\n// their hashed passwords (unless they have a 'services.password.srp'\n// field, in which case they will be upgraded to bcrypt the next time\n// they log in).\n//\n// When the client sends a password to the server, it can either be a\n// string (the plaintext password) or an object with keys 'digest' and\n// 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends\n// password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients\n// that don't have access to SHA can just send plaintext passwords as\n// strings.\n//\n// When the server receives a plaintext password as a string, it always\n// hashes it with SHA256 before passing it into bcrypt. When the server\n// receives a password as an object, it asserts that the algorithm is\n// \"sha-256\" and then passes the digest to bcrypt.\n\n\nAccounts._bcryptRounds = () => Accounts._options.bcryptRounds || 10;\n\n// Given a 'password' from the client, extract the string that we should\n// bcrypt. 'password' can be one of:\n//  - String (the plaintext password)\n//  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".\n//\nvar getPasswordString = function (password) {\n  if (typeof password === \"string\") {\n    password = SHA256(password);\n  } else { // 'password' is an object\n    if (password.algorithm !== \"sha-256\") {\n      throw new Error(\"Invalid password hash algorithm. \" +\n                      \"Only 'sha-256' is allowed.\");\n    }\n    password = password.digest;\n  }\n  return password;\n};\n\n// Use bcrypt to hash the password for storage in the database.\n// `password` can be a string (in which case it will be run through\n// SHA256 before bcrypt) or an object with properties `digest` and\n// `algorithm` (in which case we bcrypt `password.digest`).\n//\nvar hashPassword = function (password) {\n  password = getPasswordString(password);\n  return bcryptHash(password, Accounts._bcryptRounds());\n};\n\n// Extract the number of rounds used in the specified bcrypt hash.\nconst getRoundsFromBcryptHash = hash => {\n  let rounds;\n  if (hash) {\n    const hashSegments = hash.split('$');\n    if (hashSegments.length > 2) {\n      rounds = parseInt(hashSegments[2], 10);\n    }\n  }\n  return rounds;\n};\n\n// Check whether the provided password matches the bcrypt'ed password in\n// the database user record. `password` can be a string (in which case\n// it will be run through SHA256 before bcrypt) or an object with\n// properties `digest` and `algorithm` (in which case we bcrypt\n// `password.digest`).\n//\nAccounts._checkPassword = function (user, password) {\n  var result = {\n    userId: user._id\n  };\n\n  const formattedPassword = getPasswordString(password);\n  const hash = user.services.password.bcrypt;\n  const hashRounds = getRoundsFromBcryptHash(hash);\n\n  if (! bcryptCompare(formattedPassword, hash)) {\n    result.error = handleError(\"Incorrect password\", false);\n  } else if (hash && Accounts._bcryptRounds() != hashRounds) {\n    // The password checks out, but the user's bcrypt hash needs to be updated.\n    Meteor.defer(() => {\n      Meteor.users.update({ _id: user._id }, {\n        $set: {\n          'services.password.bcrypt':\n            bcryptHash(formattedPassword, Accounts._bcryptRounds())\n        }\n      });\n    });\n  }\n\n  return result;\n};\nvar checkPassword = Accounts._checkPassword;\n\n///\n/// ERROR HANDLER\n///\nconst handleError = (msg, throwError = true) => {\n  const error = new Meteor.Error(\n    403,\n    Accounts._options.ambiguousErrorMessages\n      ? \"Something went wrong. Please check your credentials.\"\n      : msg\n  );\n  if (throwError) {\n    throw error;\n  }\n  return error;\n};\n\n///\n/// LOGIN\n///\n\nAccounts._findUserByQuery = function (query) {\n  var user = null;\n\n  if (query.id) {\n    user = Meteor.users.findOne({ _id: query.id });\n  } else {\n    var fieldName;\n    var fieldValue;\n    if (query.username) {\n      fieldName = 'username';\n      fieldValue = query.username;\n    } else if (query.email) {\n      fieldName = 'emails.address';\n      fieldValue = query.email;\n    } else {\n      throw new Error(\"shouldn't happen (validation missed something)\");\n    }\n    var selector = {};\n    selector[fieldName] = fieldValue;\n    user = Meteor.users.findOne(selector);\n    // If user is not found, try a case insensitive lookup\n    if (!user) {\n      selector = selectorForFastCaseInsensitiveLookup(fieldName, fieldValue);\n      var candidateUsers = Meteor.users.find(selector).fetch();\n      // No match if multiple candidates are found\n      if (candidateUsers.length === 1) {\n        user = candidateUsers[0];\n      }\n    }\n  }\n\n  return user;\n};\n\n/**\n * @summary Finds the user with the specified username.\n * First tries to match username case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} username The username to look for\n * @returns {Object} A user if found, else null\n * @importFromPackage accounts-base\n */\nAccounts.findUserByUsername = function (username) {\n  return Accounts._findUserByQuery({\n    username: username\n  });\n};\n\n/**\n * @summary Finds the user with the specified email.\n * First tries to match email case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} email The email address to look for\n * @returns {Object} A user if found, else null\n * @importFromPackage accounts-base\n */\nAccounts.findUserByEmail = function (email) {\n  return Accounts._findUserByQuery({\n    email: email\n  });\n};\n\n// Generates a MongoDB selector that can be used to perform a fast case\n// insensitive lookup for the given fieldName and string. Since MongoDB does\n// not support case insensitive indexes, and case insensitive regex queries\n// are slow, we construct a set of prefix selectors for all permutations of\n// the first 4 characters ourselves. We first attempt to matching against\n// these, and because 'prefix expression' regex queries do use indexes (see\n// http://docs.mongodb.org/v2.6/reference/operator/query/regex/#index-use),\n// this has been found to greatly improve performance (from 1200ms to 5ms in a\n// test with 1.000.000 users).\nvar selectorForFastCaseInsensitiveLookup = function (fieldName, string) {\n  // Performance seems to improve up to 4 prefix characters\n  var prefix = string.substring(0, Math.min(string.length, 4));\n  var orClause = _.map(generateCasePermutationsForString(prefix),\n    function (prefixPermutation) {\n      var selector = {};\n      selector[fieldName] =\n        new RegExp('^' + Meteor._escapeRegExp(prefixPermutation));\n      return selector;\n    });\n  var caseInsensitiveClause = {};\n  caseInsensitiveClause[fieldName] =\n    new RegExp('^' + Meteor._escapeRegExp(string) + '$', 'i')\n  return {$and: [{$or: orClause}, caseInsensitiveClause]};\n}\n\n// Generates permutations of all case variations of a given string.\nvar generateCasePermutationsForString = function (string) {\n  var permutations = [''];\n  for (var i = 0; i < string.length; i++) {\n    var ch = string.charAt(i);\n    permutations = _.flatten(_.map(permutations, function (prefix) {\n      var lowerCaseChar = ch.toLowerCase();\n      var upperCaseChar = ch.toUpperCase();\n      // Don't add unneccesary permutations when ch is not a letter\n      if (lowerCaseChar === upperCaseChar) {\n        return [prefix + ch];\n      } else {\n        return [prefix + lowerCaseChar, prefix + upperCaseChar];\n      }\n    }));\n  }\n  return permutations;\n}\n\nvar checkForCaseInsensitiveDuplicates = function (fieldName, displayName, fieldValue, ownUserId) {\n  // Some tests need the ability to add users with the same case insensitive\n  // value, hence the _skipCaseInsensitiveChecksForTest check\n  var skipCheck = _.has(Accounts._skipCaseInsensitiveChecksForTest, fieldValue);\n\n  if (fieldValue && !skipCheck) {\n    var matchedUsers = Meteor.users.find(\n      selectorForFastCaseInsensitiveLookup(fieldName, fieldValue)).fetch();\n\n    if (matchedUsers.length > 0 &&\n        // If we don't have a userId yet, any match we find is a duplicate\n        (!ownUserId ||\n        // Otherwise, check to see if there are multiple matches or a match\n        // that is not us\n        (matchedUsers.length > 1 || matchedUsers[0]._id !== ownUserId))) {\n      handleError(displayName + \" already exists.\");\n    }\n  }\n};\n\n// XXX maybe this belongs in the check package\nvar NonEmptyString = Match.Where(function (x) {\n  check(x, String);\n  return x.length > 0;\n});\n\nvar userQueryValidator = Match.Where(function (user) {\n  check(user, {\n    id: Match.Optional(NonEmptyString),\n    username: Match.Optional(NonEmptyString),\n    email: Match.Optional(NonEmptyString)\n  });\n  if (_.keys(user).length !== 1)\n    throw new Match.Error(\"User property must have exactly one field\");\n  return true;\n});\n\nvar passwordValidator = Match.OneOf(\n  String,\n  { digest: String, algorithm: String }\n);\n\n// Handler to login with a password.\n//\n// The Meteor client sets options.password to an object with keys\n// 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").\n//\n// For other DDP clients which don't have access to SHA, the handler\n// also accepts the plaintext password in options.password as a string.\n//\n// (It might be nice if servers could turn the plaintext password\n// option off. Or maybe it should be opt-in, not opt-out?\n// Accounts.config option?)\n//\n// Note that neither password option is secure without SSL.\n//\nAccounts.registerLoginHandler(\"password\", function (options) {\n  if (! options.password || options.srp)\n    return undefined; // don't handle\n\n  check(options, {\n    user: userQueryValidator,\n    password: passwordValidator\n  });\n\n\n  var user = Accounts._findUserByQuery(options.user);\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  if (!user.services || !user.services.password ||\n      !(user.services.password.bcrypt || user.services.password.srp)) {\n    handleError(\"User has no password set\");\n  }\n\n  if (!user.services.password.bcrypt) {\n    if (typeof options.password === \"string\") {\n      // The client has presented a plaintext password, and the user is\n      // not upgraded to bcrypt yet. We don't attempt to tell the client\n      // to upgrade to bcrypt, because it might be a standalone DDP\n      // client doesn't know how to do such a thing.\n      var verifier = user.services.password.srp;\n      var newVerifier = SRP.generateVerifier(options.password, {\n        identity: verifier.identity, salt: verifier.salt});\n\n      if (verifier.verifier !== newVerifier.verifier) {\n        return {\n          userId: Accounts._options.ambiguousErrorMessages ? null : user._id,\n          error: handleError(\"Incorrect password\", false)\n        };\n      }\n\n      return {userId: user._id};\n    } else {\n      // Tell the client to use the SRP upgrade process.\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n        format: 'srp',\n        identity: user.services.password.srp.identity\n      }));\n    }\n  }\n\n  return checkPassword(\n    user,\n    options.password\n  );\n});\n\n// Handler to login using the SRP upgrade path. To use this login\n// handler, the client must provide:\n//   - srp: H(identity + \":\" + password)\n//   - password: a string or an object with properties 'digest' and 'algorithm'\n//\n// We use `options.srp` to verify that the client knows the correct\n// password without doing a full SRP flow. Once we've checked that, we\n// upgrade the user to bcrypt and remove the SRP information from the\n// user document.\n//\n// The client ends up using this login handler after trying the normal\n// login handler (above), which throws an error telling the client to\n// try the SRP upgrade path.\n//\n// XXX COMPAT WITH 0.8.1.3\nAccounts.registerLoginHandler(\"password\", function (options) {\n  if (!options.srp || !options.password) {\n    return undefined; // don't handle\n  }\n\n  check(options, {\n    user: userQueryValidator,\n    srp: String,\n    password: passwordValidator\n  });\n\n  var user = Accounts._findUserByQuery(options.user);\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  // Check to see if another simultaneous login has already upgraded\n  // the user record to bcrypt.\n  if (user.services && user.services.password && user.services.password.bcrypt) {\n    return checkPassword(user, options.password);\n  }\n\n  if (!(user.services && user.services.password && user.services.password.srp)) {\n    handleError(\"User has no password set\");\n  }\n\n  var v1 = user.services.password.srp.verifier;\n  var v2 = SRP.generateVerifier(\n    null,\n    {\n      hashedIdentityAndPassword: options.srp,\n      salt: user.services.password.srp.salt\n    }\n  ).verifier;\n  if (v1 !== v2) {\n    return {\n      userId: Accounts._options.ambiguousErrorMessages ? null : user._id,\n      error: handleError(\"Incorrect password\", false)\n    };\n  }\n\n  // Upgrade to bcrypt on successful login.\n  var salted = hashPassword(options.password);\n  Meteor.users.update(\n    user._id,\n    {\n      $unset: { 'services.password.srp': 1 },\n      $set: { 'services.password.bcrypt': salted }\n    }\n  );\n\n  return {userId: user._id};\n});\n\n\n///\n/// CHANGING\n///\n\n/**\n * @summary Change a user's username. Use this instead of updating the\n * database directly. The operation will fail if there is an existing user\n * with a username only differing in case.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newUsername A new username for the user.\n * @importFromPackage accounts-base\n */\nAccounts.setUsername = function (userId, newUsername) {\n  check(userId, NonEmptyString);\n  check(newUsername, NonEmptyString);\n\n  var user = Meteor.users.findOne(userId);\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  var oldUsername = user.username;\n\n  // Perform a case insensitive check for duplicates before update\n  checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n\n  Meteor.users.update({_id: user._id}, {$set: {username: newUsername}});\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({_id: user._id}, {$set: {username: oldUsername}});\n    throw ex;\n  }\n};\n\n// Let the user change their own password if they know the old\n// password. `oldPassword` and `newPassword` should be objects with keys\n// `digest` and `algorithm` (representing the SHA256 of the password).\n//\n// XXX COMPAT WITH 0.8.1.3\n// Like the login method, if the user hasn't been upgraded from SRP to\n// bcrypt yet, then this method will throw an 'old password format'\n// error. The client should call the SRP upgrade login handler and then\n// retry this method again.\n//\n// UNLIKE the login method, there is no way to avoid getting SRP upgrade\n// errors thrown. The reasoning for this is that clients using this\n// method directly will need to be updated anyway because we no longer\n// support the SRP flow that they would have been doing to use this\n// method previously.\nMeteor.methods({changePassword: function (oldPassword, newPassword) {\n  check(oldPassword, passwordValidator);\n  check(newPassword, passwordValidator);\n\n  if (!this.userId) {\n    throw new Meteor.Error(401, \"Must be logged in\");\n  }\n\n  var user = Meteor.users.findOne(this.userId);\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  if (!user.services || !user.services.password ||\n      (!user.services.password.bcrypt && !user.services.password.srp)) {\n    handleError(\"User has no password set\");\n  }\n\n  if (! user.services.password.bcrypt) {\n    throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n      format: 'srp',\n      identity: user.services.password.srp.identity\n    }));\n  }\n\n  var result = checkPassword(user, oldPassword);\n  if (result.error) {\n    throw result.error;\n  }\n\n  var hashed = hashPassword(newPassword);\n\n  // It would be better if this removed ALL existing tokens and replaced\n  // the token for the current connection with a new one, but that would\n  // be tricky, so we'll settle for just replacing all tokens other than\n  // the one for the current connection.\n  var currentToken = Accounts._getLoginToken(this.connection.id);\n  Meteor.users.update(\n    { _id: this.userId },\n    {\n      $set: { 'services.password.bcrypt': hashed },\n      $pull: {\n        'services.resume.loginTokens': { hashedToken: { $ne: currentToken } }\n      },\n      $unset: { 'services.password.reset': 1 }\n    }\n  );\n\n  return {passwordChanged: true};\n}});\n\n\n// Force change the users password.\n\n/**\n * @summary Forcibly change the password for a user.\n * @locus Server\n * @param {String} userId The id of the user to update.\n * @param {String} newPassword A new password for the user.\n * @param {Object} [options]\n * @param {Object} options.logout Logout all current connections with this userId (default: true)\n * @importFromPackage accounts-base\n */\nAccounts.setPassword = function (userId, newPlaintextPassword, options) {\n  options = _.extend({logout: true}, options);\n\n  var user = Meteor.users.findOne(userId);\n  if (!user) {\n    throw new Meteor.Error(403, \"User not found\");\n  }\n\n  var update = {\n    $unset: {\n      'services.password.srp': 1, // XXX COMPAT WITH 0.8.1.3\n      'services.password.reset': 1\n    },\n    $set: {'services.password.bcrypt': hashPassword(newPlaintextPassword)}\n  };\n\n  if (options.logout) {\n    update.$unset['services.resume.loginTokens'] = 1;\n  }\n\n  Meteor.users.update({_id: user._id}, update);\n};\n\n\n///\n/// RESETTING VIA EMAIL\n///\n\n// Method called by a user to request a password reset email. This is\n// the start of the reset process.\nMeteor.methods({forgotPassword: function (options) {\n  check(options, {email: String});\n\n  var user = Accounts.findUserByEmail(options.email);\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  const emails = _.pluck(user.emails || [], 'address');\n  const caseSensitiveEmail = _.find(emails, email => {\n    return email.toLowerCase() === options.email.toLowerCase();\n  });\n\n  Accounts.sendResetPasswordEmail(user._id, caseSensitiveEmail);\n}});\n\n/**\n * @summary Generates a reset token and saves it into the database.\n * @locus Server\n * @param {String} userId The id of the user to generate the reset token for.\n * @param {String} email Which address of the user to generate the reset token for. This address must be in the user's `emails` list. If `null`, defaults to the first email in the list.\n * @param {String} reason `resetPassword` or `enrollAccount`.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token} values.\n * @importFromPackage accounts-base\n */\nAccounts.generateResetToken = function (userId, email, reason, extraTokenData) {\n  // Make sure the user exists, and email is one of their addresses.\n  var user = Meteor.users.findOne(userId);\n  if (!user) {\n    handleError(\"Can't find user\");\n  }\n\n  // pick the first email if we weren't passed an email.\n  if (!email && user.emails && user.emails[0]) {\n    email = user.emails[0].address;\n  }\n\n  // make sure we have a valid email\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email)) {\n    handleError(\"No such email for user.\");\n  }\n\n  var token = Random.secret();\n  var tokenRecord = {\n    token: token,\n    email: email,\n    when: new Date()\n  };\n\n  if (reason === 'resetPassword') {\n    tokenRecord.reason = 'reset';\n  } else if (reason === 'enrollAccount') {\n    tokenRecord.reason = 'enroll';\n  } else if (reason) {\n    // fallback so that this function can be used for unknown reasons as well\n    tokenRecord.reason = reason;\n  }\n\n  if (extraTokenData) {\n    _.extend(tokenRecord, extraTokenData);\n  }\n\n  Meteor.users.update({_id: user._id}, {$set: {\n    'services.password.reset': tokenRecord\n  }});\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n\n  return {email, user, token};\n};\n\n/**\n * @summary Generates an e-mail verification token and saves it into the database.\n * @locus Server\n * @param {String} userId The id of the user to generate the  e-mail verification token for.\n * @param {String} email Which address of the user to generate the e-mail verification token for. This address must be in the user's `emails` list. If `null`, defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token} values.\n * @importFromPackage accounts-base\n */\nAccounts.generateVerificationToken = function (userId, email, extraTokenData) {\n  // Make sure the user exists, and email is one of their addresses.\n  var user = Meteor.users.findOne(userId);\n  if (!user) {\n    handleError(\"Can't find user\");\n  }\n\n  // pick the first unverified email if we weren't passed an email.\n  if (!email) {\n    var emailRecord = _.find(user.emails || [], function (e) { return !e.verified; });\n    email = (emailRecord || {}).address;\n\n    if (!email) {\n      handleError(\"That user has no unverified email addresses.\");\n    }\n  }\n\n  // make sure we have a valid email\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email)) {\n    handleError(\"No such email for user.\");\n  }\n\n  var token = Random.secret();\n  var tokenRecord = {\n    token: token,\n    // TODO: This should probably be renamed to \"email\" to match reset token record.\n    address: email,\n    when: new Date()\n  };\n\n  if (extraTokenData) {\n    _.extend(tokenRecord, extraTokenData);\n  }\n\n  Meteor.users.update({_id: user._id}, {$push: {\n    'services.email.verificationTokens': tokenRecord\n  }});\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'email');\n  if (!user.services.email.verificationTokens) {\n    user.services.email.verificationTokens = [];\n  }\n  user.services.email.verificationTokens.push(tokenRecord);\n\n  return {email, user, token};\n};\n\n/**\n * @summary Creates options for email sending for reset password and enroll account emails.\n * You can use this function when customizing a reset password or enroll account email sending.\n * @locus Server\n * @param {Object} email Which address of the user's to send the email to.\n * @param {Object} user The user object to generate options for.\n * @param {String} url URL to which user is directed to confirm the email.\n * @param {String} reason `resetPassword` or `enrollAccount`.\n * @returns {Object} Options which can be passed to `Email.send`.\n * @importFromPackage accounts-base\n */\nAccounts.generateOptionsForEmail = function (email, user, url, reason) {\n  var options = {\n    to: email,\n    from: Accounts.emailTemplates[reason].from\n      ? Accounts.emailTemplates[reason].from(user)\n      : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates[reason].subject(user)\n  };\n\n  if (typeof Accounts.emailTemplates[reason].text === 'function') {\n    options.text = Accounts.emailTemplates[reason].text(user, url);\n  }\n\n  if (typeof Accounts.emailTemplates[reason].html === 'function') {\n    options.html = Accounts.emailTemplates[reason].html(user, url);\n  }\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  return options;\n};\n\n// send the user an email with a link that when opened allows the user\n// to set a new password, without the old password.\n\n/**\n * @summary Send an email with a link the user can use to reset their password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendResetPasswordEmail = function (userId, email, extraTokenData) {\n  const {email: realEmail, user, token} =\n    Accounts.generateResetToken(userId, email, 'resetPassword', extraTokenData);\n  const url = Accounts.urls.resetPassword(token);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'resetPassword');\n  Email.send(options);\n  return {email: realEmail, user, token, url, options};\n};\n\n// send the user an email informing them that their account was created, with\n// a link that when opened both marks their email as verified and forces them\n// to choose their password. The email must be one of the addresses in the\n// user's emails field, or undefined to pick the first email automatically.\n//\n// This is not called automatically. It must be called manually if you\n// want to use enrollment emails.\n\n/**\n * @summary Send an email with a link the user can use to set their initial password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendEnrollmentEmail = function (userId, email, extraTokenData) {\n  const {email: realEmail, user, token} =\n    Accounts.generateResetToken(userId, email, 'enrollAccount', extraTokenData);\n  const url = Accounts.urls.enrollAccount(token);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'enrollAccount');\n  Email.send(options);\n  return {email: realEmail, user, token, url, options};\n};\n\n\n// Take token from sendResetPasswordEmail or sendEnrollmentEmail, change\n// the users password, and log them in.\nMeteor.methods({resetPassword: function (token, newPassword) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"resetPassword\",\n    arguments,\n    \"password\",\n    function () {\n      check(token, String);\n      check(newPassword, passwordValidator);\n\n      var user = Meteor.users.findOne({\n        \"services.password.reset.token\": token});\n      if (!user) {\n        throw new Meteor.Error(403, \"Token expired\");\n      }\n      var when = user.services.password.reset.when;\n      var reason = user.services.password.reset.reason;\n      var tokenLifetimeMs = Accounts._getPasswordResetTokenLifetimeMs();\n      if (reason === \"enroll\") {\n        tokenLifetimeMs = Accounts._getPasswordEnrollTokenLifetimeMs();\n      }\n      var currentTimeMs = Date.now();\n      if ((currentTimeMs - when) > tokenLifetimeMs)\n        throw new Meteor.Error(403, \"Token expired\");\n      var email = user.services.password.reset.email;\n      if (!_.include(_.pluck(user.emails || [], 'address'), email))\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Token has invalid email address\")\n        };\n\n      var hashed = hashPassword(newPassword);\n\n      // NOTE: We're about to invalidate tokens on the user, who we might be\n      // logged in as. Make sure to avoid logging ourselves out if this\n      // happens. But also make sure not to leave the connection in a state\n      // of having a bad token set if things fail.\n      var oldToken = Accounts._getLoginToken(self.connection.id);\n      Accounts._setLoginToken(user._id, self.connection, null);\n      var resetToOldToken = function () {\n        Accounts._setLoginToken(user._id, self.connection, oldToken);\n      };\n\n      try {\n        // Update the user record by:\n        // - Changing the password to the new one\n        // - Forgetting about the reset token that was just used\n        // - Verifying their email, since they got the password reset via email.\n        var affectedRecords = Meteor.users.update(\n          {\n            _id: user._id,\n            'emails.address': email,\n            'services.password.reset.token': token\n          },\n          {$set: {'services.password.bcrypt': hashed,\n                  'emails.$.verified': true},\n           $unset: {'services.password.reset': 1,\n                    'services.password.srp': 1}});\n        if (affectedRecords !== 1)\n          return {\n            userId: user._id,\n            error: new Meteor.Error(403, \"Invalid email\")\n          };\n      } catch (err) {\n        resetToOldToken();\n        throw err;\n      }\n\n      // Replace all valid login tokens with new ones (changing\n      // password should invalidate existing sessions).\n      Accounts._clearAllLoginTokens(user._id);\n\n      return {userId: user._id};\n    }\n  );\n}});\n\n///\n/// EMAIL VERIFICATION\n///\n\n\n// send the user an email with a link that when opened marks that\n// address as verified\n\n/**\n * @summary Send an email with a link the user can use verify their email address.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendVerificationEmail = function (userId, email, extraTokenData) {\n  // XXX Also generate a link using which someone can delete this\n  // account if they own said address but weren't those who created\n  // this account.\n\n  const {email: realEmail, user, token} =\n    Accounts.generateVerificationToken(userId, email, extraTokenData);\n  const url = Accounts.urls.verifyEmail(token);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'verifyEmail');\n  Email.send(options);\n  return {email: realEmail, user, token, url, options};\n};\n\n// Take token from sendVerificationEmail, mark the email as verified,\n// and log them in.\nMeteor.methods({verifyEmail: function (token) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"verifyEmail\",\n    arguments,\n    \"password\",\n    function () {\n      check(token, String);\n\n      var user = Meteor.users.findOne(\n        {'services.email.verificationTokens.token': token});\n      if (!user)\n        throw new Meteor.Error(403, \"Verify email link expired\");\n\n      var tokenRecord = _.find(user.services.email.verificationTokens,\n                               function (t) {\n                                 return t.token == token;\n                               });\n      if (!tokenRecord)\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link expired\")\n        };\n\n      var emailsRecord = _.find(user.emails, function (e) {\n        return e.address == tokenRecord.address;\n      });\n      if (!emailsRecord)\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link is for unknown address\")\n        };\n\n      // By including the address in the query, we can use 'emails.$' in the\n      // modifier to get a reference to the specific object in the emails\n      // array. See\n      // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)\n      // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull\n      Meteor.users.update(\n        {_id: user._id,\n         'emails.address': tokenRecord.address},\n        {$set: {'emails.$.verified': true},\n         $pull: {'services.email.verificationTokens': {address: tokenRecord.address}}});\n\n      return {userId: user._id};\n    }\n  );\n}});\n\n/**\n * @summary Add an email address for a user. Use this instead of directly\n * updating the database. The operation will fail if there is a different user\n * with an email only differing in case. If the specified user has an existing\n * email only differing in case however, we replace it.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newEmail A new email address for the user.\n * @param {Boolean} [verified] Optional - whether the new email address should\n * be marked as verified. Defaults to false.\n * @importFromPackage accounts-base\n */\nAccounts.addEmail = function (userId, newEmail, verified) {\n  check(userId, NonEmptyString);\n  check(newEmail, NonEmptyString);\n  check(verified, Match.Optional(Boolean));\n\n  if (_.isUndefined(verified)) {\n    verified = false;\n  }\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  // Allow users to change their own email to a version with a different case\n\n  // We don't have to call checkForCaseInsensitiveDuplicates to do a case\n  // insensitive check across all emails in the database here because: (1) if\n  // there is no case-insensitive duplicate between this user and other users,\n  // then we are OK and (2) if this would create a conflict with other users\n  // then there would already be a case-insensitive duplicate and we can't fix\n  // that in this code anyway.\n  var caseInsensitiveRegExp =\n    new RegExp('^' + Meteor._escapeRegExp(newEmail) + '$', 'i');\n\n  var didUpdateOwnEmail = _.any(user.emails, function(email, index) {\n    if (caseInsensitiveRegExp.test(email.address)) {\n      Meteor.users.update({\n        _id: user._id,\n        'emails.address': email.address\n      }, {$set: {\n        'emails.$.address': newEmail,\n        'emails.$.verified': verified\n      }});\n      return true;\n    }\n\n    return false;\n  });\n\n  // In the other updates below, we have to do another call to\n  // checkForCaseInsensitiveDuplicates to make sure that no conflicting values\n  // were added to the database in the meantime. We don't have to do this for\n  // the case where the user is updating their email address to one that is the\n  // same as before, but only different because of capitalization. Read the\n  // big comment above to understand why.\n\n  if (didUpdateOwnEmail) {\n    return;\n  }\n\n  // Perform a case insensitive check for duplicates before update\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $addToSet: {\n      emails: {\n        address: newEmail,\n        verified: verified\n      }\n    }\n  });\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({_id: user._id},\n      {$pull: {emails: {address: newEmail}}});\n    throw ex;\n  }\n}\n\n/**\n * @summary Remove an email address for a user. Use this instead of updating\n * the database directly.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} email The email address to remove.\n * @importFromPackage accounts-base\n */\nAccounts.removeEmail = function (userId, email) {\n  check(userId, NonEmptyString);\n  check(email, NonEmptyString);\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  Meteor.users.update({_id: user._id},\n    {$pull: {emails: {address: email}}});\n}\n\n///\n/// CREATING USERS\n///\n\n// Shared createUser function called from the createUser method, both\n// if originates in client or server code. Calls user provided hooks,\n// does the actual user insertion.\n//\n// returns the user id\nvar createUser = function (options) {\n  // Unknown keys allowed, because a onCreateUserHook can take arbitrary\n  // options.\n  check(options, Match.ObjectIncluding({\n    username: Match.Optional(String),\n    email: Match.Optional(String),\n    password: Match.Optional(passwordValidator)\n  }));\n\n  var username = options.username;\n  var email = options.email;\n  if (!username && !email)\n    throw new Meteor.Error(400, \"Need to set a username or email\");\n\n  var user = {services: {}};\n  if (options.password) {\n    var hashed = hashPassword(options.password);\n    user.services.password = { bcrypt: hashed };\n  }\n\n  if (username)\n    user.username = username;\n  if (email)\n    user.emails = [{address: email, verified: false}];\n\n  // Perform a case insensitive check before insert\n  checkForCaseInsensitiveDuplicates('username', 'Username', username);\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', email);\n\n  var userId = Accounts.insertUserDoc(options, user);\n  // Perform another check after insert, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('username', 'Username', username, userId);\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', email, userId);\n  } catch (ex) {\n    // Remove inserted user if the check fails\n    Meteor.users.remove(userId);\n    throw ex;\n  }\n  return userId;\n};\n\n// method for create user. Requests come from the client.\nMeteor.methods({createUser: function (options) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"createUser\",\n    arguments,\n    \"password\",\n    function () {\n      // createUser() above does more checking.\n      check(options, Object);\n      if (Accounts._options.forbidClientAccountCreation)\n        return {\n          error: new Meteor.Error(403, \"Signups forbidden\")\n        };\n\n      // Create user. result contains id and token.\n      var userId = createUser(options);\n      // safety belt. createUser is supposed to throw on error. send 500 error\n      // instead of sending a verification email with empty userid.\n      if (! userId)\n        throw new Error(\"createUser failed to insert new user\");\n\n      // If `Accounts._options.sendVerificationEmail` is set, register\n      // a token to verify the user's primary email, and send it to\n      // that address.\n      if (options.email && Accounts._options.sendVerificationEmail)\n        Accounts.sendVerificationEmail(userId, options.email);\n\n      // client gets logged in as the new user afterwards.\n      return {userId: userId};\n    }\n  );\n}});\n\n// Create user directly on the server.\n//\n// Unlike the client version, this does not log you in as this user\n// after creation.\n//\n// returns userId or throws an error if it can't create\n//\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,\n// which is always empty when called from the createUser method? eg, \"admin:\n// true\", which we want to prevent the client from setting, but which a custom\n// method calling Accounts.createUser could set?\n//\nAccounts.createUser = function (options, callback) {\n  options = _.clone(options);\n\n  // XXX allow an optional callback?\n  if (callback) {\n    throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");\n  }\n\n  return createUser(options);\n};\n\n///\n/// PASSWORD-SPECIFIC INDEXES ON USERS\n///\nMeteor.users._ensureIndex('services.email.verificationTokens.token',\n                          {unique: 1, sparse: 1});\nMeteor.users._ensureIndex('services.password.reset.token',\n                          {unique: 1, sparse: 1});\n"]},"sourceType":"script","hash":"ecfcd2ac96d804ab793b477d7ec350fffbea9c3f"}
