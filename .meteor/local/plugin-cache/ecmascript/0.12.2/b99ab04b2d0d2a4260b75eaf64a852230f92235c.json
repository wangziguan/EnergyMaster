{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$4","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$5","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$6","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$7","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$9","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/components/autoForm/autoForm.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/aldeed:autoform/components/autoForm/autoForm.js","filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/components/autoForm/autoForm.js","passPerPreset":false,"envName":"development","cwd":"/home/wangziguan/wzg/EnergyMaster","root":"/home/wangziguan/wzg/EnergyMaster","generatorOpts":{"filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/components/autoForm/autoForm.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/aldeed:autoform/components/autoForm/autoForm.js"}},"code":"let MongoObject;\nmodule.link(\"mongo-object\", {\n  default(v) {\n    MongoObject = v;\n  }\n\n}, 0);\n\n/* global AutoForm, ReactiveVar, arrayTracker, Hooks, Utility, setDefaults */\nTemplate.autoForm.helpers({\n  atts: function autoFormTplAtts() {\n    // After removing all of the props we know about, everything else should\n    // become a form attribute unless it's an array or object.\n    var val,\n        htmlAttributes = {},\n        context = this;\n    var removeProps = [\"schema\", \"collection\", \"validation\", \"doc\", \"resetOnSuccess\", \"type\", \"template\", \"autosave\", \"autosaveOnKeyup\", \"meteormethod\", \"filter\", \"autoConvert\", \"removeEmptyStrings\", \"trimStrings\"]; // Filter out any attributes that have a component prefix\n\n    function hasComponentPrefix(prop) {\n      return _.any(Utility.componentTypeList, function (componentType) {\n        return prop.indexOf(componentType + '-') === 0;\n      });\n    } // Filter out arrays and objects, which are obviously not meant to be\n    // HTML attributes.\n\n\n    for (var prop in context) {\n      if (context.hasOwnProperty(prop) && !_.contains(removeProps, prop) && !hasComponentPrefix(prop)) {\n        val = context[prop];\n\n        if (!_.isArray(val) && !_.isObject(val)) {\n          htmlAttributes[prop] = val;\n        }\n      }\n    } // By default, we add the `novalidate=\"novalidate\"` attribute to our form,\n    // unless the user passes `validation=\"browser\"`.\n\n\n    if (this.validation !== \"browser\" && !htmlAttributes.novalidate) {\n      htmlAttributes.novalidate = \"novalidate\";\n    }\n\n    return htmlAttributes;\n  },\n  afDestroyUpdateForm: function (formId) {\n    AutoForm._destroyForm[formId] = AutoForm._destroyForm[formId] || new ReactiveVar(false);\n    return AutoForm._destroyForm[formId].get();\n  }\n});\n\nTemplate.autoForm.created = function autoFormCreated() {\n  var template = this; // We'll add tracker dependencies for reactive field values\n  // to this object as necessary\n\n  template.formValues = template.formValues || {}; // We'll store \"sticky\" errors here. These are errors added\n  // manually based on server validation, which we don't want to\n  // be wiped out by further client validation.\n\n  template._stickyErrors = {};\n  template.autorun(function (c) {\n    var data = Template.currentData(); // rerun when current data changes\n\n    var formId = data.id;\n\n    if (!formId) {\n      throw new Error('Every autoForm and quickForm must have an \"id\" attribute set to a unique string.');\n    } // When we change the form, loading a different doc, reloading the current doc, etc.,\n    // we also want to reset the array counts for the form\n\n\n    arrayTracker.resetForm(formId);\n    data = setDefaults(data); // Clone the doc so that docToForm and other modifications do not change\n    // the original referenced object.\n\n    var doc = data.doc ? EJSON.clone(data.doc) : null; // Update cached form values for hot code reload persistence\n\n    if (data.preserveForm === false) {\n      AutoForm.formPreserve.unregisterForm(formId);\n    } else {\n      // Even if we have already registered, we reregister to ensure that the\n      // closure values of template, formId, and ss remain correct after each\n      // reaction\n      AutoForm.formPreserve.registerForm(formId, function autoFormRegFormCallback() {\n        return AutoForm.getFormValues(formId, template, data._resolvedSchema, false);\n      });\n    } // Retain doc values after a \"hot code push\", if possible\n\n\n    if (c.firstRun) {\n      var retrievedDoc = AutoForm.formPreserve.getDocument(formId);\n\n      if (retrievedDoc !== false) {\n        // Ensure we keep the _id property which may not be present in retrievedDoc.\n        doc = _.extend(doc || {}, retrievedDoc || {});\n      }\n    }\n\n    var mDoc;\n\n    if (doc && !_.isEmpty(doc)) {\n      var hookCtx = {\n        formId: formId\n      }; // Pass doc through docToForm hooks\n\n      _.each(Hooks.getHooks(formId, 'docToForm'), function autoFormEachDocToForm(hook) {\n        doc = hook.call(hookCtx, doc, data._resolvedSchema);\n\n        if (!doc) {\n          throw new Error('Oops! Did you forget to return the modified document from your docToForm hook for the ' + formId + ' form?');\n        }\n      }); // Create a \"flat doc\" that can be used to easily get values for corresponding\n      // form fields.\n\n\n      mDoc = new MongoObject(doc);\n      AutoForm.reactiveFormData.sourceDoc(formId, mDoc);\n    } else {\n      AutoForm.reactiveFormData.sourceDoc(formId, null);\n    }\n  });\n};\n\nTemplate.autoForm.rendered = function autoFormRendered() {\n  var lastId;\n  this.autorun(function () {\n    var data = Template.currentData(); // rerun when current data changes\n\n    if (data.id === lastId) return;\n    lastId = data.id;\n    AutoForm.triggerFormRenderedDestroyedReruns(data.id);\n  });\n};\n\nTemplate.autoForm.destroyed = function autoFormDestroyed() {\n  var self = this;\n  var formId = self.data.id; // TODO if formId was changing reactively during life of instance,\n  // some data won't be removed by the calls below.\n  // Remove from array fields list\n\n  arrayTracker.untrackForm(formId); // Unregister form preservation\n\n  AutoForm.formPreserve.unregisterForm(formId); // Trigger value reruns\n\n  AutoForm.triggerFormRenderedDestroyedReruns(formId);\n};","map":{"version":3,"sources":["packages/aldeed:autoform/components/autoForm/autoForm.js"],"names":["MongoObject","module","link","default","v","Template","autoForm","helpers","atts","autoFormTplAtts","val","htmlAttributes","context","removeProps","hasComponentPrefix","prop","_","any","Utility","componentTypeList","componentType","indexOf","hasOwnProperty","contains","isArray","isObject","validation","novalidate","afDestroyUpdateForm","formId","AutoForm","_destroyForm","ReactiveVar","get","created","autoFormCreated","template","formValues","_stickyErrors","autorun","c","data","currentData","id","Error","arrayTracker","resetForm","setDefaults","doc","EJSON","clone","preserveForm","formPreserve","unregisterForm","registerForm","autoFormRegFormCallback","getFormValues","_resolvedSchema","firstRun","retrievedDoc","getDocument","extend","mDoc","isEmpty","hookCtx","each","Hooks","getHooks","autoFormEachDocToForm","hook","call","reactiveFormData","sourceDoc","rendered","autoFormRendered","lastId","triggerFormRenderedDestroyedReruns","destroyed","autoFormDestroyed","self","untrackForm"],"mappings":"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","sourcesContent":["import MongoObject from 'mongo-object';\n\n/* global AutoForm, ReactiveVar, arrayTracker, Hooks, Utility, setDefaults */\n\nTemplate.autoForm.helpers({\n  atts: function autoFormTplAtts() {\n    // After removing all of the props we know about, everything else should\n    // become a form attribute unless it's an array or object.\n    var val, htmlAttributes = {}, context = this;\n    var removeProps = [\n      \"schema\",\n      \"collection\",\n      \"validation\",\n      \"doc\",\n      \"resetOnSuccess\",\n      \"type\",\n      \"template\",\n      \"autosave\",\n      \"autosaveOnKeyup\",\n      \"meteormethod\",\n      \"filter\",\n      \"autoConvert\",\n      \"removeEmptyStrings\",\n      \"trimStrings\"\n    ];\n\n    // Filter out any attributes that have a component prefix\n    function hasComponentPrefix(prop) {\n      return _.any(Utility.componentTypeList, function (componentType) {\n        return prop.indexOf(componentType + '-') === 0;\n      });\n    }\n\n    // Filter out arrays and objects, which are obviously not meant to be\n    // HTML attributes.\n    for (var prop in context) {\n      if (context.hasOwnProperty(prop) &&\n          !_.contains(removeProps, prop) &&\n          !hasComponentPrefix(prop)) {\n        val = context[prop];\n        if (!_.isArray(val) && !_.isObject(val)) {\n          htmlAttributes[prop] = val;\n        }\n      }\n    }\n\n    // By default, we add the `novalidate=\"novalidate\"` attribute to our form,\n    // unless the user passes `validation=\"browser\"`.\n    if (this.validation !== \"browser\" && !htmlAttributes.novalidate) {\n      htmlAttributes.novalidate = \"novalidate\";\n    }\n\n    return htmlAttributes;\n  },\n  afDestroyUpdateForm: function (formId) {\n    AutoForm._destroyForm[formId] = AutoForm._destroyForm[formId] || new ReactiveVar(false);\n    return AutoForm._destroyForm[formId].get();\n  }\n});\n\nTemplate.autoForm.created = function autoFormCreated() {\n  var template = this;\n\n  // We'll add tracker dependencies for reactive field values\n  // to this object as necessary\n  template.formValues = template.formValues || {};\n\n  // We'll store \"sticky\" errors here. These are errors added\n  // manually based on server validation, which we don't want to\n  // be wiped out by further client validation.\n  template._stickyErrors = {};\n\n  template.autorun(function (c) {\n    var data = Template.currentData(); // rerun when current data changes\n    var formId = data.id;\n\n    if (!formId) {\n      throw new Error('Every autoForm and quickForm must have an \"id\" attribute set to a unique string.');\n    }\n\n    // When we change the form, loading a different doc, reloading the current doc, etc.,\n    // we also want to reset the array counts for the form\n    arrayTracker.resetForm(formId);\n\n    data = setDefaults(data);\n\n    // Clone the doc so that docToForm and other modifications do not change\n    // the original referenced object.\n    var doc = data.doc ? EJSON.clone(data.doc) : null;\n\n    // Update cached form values for hot code reload persistence\n    if (data.preserveForm === false) {\n      AutoForm.formPreserve.unregisterForm(formId);\n    } else {\n      // Even if we have already registered, we reregister to ensure that the\n      // closure values of template, formId, and ss remain correct after each\n      // reaction\n      AutoForm.formPreserve.registerForm(formId, function autoFormRegFormCallback() {\n        return AutoForm.getFormValues(formId, template, data._resolvedSchema, false);\n      });\n    }\n\n    // Retain doc values after a \"hot code push\", if possible\n    if (c.firstRun) {\n      var retrievedDoc = AutoForm.formPreserve.getDocument(formId);\n      if (retrievedDoc !== false) {\n        // Ensure we keep the _id property which may not be present in retrievedDoc.\n        doc = _.extend(doc || {}, retrievedDoc || {});\n      }\n    }\n\n    var mDoc;\n    if (doc && !_.isEmpty(doc)) {\n      var hookCtx = {formId: formId};\n      // Pass doc through docToForm hooks\n      _.each(Hooks.getHooks(formId, 'docToForm'), function autoFormEachDocToForm(hook) {\n        doc = hook.call(hookCtx, doc, data._resolvedSchema);\n        if (!doc) {\n          throw new Error('Oops! Did you forget to return the modified document from your docToForm hook for the ' + formId + ' form?');\n        }\n      });\n\n      // Create a \"flat doc\" that can be used to easily get values for corresponding\n      // form fields.\n      mDoc = new MongoObject(doc);\n      AutoForm.reactiveFormData.sourceDoc(formId, mDoc);\n    } else {\n      AutoForm.reactiveFormData.sourceDoc(formId, null);\n    }\n  });\n};\n\nTemplate.autoForm.rendered = function autoFormRendered() {\n  var lastId;\n  this.autorun(function () {\n    var data = Template.currentData(); // rerun when current data changes\n\n    if (data.id === lastId) return;\n    lastId = data.id;\n\n    AutoForm.triggerFormRenderedDestroyedReruns(data.id);\n  });\n};\n\nTemplate.autoForm.destroyed = function autoFormDestroyed() {\n  var self = this;\n  var formId = self.data.id;\n\n  // TODO if formId was changing reactively during life of instance,\n  // some data won't be removed by the calls below.\n\n  // Remove from array fields list\n  arrayTracker.untrackForm(formId);\n\n  // Unregister form preservation\n  AutoForm.formPreserve.unregisterForm(formId);\n\n  // Trigger value reruns\n  AutoForm.triggerFormRenderedDestroyedReruns(formId);\n};\n"]},"sourceType":"script","hash":"b99ab04b2d0d2a4260b75eaf64a852230f92235c"}
