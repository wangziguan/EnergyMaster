{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$4","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$5","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$6","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$7","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$9","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:tabular/client/main.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/aldeed:tabular/client/main.js","filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:tabular/client/main.js","passPerPreset":false,"envName":"development","cwd":"/home/wangziguan/wzg/EnergyMaster","root":"/home/wangziguan/wzg/EnergyMaster","generatorOpts":{"filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:tabular/client/main.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/aldeed:tabular/client/main.js"}},"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nlet $;\nmodule.link(\"meteor/jquery\", {\n  $(v) {\n    $ = v;\n  }\n\n}, 0);\nlet dataTableInit;\nmodule.link(\"datatables.net\", {\n  default(v) {\n    dataTableInit = v;\n  }\n\n}, 1);\nlet Mongo;\nmodule.link(\"meteor/mongo\", {\n  Mongo(v) {\n    Mongo = v;\n  }\n\n}, 2);\nlet Template;\nmodule.link(\"meteor/templating\", {\n  Template(v) {\n    Template = v;\n  }\n\n}, 3);\nlet Tabular;\nmodule.link(\"../common/Tabular\", {\n  default(v) {\n    Tabular = v;\n  }\n\n}, 4);\nlet tableInit;\nmodule.link(\"./tableInit\", {\n  default(v) {\n    tableInit = v;\n  }\n\n}, 5);\nlet getPubSelector;\nmodule.link(\"./getPubSelector\", {\n  default(v) {\n    getPubSelector = v;\n  }\n\n}, 6);\nlet getMongoSort, objectsAreEqual, sortsAreEqual;\nmodule.link(\"./util\", {\n  getMongoSort(v) {\n    getMongoSort = v;\n  },\n\n  objectsAreEqual(v) {\n    objectsAreEqual = v;\n  },\n\n  sortsAreEqual(v) {\n    sortsAreEqual = v;\n  }\n\n}, 7);\nmodule.link(\"./tabular.html\");\ndataTableInit(window, $);\nTemplate.registerHelper('TabularTables', Tabular.tablesByName);\nTabular.tableRecords = new Mongo.Collection('tabular_records');\nTabular.remoteTableRecords = [];\n\nTabular.getTableRecordsCollection = function (connection) {\n  if (!connection || connection === Tabular.tableRecords._connection) return Tabular.tableRecords;\n\n  let remote = _.find(Tabular.remoteTableRecords, remote => remote.connection === connection);\n\n  if (!remote) {\n    remote = {\n      connection,\n      tableRecords: new Mongo.Collection('tabular_records', {\n        connection\n      })\n    };\n    Tabular.remoteTableRecords.push(remote);\n  }\n\n  return remote.tableRecords;\n};\n\nTabular.getRecord = function (name, collection) {\n  return Tabular.getTableRecordsCollection(collection._connection).findOne(name);\n};\n\nTemplate.tabular.helpers({\n  atts() {\n    // We remove the \"table\" and \"selector\" attributes and assume the rest belong\n    // on the <table> element\n    return _.omit(this, 'table', 'selector');\n  }\n\n});\nTemplate.tabular.onRendered(function () {\n  const template = this;\n  template.$tableElement = template.$('table');\n  let table;\n  let resetTablePaging = false;\n  template.tabular = {};\n  template.tabular.data = [];\n  template.tabular.pubSelector = new ReactiveVar({}, objectsAreEqual);\n  template.tabular.skip = new ReactiveVar(0);\n  template.tabular.limit = new ReactiveVar(10);\n  template.tabular.sort = new ReactiveVar(null, sortsAreEqual);\n  template.tabular.columns = null;\n  template.tabular.fields = null;\n  template.tabular.searchFields = null;\n  template.tabular.searchCaseInsensitive = true;\n  template.tabular.splitSearchByWhitespace = true;\n  template.tabular.tableName = new ReactiveVar(null);\n  template.tabular.options = new ReactiveVar({}, objectsAreEqual);\n  template.tabular.docPub = new ReactiveVar(null);\n  template.tabular.collection = new ReactiveVar(null);\n  template.tabular.connection = null;\n  template.tabular.ready = new ReactiveVar(false);\n  template.tabular.recordsTotal = 0;\n  template.tabular.recordsFiltered = 0;\n  template.tabular.isLoading = new ReactiveVar(true); // These are some DataTables options that we need for everything to work.\n  // We add them to the options specified by the user.\n\n  const ajaxOptions = {\n    // tell DataTables that we're getting the table data from a server\n    serverSide: true,\n    processing: true,\n    // define the function that DataTables will call upon first load and whenever\n    // we tell it to reload data, such as when paging, etc.\n    ajax: function (data, callback\n    /*, settings*/\n    ) {\n      // When DataTables requests data, first we set\n      // the new skip, limit, order, and pubSelector values\n      // that DataTables has requested. These trigger\n      // the first subscription, which will then trigger the\n      // second subscription.\n      //console.log('data', template.tabular.data);\n      // Update skip\n      template.tabular.skip.set(data.start);\n      Session.set('Tabular.LastSkip', data.start); // Update limit\n\n      var options = template.tabular.options.get();\n      var hardLimit = options && options.limit;\n\n      if (data.length === -1) {\n        if (hardLimit === undefined) {\n          console.warn('When using no paging or an \"All\" option with tabular, it is best to also add a hard limit in your table options like {limit: 500}');\n          template.tabular.limit.set(null);\n        } else {\n          template.tabular.limit.set(hardLimit);\n        }\n      } else {\n        template.tabular.limit.set(data.length);\n      } // Update sort\n\n\n      template.tabular.sort.set(getMongoSort(data.order, options.columns)); // Update pubSelector\n\n      const pubSelector = getPubSelector(template.tabular.selector, data.search && data.search.value || null, template.tabular.searchFields, template.tabular.searchCaseInsensitive, template.tabular.splitSearchByWhitespace, data.columns || null, options.columns);\n      template.tabular.pubSelector.set(pubSelector); // We're ready to subscribe to the data.\n      // Matters on the first run only.\n\n      template.tabular.ready.set(true); //console.log('ajax');\n\n      callback({\n        draw: data.draw,\n        recordsTotal: template.tabular.recordsTotal,\n        recordsFiltered: template.tabular.recordsFiltered,\n        data: template.tabular.data\n      });\n    },\n    initComplete: function () {\n      var options = template.tabular.options.get();\n\n      if (options.search && options.search.onEnterOnly) {\n        var replaceSearchLabel = function (newText) {\n          $('.dataTables_filter label').contents().filter(function () {\n            return this.nodeType === 3 && this.textContent.trim().length;\n          }).replaceWith(newText);\n        };\n\n        $('.dataTables_filter input').unbind().bind('keyup change', function (event) {\n          if (!table) return;\n\n          if (event.keyCode === 13 || this.value === '') {\n            replaceSearchLabel(\"Search:\");\n            table.search(this.value).draw();\n          } else {\n            replaceSearchLabel(\"Search (hit enter):\");\n          }\n        });\n      }\n    },\n\n    headerCallback(headerRow) {\n      const options = template.tabular.options.get();\n      const columns = options.columns;\n      $(headerRow).find('td,th').each((index, headerCell) => {\n        const titleFunction = columns[index] && columns[index].titleFn;\n\n        if (typeof titleFunction === 'function') {\n          headerCell.innerHTML = '';\n\n          if (headerCell.__blazeViewInstance) {\n            Blaze.remove(headerCell.__blazeViewInstance);\n          }\n\n          const view = new Blaze.View(titleFunction);\n          headerCell.__blazeViewInstance = Blaze.render(view, headerCell);\n        }\n      });\n    }\n\n  }; // For testing\n  //setUpTestingAutoRunLogging(template);\n  // Reactively determine table columns, fields, and searchFields.\n  // This will rerun whenever the current template data changes.\n\n  var lastTableName;\n  template.autorun(function () {\n    var data = Template.currentData(); //console.log('currentData autorun', data);\n\n    if (!data) return; // We get the current TabularTable instance, and cache it on the\n    // template instance for access elsewhere\n\n    var tabularTable = template.tabular.tableDef = data.table;\n\n    if (!(tabularTable instanceof Tabular.Table)) {\n      throw new Error(\"You must pass Tabular.Table instance as the table attribute\");\n    } // Always update the selector reactively\n\n\n    template.tabular.selector = data.selector; // The remaining stuff relates to changing the `table`\n    // attribute. If we didn't change it, we can stop here,\n    // but we need to reload the table if this is not the first\n    // run\n\n    if (tabularTable.name === lastTableName) {\n      if (table) {\n        // passing `false` as the second arg tells it to\n        // reset the paging\n        table.ajax.reload(null, true);\n      }\n\n      return;\n    } // If we reactively changed the `table` attribute, run\n    // onUnload for the previous table\n\n\n    if (lastTableName !== undefined) {\n      var lastTableDef = Tabular.tablesByName[lastTableName];\n\n      if (lastTableDef && typeof lastTableDef.onUnload === 'function') {\n        lastTableDef.onUnload();\n      }\n    } // Cache this table name as the last table name for next run\n\n\n    lastTableName = tabularTable.name; // Figure out and update the columns, fields, and searchFields\n\n    const columns = tableInit(tabularTable, template); // Set/update everything else\n\n    template.tabular.searchCaseInsensitive = true;\n    template.tabular.splitSearchByWhitespace = true;\n\n    if (tabularTable.options && tabularTable.options.search) {\n      if (tabularTable.options.search.caseInsensitive === false) {\n        template.tabular.searchCaseInsensitive = false;\n      }\n\n      if (tabularTable.options.search.smart === false) {\n        template.tabular.splitSearchByWhitespace = false;\n      }\n    }\n\n    template.tabular.options.set((0, _objectSpread2.default)({}, tabularTable.options, {\n      columns\n    }));\n    template.tabular.tableName.set(tabularTable.name);\n    template.tabular.docPub.set(tabularTable.pub);\n    template.tabular.collection.set(tabularTable.collection);\n\n    if (tabularTable.collection && tabularTable.collection._connection) {\n      template.tabular.connection = tabularTable.collection._connection;\n    } // userOptions rerun should do this?\n\n\n    if (table) {\n      // passing `true` as the second arg tells it to\n      // reset the paging\n      table.ajax.reload(null, true);\n    }\n  });\n  template.autorun(() => {\n    // these 5 are the parameters passed to \"tabular_getInfo\" subscription\n    // so when they *change*, set the isLoading flag to true\n    template.tabular.tableName.get();\n    template.tabular.pubSelector.get();\n    template.tabular.sort.get();\n    template.tabular.skip.get();\n    template.tabular.limit.get();\n    template.tabular.isLoading.set(true);\n  }); // First Subscription\n  // Subscribe to an array of _ids that should be on the\n  // current page of the table, plus some aggregate\n  // numbers that DataTables needs in order to show the paging.\n  // The server will reactively keep this info accurate.\n  // It's not necessary to call stop\n  // on subscriptions that are within autorun computations.\n\n  template.autorun(function () {\n    if (!template.tabular.ready.get()) return; //console.log('tabular_getInfo autorun');\n\n    function onReady() {\n      template.tabular.isLoading.set(false);\n    }\n\n    var connection = template.tabular.connection;\n    var context = connection || Meteor;\n    context.subscribe(\"tabular_getInfo\", template.tabular.tableName.get(), template.tabular.pubSelector.get(), template.tabular.sort.get(), template.tabular.skip.get(), template.tabular.limit.get(), onReady);\n  }); // Second Subscription\n  // Reactively subscribe to the documents with _ids given to us. Limit the\n  // fields to only those we need to display. It's not necessary to call stop\n  // on subscriptions that are within autorun computations.\n\n  template.autorun(function () {\n    // tableInfo is reactive and causes a rerun whenever the\n    // list of docs that should currently be in the table changes.\n    // It does not cause reruns based on the documents themselves\n    // changing.\n    var tableName = template.tabular.tableName.get();\n    var collection = template.tabular.collection.get();\n    var tableInfo = Tabular.getRecord(tableName, collection) || {}; //console.log('tableName and tableInfo autorun', tableName, tableInfo);\n\n    template.tabular.recordsTotal = tableInfo.recordsTotal || 0;\n    template.tabular.recordsFiltered = tableInfo.recordsFiltered || 0; // In some cases, there is no point in subscribing to nothing\n\n    if (_.isEmpty(tableInfo) || template.tabular.recordsTotal === 0 || template.tabular.recordsFiltered === 0) {\n      return;\n    } // Extend with extraFields from table definition\n\n\n    var fields = template.tabular.fields;\n\n    if (fields) {\n      // Extend with extraFields from table definition\n      if (typeof template.tabular.tableDef.extraFields === 'object') {\n        fields = _.extend(_.clone(fields), template.tabular.tableDef.extraFields);\n      }\n    }\n\n    template.tabular.tableDef.sub.subscribe(template.tabular.docPub.get(), tableName, tableInfo.ids || [], fields);\n  }); // Build the table. We rerun this only when the table\n  // options specified by the user changes, which should be\n  // only when the `table` attribute changes reactively.\n\n  template.autorun(c => {\n    const userOptions = template.tabular.options.get();\n\n    const options = _.extend({}, ajaxOptions, userOptions); //console.log('userOptions autorun', userOptions);\n    // unless the user provides her own displayStart,\n    // we use a value from Session. This keeps the\n    // same page selected after a hot code push.\n\n\n    if (c.firstRun && !('displayStart' in options)) {\n      options.displayStart = Tracker.nonreactive(function () {\n        return Session.get('Tabular.LastSkip');\n      });\n    }\n\n    if (!('order' in options)) options.order = []; // After the first time, we need to destroy before rebuilding.\n\n    if (table) {\n      var dt = template.$tableElement.DataTable();\n      if (dt) dt.destroy();\n      template.$tableElement.empty();\n    } // We start with an empty table.\n    // Data will be populated by ajax function now.\n\n\n    table = template.$tableElement.DataTable(options);\n\n    if (options.buttonContainer) {\n      const container = $(options.buttonContainer, table.table().container());\n      table.buttons().container().appendTo(container);\n    }\n  });\n  template.autorun(() => {\n    // Get table name non-reactively\n    var tableName = Tracker.nonreactive(function () {\n      return template.tabular.tableName.get();\n    }); // Get the collection that we're showing in the table non-reactively\n\n    var collection = Tracker.nonreactive(function () {\n      return template.tabular.collection.get();\n    }); // React when the requested list of records changes.\n    // This can happen for various reasons.\n    // * DataTables reran ajax due to sort changing.\n    // * DataTables reran ajax due to page changing.\n    // * DataTables reran ajax due to results-per-page changing.\n    // * DataTables reran ajax due to search terms changing.\n    // * `selector` attribute changed reactively\n    // * Docs were added/changed/removed by this user or\n    //   another user, causing visible result set to change.\n\n    var tableInfo = Tabular.getRecord(tableName, collection);\n    if (!collection || !tableInfo) return; // Build options object to pass to `find`.\n    // It's important that we use the same options\n    // that were used in generating the list of `_id`s\n    // on the server.\n\n    var findOptions = {};\n    var fields = template.tabular.fields;\n\n    if (fields) {\n      // Extend with extraFields from table definition\n      if (typeof template.tabular.tableDef.extraFields === 'object') {\n        _.extend(fields, template.tabular.tableDef.extraFields);\n      }\n\n      findOptions.fields = fields;\n    } // Sort does not need to be reactive here; using\n    // reactive sort would result in extra rerunning.\n\n\n    var sort = Tracker.nonreactive(function () {\n      return template.tabular.sort.get();\n    });\n\n    if (sort) {\n      findOptions.sort = sort;\n    } // Get the updated list of docs we should be showing\n\n\n    var cursor = collection.find({\n      _id: {\n        $in: tableInfo.ids\n      }\n    }, findOptions); //console.log('tableInfo, fields, sort, find autorun', cursor.count());\n    // We're subscribing to the docs just in time, so there's\n    // a good chance that they aren't all sent to the client yet.\n    // We'll stop here if we didn't find all the docs we asked for.\n    // This will rerun one or more times as the docs are received\n    // from the server, and eventually we'll have them all.\n    // Without this check in here, there's a lot of flashing in the\n    // table as rows are added.\n\n    if (cursor.count() < tableInfo.ids.length) return; // Get data as array for DataTables to consume in the ajax function\n\n    template.tabular.data = cursor.fetch(); // For these types of reactive changes, we don't want to\n    // reset the page we're on, so we pass `false` as second arg.\n    // The exception is if we changed the results-per-page number,\n    // in which cases `resetTablePaging` will be `true` and we will do so.\n\n    if (table) {\n      if (resetTablePaging) {\n        table.ajax.reload(null, true);\n        resetTablePaging = false;\n      } else {\n        table.ajax.reload(null, false);\n      }\n    }\n\n    template.tabular.isLoading.set(false);\n  });\n  template.autorun(() => {\n    const isLoading = template.tabular.isLoading.get();\n\n    if (isLoading) {\n      template.$('.dataTables_processing').show();\n    } else {\n      template.$('.dataTables_processing').hide();\n    }\n  }); // force table paging to reset to first page when we change page length\n\n  template.$tableElement.on('length.dt', function () {\n    resetTablePaging = true;\n  });\n});\nTemplate.tabular.onDestroyed(function () {\n  // Clear last skip tracking\n  Session.set('Tabular.LastSkip', 0); // Run a user-provided onUnload function\n\n  if (this.tabular && this.tabular.tableDef && typeof this.tabular.tableDef.onUnload === 'function') {\n    this.tabular.tableDef.onUnload();\n  } // Destroy the DataTable instance to avoid memory leak\n\n\n  if (this.$tableElement.length) {\n    const dt = this.$tableElement.DataTable();\n    if (dt) dt.destroy();\n    this.$tableElement.empty();\n  }\n}); //function setUpTestingAutoRunLogging(template) {\n//  template.autorun(function () {\n//    var val = template.tabular.tableName.get();\n//    console.log('tableName changed', val);\n//  });\n//\n//  template.autorun(function () {\n//    var val = template.tabular.pubSelector.get();\n//    console.log('pubSelector changed', val);\n//  });\n//\n//  template.autorun(function () {\n//    var val = template.tabular.sort.get();\n//    console.log('sort changed', val);\n//  });\n//\n//  template.autorun(function () {\n//    var val = template.tabular.skip.get();\n//    console.log('skip changed', val);\n//  });\n//\n//  template.autorun(function () {\n//    var val = template.tabular.limit.get();\n//    console.log('limit changed', val);\n//  });\n//}\n\nmodule.exportDefault(Tabular);","map":{"version":3,"sources":["packages/aldeed:tabular/client/main.js"],"names":["$","module","link","v","dataTableInit","default","Mongo","Template","Tabular","tableInit","getPubSelector","getMongoSort","objectsAreEqual","sortsAreEqual","window","registerHelper","tablesByName","tableRecords","Collection","remoteTableRecords","getTableRecordsCollection","connection","_connection","remote","_","find","push","getRecord","name","collection","findOne","tabular","helpers","atts","omit","onRendered","template","$tableElement","table","resetTablePaging","data","pubSelector","ReactiveVar","skip","limit","sort","columns","fields","searchFields","searchCaseInsensitive","splitSearchByWhitespace","tableName","options","docPub","ready","recordsTotal","recordsFiltered","isLoading","ajaxOptions","serverSide","processing","ajax","callback","set","start","Session","get","hardLimit","length","undefined","console","warn","order","selector","search","value","draw","initComplete","onEnterOnly","replaceSearchLabel","newText","contents","filter","nodeType","textContent","trim","replaceWith","unbind","bind","event","keyCode","headerCallback","headerRow","each","index","headerCell","titleFunction","titleFn","innerHTML","__blazeViewInstance","Blaze","remove","view","View","render","lastTableName","autorun","currentData","tabularTable","tableDef","Table","Error","reload","lastTableDef","onUnload","caseInsensitive","smart","pub","onReady","context","Meteor","subscribe","tableInfo","isEmpty","extraFields","extend","clone","sub","ids","c","userOptions","firstRun","displayStart","Tracker","nonreactive","dt","DataTable","destroy","empty","buttonContainer","container","buttons","appendTo","findOptions","cursor","_id","$in","count","fetch","show","hide","on","onDestroyed","exportDefault"],"mappings":"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","sourcesContent":["/* global _, Template, Tabular, Tracker, ReactiveVar, Session, Meteor, */\nimport { $ } from 'meteor/jquery';\nimport dataTableInit from 'datatables.net';\nimport { Mongo } from 'meteor/mongo';\nimport { Template } from 'meteor/templating';\nimport Tabular from '../common/Tabular';\nimport tableInit from './tableInit';\nimport getPubSelector from './getPubSelector';\nimport { getMongoSort, objectsAreEqual, sortsAreEqual } from './util';\n\nimport './tabular.html';\n\ndataTableInit(window, $);\n\nTemplate.registerHelper('TabularTables', Tabular.tablesByName);\n\nTabular.tableRecords = new Mongo.Collection('tabular_records');\nTabular.remoteTableRecords = [];\n\nTabular.getTableRecordsCollection = function (connection) {\n  if (!connection || connection === Tabular.tableRecords._connection) return Tabular.tableRecords;\n\n  let remote = _.find(Tabular.remoteTableRecords, remote => remote.connection === connection);\n  if (!remote) {\n    remote = {\n      connection,\n      tableRecords: new Mongo.Collection('tabular_records', { connection }),\n    };\n    Tabular.remoteTableRecords.push(remote);\n  }\n  return remote.tableRecords;\n};\n\nTabular.getRecord = function (name, collection) {\n  return Tabular.getTableRecordsCollection(collection._connection).findOne(name);\n};\n\nTemplate.tabular.helpers({\n  atts() {\n    // We remove the \"table\" and \"selector\" attributes and assume the rest belong\n    // on the <table> element\n    return _.omit(this, 'table', 'selector');\n  }\n});\n\nTemplate.tabular.onRendered(function () {\n  const template = this;\n  template.$tableElement = template.$('table');\n  let table;\n  let resetTablePaging = false;\n\n  template.tabular = {};\n  template.tabular.data = [];\n  template.tabular.pubSelector = new ReactiveVar({}, objectsAreEqual);\n  template.tabular.skip = new ReactiveVar(0);\n  template.tabular.limit = new ReactiveVar(10);\n  template.tabular.sort = new ReactiveVar(null, sortsAreEqual);\n  template.tabular.columns = null;\n  template.tabular.fields = null;\n  template.tabular.searchFields = null;\n  template.tabular.searchCaseInsensitive = true;\n  template.tabular.splitSearchByWhitespace = true;\n  template.tabular.tableName = new ReactiveVar(null);\n  template.tabular.options = new ReactiveVar({}, objectsAreEqual);\n  template.tabular.docPub = new ReactiveVar(null);\n  template.tabular.collection = new ReactiveVar(null);\n  template.tabular.connection = null;\n  template.tabular.ready = new ReactiveVar(false);\n  template.tabular.recordsTotal = 0;\n  template.tabular.recordsFiltered = 0;\n  template.tabular.isLoading = new ReactiveVar(true);\n\n  // These are some DataTables options that we need for everything to work.\n  // We add them to the options specified by the user.\n  const ajaxOptions = {\n    // tell DataTables that we're getting the table data from a server\n    serverSide: true,\n    processing: true,\n    // define the function that DataTables will call upon first load and whenever\n    // we tell it to reload data, such as when paging, etc.\n    ajax: function (data, callback/*, settings*/) {\n      // When DataTables requests data, first we set\n      // the new skip, limit, order, and pubSelector values\n      // that DataTables has requested. These trigger\n      // the first subscription, which will then trigger the\n      // second subscription.\n\n      //console.log('data', template.tabular.data);\n\n      // Update skip\n      template.tabular.skip.set(data.start);\n      Session.set('Tabular.LastSkip', data.start);\n\n      // Update limit\n      var options = template.tabular.options.get();\n      var hardLimit = options && options.limit;\n      if (data.length === -1) {\n        if (hardLimit === undefined) {\n          console.warn('When using no paging or an \"All\" option with tabular, it is best to also add a hard limit in your table options like {limit: 500}');\n          template.tabular.limit.set(null);\n        } else {\n          template.tabular.limit.set(hardLimit);\n        }\n      } else {\n        template.tabular.limit.set(data.length);\n      }\n\n      // Update sort\n      template.tabular.sort.set(getMongoSort(data.order, options.columns));\n\n      // Update pubSelector\n      const pubSelector = getPubSelector(\n        template.tabular.selector,\n        (data.search && data.search.value) || null,\n        template.tabular.searchFields,\n        template.tabular.searchCaseInsensitive,\n        template.tabular.splitSearchByWhitespace,\n        data.columns || null,\n        options.columns,\n      );\n      template.tabular.pubSelector.set(pubSelector);\n\n      // We're ready to subscribe to the data.\n      // Matters on the first run only.\n      template.tabular.ready.set(true);\n\n      //console.log('ajax');\n\n      callback({\n        draw: data.draw,\n        recordsTotal: template.tabular.recordsTotal,\n        recordsFiltered: template.tabular.recordsFiltered,\n        data: template.tabular.data\n      });\n\n    },\n    initComplete: function () {\n      var options = template.tabular.options.get();\n      if (options.search && options.search.onEnterOnly) {\n        var replaceSearchLabel = function(newText){\n          $('.dataTables_filter label').contents().filter(function() {\n            return this.nodeType === 3 && this.textContent.trim().length;\n          }).replaceWith(newText);\n        }\n        $('.dataTables_filter input')\n          .unbind()\n          .bind('keyup change', function (event) {\n            if (!table) return;\n            if (event.keyCode === 13 || this.value === '') {\n              replaceSearchLabel(\"Search:\");\n              table.search(this.value).draw();\n            }\n            else {\n              replaceSearchLabel(\"Search (hit enter):\");\n            }\n          });\n      }\n    },\n    headerCallback(headerRow) {\n      const options = template.tabular.options.get();\n      const columns = options.columns;\n\n      $(headerRow).find('td,th').each((index, headerCell) => {\n        const titleFunction = columns[index] && columns[index].titleFn;\n        if (typeof titleFunction === 'function') {\n          headerCell.innerHTML = '';\n          if (headerCell.__blazeViewInstance) {\n            Blaze.remove(headerCell.__blazeViewInstance);\n          }\n          const view = new Blaze.View(titleFunction);\n          headerCell.__blazeViewInstance = Blaze.render(view, headerCell);\n        }\n      });\n    }\n  };\n\n  // For testing\n  //setUpTestingAutoRunLogging(template);\n\n  // Reactively determine table columns, fields, and searchFields.\n  // This will rerun whenever the current template data changes.\n  var lastTableName;\n  template.autorun(function () {\n    var data = Template.currentData();\n\n    //console.log('currentData autorun', data);\n\n    if (!data) return;\n\n    // We get the current TabularTable instance, and cache it on the\n    // template instance for access elsewhere\n    var tabularTable = template.tabular.tableDef = data.table;\n\n    if (!(tabularTable instanceof Tabular.Table)) {\n      throw new Error(\"You must pass Tabular.Table instance as the table attribute\");\n    }\n\n    // Always update the selector reactively\n    template.tabular.selector = data.selector;\n\n    // The remaining stuff relates to changing the `table`\n    // attribute. If we didn't change it, we can stop here,\n    // but we need to reload the table if this is not the first\n    // run\n    if (tabularTable.name === lastTableName) {\n      if (table) {\n        // passing `false` as the second arg tells it to\n        // reset the paging\n        table.ajax.reload(null, true);\n      }\n      return;\n    }\n\n    // If we reactively changed the `table` attribute, run\n    // onUnload for the previous table\n    if (lastTableName !== undefined) {\n      var lastTableDef = Tabular.tablesByName[lastTableName];\n      if (lastTableDef && typeof lastTableDef.onUnload === 'function') {\n        lastTableDef.onUnload();\n      }\n    }\n\n    // Cache this table name as the last table name for next run\n    lastTableName = tabularTable.name;\n\n    // Figure out and update the columns, fields, and searchFields\n    const columns = tableInit(tabularTable, template);\n\n    // Set/update everything else\n    template.tabular.searchCaseInsensitive = true;\n    template.tabular.splitSearchByWhitespace = true;\n\n    if (tabularTable.options && tabularTable.options.search) {\n      if (tabularTable.options.search.caseInsensitive === false) {\n        template.tabular.searchCaseInsensitive = false;\n      }\n      if (tabularTable.options.search.smart === false) {\n        template.tabular.splitSearchByWhitespace = false;\n      }\n    }\n    template.tabular.options.set({\n      ...tabularTable.options,\n      columns,\n    });\n    template.tabular.tableName.set(tabularTable.name);\n    template.tabular.docPub.set(tabularTable.pub);\n    template.tabular.collection.set(tabularTable.collection);\n    if (tabularTable.collection && tabularTable.collection._connection) {\n      template.tabular.connection = tabularTable.collection._connection;\n    }\n\n    // userOptions rerun should do this?\n    if (table) {\n      // passing `true` as the second arg tells it to\n      // reset the paging\n      table.ajax.reload(null, true);\n    }\n  });\n\n  template.autorun(() => {\n    // these 5 are the parameters passed to \"tabular_getInfo\" subscription\n    // so when they *change*, set the isLoading flag to true\n    template.tabular.tableName.get();\n    template.tabular.pubSelector.get();\n    template.tabular.sort.get();\n    template.tabular.skip.get();\n    template.tabular.limit.get();\n    template.tabular.isLoading.set(true);\n  });\n\n  // First Subscription\n  // Subscribe to an array of _ids that should be on the\n  // current page of the table, plus some aggregate\n  // numbers that DataTables needs in order to show the paging.\n  // The server will reactively keep this info accurate.\n  // It's not necessary to call stop\n  // on subscriptions that are within autorun computations.\n  template.autorun(function () {\n    if (!template.tabular.ready.get()) return;\n\n    //console.log('tabular_getInfo autorun');\n\n    function onReady() {\n      template.tabular.isLoading.set(false);\n    }\n\n    var connection = template.tabular.connection;\n    var context = connection || Meteor;\n    context.subscribe(\n      \"tabular_getInfo\",\n      template.tabular.tableName.get(),\n      template.tabular.pubSelector.get(),\n      template.tabular.sort.get(),\n      template.tabular.skip.get(),\n      template.tabular.limit.get(),\n      onReady,\n    );\n  });\n\n  // Second Subscription\n  // Reactively subscribe to the documents with _ids given to us. Limit the\n  // fields to only those we need to display. It's not necessary to call stop\n  // on subscriptions that are within autorun computations.\n  template.autorun(function () {\n    // tableInfo is reactive and causes a rerun whenever the\n    // list of docs that should currently be in the table changes.\n    // It does not cause reruns based on the documents themselves\n    // changing.\n    var tableName = template.tabular.tableName.get();\n    var collection = template.tabular.collection.get();\n    var tableInfo = Tabular.getRecord(tableName, collection) || {};\n\n    //console.log('tableName and tableInfo autorun', tableName, tableInfo);\n\n    template.tabular.recordsTotal = tableInfo.recordsTotal || 0;\n    template.tabular.recordsFiltered = tableInfo.recordsFiltered || 0;\n\n    // In some cases, there is no point in subscribing to nothing\n    if (_.isEmpty(tableInfo) ||\n        template.tabular.recordsTotal === 0 ||\n        template.tabular.recordsFiltered === 0) {\n      return;\n    }\n\n    // Extend with extraFields from table definition\n    var fields = template.tabular.fields;\n    if (fields) {\n      // Extend with extraFields from table definition\n      if (typeof template.tabular.tableDef.extraFields === 'object') {\n        fields = _.extend(_.clone(fields), template.tabular.tableDef.extraFields);\n      }\n    }\n\n    template.tabular.tableDef.sub.subscribe(\n      template.tabular.docPub.get(),\n      tableName,\n      tableInfo.ids || [],\n      fields\n    );\n  });\n\n  // Build the table. We rerun this only when the table\n  // options specified by the user changes, which should be\n  // only when the `table` attribute changes reactively.\n  template.autorun(c => {\n    const userOptions = template.tabular.options.get();\n    const options = _.extend({}, ajaxOptions, userOptions);\n\n    //console.log('userOptions autorun', userOptions);\n\n    // unless the user provides her own displayStart,\n    // we use a value from Session. This keeps the\n    // same page selected after a hot code push.\n    if (c.firstRun && !('displayStart' in options)) {\n      options.displayStart = Tracker.nonreactive(function () {\n        return Session.get('Tabular.LastSkip');\n      });\n    }\n\n    if (!('order' in options)) options.order = [];\n\n    // After the first time, we need to destroy before rebuilding.\n    if (table) {\n      var dt = template.$tableElement.DataTable();\n      if (dt) dt.destroy();\n      template.$tableElement.empty();\n    }\n\n    // We start with an empty table.\n    // Data will be populated by ajax function now.\n    table = template.$tableElement.DataTable(options);\n\n    if (options.buttonContainer) {\n      const container = $(options.buttonContainer, table.table().container());\n      table.buttons().container().appendTo(container);\n    }\n  });\n\n  template.autorun(() => {\n    // Get table name non-reactively\n    var tableName = Tracker.nonreactive(function () {\n      return template.tabular.tableName.get();\n    });\n    // Get the collection that we're showing in the table non-reactively\n    var collection = Tracker.nonreactive(function () {\n      return template.tabular.collection.get();\n    });\n\n    // React when the requested list of records changes.\n    // This can happen for various reasons.\n    // * DataTables reran ajax due to sort changing.\n    // * DataTables reran ajax due to page changing.\n    // * DataTables reran ajax due to results-per-page changing.\n    // * DataTables reran ajax due to search terms changing.\n    // * `selector` attribute changed reactively\n    // * Docs were added/changed/removed by this user or\n    //   another user, causing visible result set to change.\n    var tableInfo = Tabular.getRecord(tableName, collection);\n\n    if (!collection || !tableInfo) return;\n\n    // Build options object to pass to `find`.\n    // It's important that we use the same options\n    // that were used in generating the list of `_id`s\n    // on the server.\n    var findOptions = {};\n    var fields = template.tabular.fields;\n    if (fields) {\n      // Extend with extraFields from table definition\n      if (typeof template.tabular.tableDef.extraFields === 'object') {\n        _.extend(fields, template.tabular.tableDef.extraFields);\n      }\n      findOptions.fields = fields;\n    }\n\n    // Sort does not need to be reactive here; using\n    // reactive sort would result in extra rerunning.\n    var sort = Tracker.nonreactive(function () {\n      return template.tabular.sort.get();\n    });\n    if (sort) {\n      findOptions.sort = sort;\n    }\n\n    // Get the updated list of docs we should be showing\n    var cursor = collection.find({_id: {$in: tableInfo.ids}}, findOptions);\n\n    //console.log('tableInfo, fields, sort, find autorun', cursor.count());\n\n    // We're subscribing to the docs just in time, so there's\n    // a good chance that they aren't all sent to the client yet.\n    // We'll stop here if we didn't find all the docs we asked for.\n    // This will rerun one or more times as the docs are received\n    // from the server, and eventually we'll have them all.\n    // Without this check in here, there's a lot of flashing in the\n    // table as rows are added.\n    if (cursor.count() < tableInfo.ids.length) return;\n\n    // Get data as array for DataTables to consume in the ajax function\n    template.tabular.data = cursor.fetch();\n\n    // For these types of reactive changes, we don't want to\n    // reset the page we're on, so we pass `false` as second arg.\n    // The exception is if we changed the results-per-page number,\n    // in which cases `resetTablePaging` will be `true` and we will do so.\n    if (table) {\n      if (resetTablePaging) {\n        table.ajax.reload(null, true);\n        resetTablePaging = false;\n      } else {\n        table.ajax.reload(null, false);\n      }\n    }\n\n    template.tabular.isLoading.set(false);\n  });\n\n  template.autorun(() => {\n    const isLoading = template.tabular.isLoading.get();\n    if (isLoading) {\n      template.$('.dataTables_processing').show();\n    } else {\n      template.$('.dataTables_processing').hide();\n    }\n  });\n\n  // force table paging to reset to first page when we change page length\n  template.$tableElement.on('length.dt', function () {\n    resetTablePaging = true;\n  });\n});\n\nTemplate.tabular.onDestroyed(function () {\n  // Clear last skip tracking\n  Session.set('Tabular.LastSkip', 0);\n  // Run a user-provided onUnload function\n  if (this.tabular &&\n      this.tabular.tableDef &&\n      typeof this.tabular.tableDef.onUnload === 'function') {\n    this.tabular.tableDef.onUnload();\n  }\n\n  // Destroy the DataTable instance to avoid memory leak\n  if (this.$tableElement.length) {\n    const dt = this.$tableElement.DataTable();\n    if (dt) dt.destroy();\n    this.$tableElement.empty();\n  }\n});\n\n//function setUpTestingAutoRunLogging(template) {\n//  template.autorun(function () {\n//    var val = template.tabular.tableName.get();\n//    console.log('tableName changed', val);\n//  });\n//\n//  template.autorun(function () {\n//    var val = template.tabular.pubSelector.get();\n//    console.log('pubSelector changed', val);\n//  });\n//\n//  template.autorun(function () {\n//    var val = template.tabular.sort.get();\n//    console.log('sort changed', val);\n//  });\n//\n//  template.autorun(function () {\n//    var val = template.tabular.skip.get();\n//    console.log('skip changed', val);\n//  });\n//\n//  template.autorun(function () {\n//    var val = template.tabular.limit.get();\n//    console.log('limit changed', val);\n//  });\n//}\n\nexport default Tabular;\n"]},"sourceType":"script","hash":"6b7fd1f90343a0761b9ecf4761cf9eff69368dcb"}
