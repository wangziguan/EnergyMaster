{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$4","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$5","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$6","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$7","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$9","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/autoform-inputs.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/aldeed:autoform/autoform-inputs.js","filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/autoform-inputs.js","passPerPreset":false,"envName":"development","cwd":"/home/wangziguan/wzg/EnergyMaster","root":"/home/wangziguan/wzg/EnergyMaster","generatorOpts":{"filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/autoform-inputs.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/aldeed:autoform/autoform-inputs.js"}},"code":"/* global AutoForm, getInputValue:true, getAllFieldsInForm:true, getInputData:true, updateTrackedFieldValue:true, updateAllTrackedFieldValues:true, getFlatDocOfFieldValues:true */\ngetFlatDocOfFieldValues = function getFlatDocOfFieldValues(fields, ss) {\n  var doc = {};\n  fields.each(function () {\n    var fieldName,\n        val = AutoForm.getInputValue(this, ss);\n\n    if (val !== void 0) {\n      // Get the field/schema key name\n      fieldName = $(this).attr('data-schema-key');\n      doc[fieldName] = val;\n    }\n  });\n  return doc;\n};\n/*\n * package scope functions\n */\n\n/*\n * Gets the value that should be shown/selected in the input. Returns\n * a string, a boolean, or an array of strings. The value used,\n * in order of preference, is one of:\n * * The `value` attribute provided\n * * The value that is set in the `doc` provided on the containing autoForm\n * * The `defaultValue` from the schema\n */\n\n\ngetInputValue = function getInputValue(atts, value, mDoc, schemaDefaultValue, fieldDefaultValue, typeDefs) {\n  if (typeof value === 'undefined') {\n    // Get the value for this key in the current document\n    if (mDoc) {\n      var valueInfo = mDoc.getInfoForKey(atts.name);\n\n      if (valueInfo) {\n        value = valueInfo.value;\n      } else {\n        value = fieldDefaultValue;\n      }\n    } // Only if there is no current document, use the schema defaultValue\n    else {\n        // Use the field default value if provided\n        if (typeof fieldDefaultValue !== 'undefined') {\n          value = fieldDefaultValue;\n        } // Or use the defaultValue in the schema\n        else {\n            value = schemaDefaultValue;\n          }\n      }\n  } // Change null or undefined to an empty string\n\n\n  value = value === null || value === void 0 ? '' : value; // If the component expects the value to be an array, and it's not, make it one\n\n  if (typeDefs.valueIsArray && !_.isArray(value)) {\n    if (typeof value === 'string') {\n      value = value.split(',');\n    } else {\n      value = [value];\n    }\n  } // At this point we have a value or an array of values.\n  // Run through the components valueIn function if we have one.\n  // It should then be in whatever format the component expects.\n\n\n  if (typeof typeDefs.valueIn === 'function') {\n    value = typeDefs.valueIn(value, atts);\n  }\n\n  return value;\n};\n/*\n * Builds the data context that the input component will have.\n */\n\n\ngetInputData = function getInputData(defs, hash, value, label, formType) {\n  /*\n   * Get HTML attributes\n   */\n  // We don't want to alter the original hash, so we clone it and\n  // remove some stuff that should not be HTML attributes.\n  var inputAtts = _.omit(hash, 'type', 'value', 'noselect', 'options', 'template', 'defaultValue', 'data'); // Add required if required\n\n\n  if (typeof inputAtts.required === 'undefined' && !defs.optional) {\n    inputAtts.required = '';\n  } // Add data-schema-key to every type of element\n\n\n  inputAtts['data-schema-key'] = inputAtts.name; // Set placeholder to label from schema if requested.\n  // We check hash.placeholder instead of inputAtts.placeholder because\n  // we're setting inputAtts.placeholder, so it wouldn't be the same on\n  // subsequent reactive runs of this function.\n\n  if (hash.placeholder === 'schemaLabel') {\n    inputAtts.placeholder = label;\n  } // To enable reactively toggling boolean attributes\n  // in a simple way, we add the attributes to the HTML\n  // only if their value is `true`. That is, unlike in\n  // HTML, their mere presence does not matter.\n\n\n  _.each(['disabled', 'readonly', 'checked', 'required', 'autofocus'], function (booleanProp) {\n    if (!_.has(hash, booleanProp)) {\n      return;\n    } // For historical reasons, we treat the string \"true\" and an empty string as `true`, too.\n    // But an empty string value results in the cleanest rendered output for boolean props,\n    // so we standardize as that.\n\n\n    if (hash[booleanProp] === true || hash[booleanProp] === 'true' || hash[booleanProp] === '') {\n      inputAtts[booleanProp] = '';\n    } else {\n      // If the value is anything else, we don't render it\n      delete inputAtts[booleanProp];\n    }\n  });\n  /*\n   * Set up the context. This is the object that becomes `this` in the\n   * input type template.\n   */\n\n\n  var inputTypeContext = {\n    name: inputAtts.name,\n    schemaType: defs.type,\n    min: defs.min,\n    max: defs.max,\n    value: value,\n    atts: inputAtts,\n    selectOptions: AutoForm.Utility.getSelectOptions(defs, hash)\n  };\n  /*\n   * Merge data property from the field schema with the context.\n   * We do not want these turned into HTML attributes.\n   */\n\n  if (hash.data) _.extend(inputTypeContext, hash.data); // Before returning the context, we allow the registered form type to\n  // adjust it if necessary.\n\n  var ftd = Utility.getFormTypeDef(formType);\n\n  if (typeof ftd.adjustInputContext === 'function') {\n    inputTypeContext = ftd.adjustInputContext(inputTypeContext);\n  }\n\n  return inputTypeContext;\n};\n\nfunction markChanged(template, fieldName) {\n  // We always want to be sure to wait for DOM updates to\n  // finish before we indicate that values have changed.\n  // Using a value of 0 here did not work, but 100 seems to\n  // work in testing. We'll need to keep an eye on this.\n  // Not an ideal solution.\n  setTimeout(function () {\n    // Template or view may have disappeared while\n    // we waited to run this\n    if (template && template.view && template.view._domrange && !template.view.isDestroyed && template.formValues[fieldName]) {\n      template.formValues[fieldName].changed();\n      template.formValues[fieldName].requestInProgress = false;\n    }\n  }, 100);\n}\n\nupdateTrackedFieldValue = function updateTrackedFieldValue(template, fieldName) {\n  if (!template) return;\n  template.formValues = template.formValues || {};\n\n  if (!template.formValues[fieldName]) {\n    template.formValues[fieldName] = new Tracker.Dependency();\n  } // In case we call updateTrackedFieldValue from multiple places at once,\n  // call .changed() only once\n\n\n  if (template.formValues[fieldName].requestInProgress) {\n    return;\n  }\n\n  template.formValues[fieldName].requestInProgress = true;\n  markChanged(template, fieldName); // To properly handle array fields, we'll mark the ancestors as changed, too\n  // XXX Might be a more elegant way to handle this\n\n  var dotPos = fieldName.lastIndexOf('.');\n\n  while (dotPos !== -1) {\n    fieldName = fieldName.slice(0, dotPos);\n\n    if (!template.formValues[fieldName]) {\n      template.formValues[fieldName] = new Tracker.Dependency();\n    }\n\n    markChanged(template, fieldName);\n    dotPos = fieldName.lastIndexOf('.');\n  }\n};\n\nupdateAllTrackedFieldValues = function updateAllTrackedFieldValues(template) {\n  if (template && template.formValues) {\n    _.each(template.formValues, function (o, fieldName) {\n      updateTrackedFieldValue(template, fieldName);\n    });\n  }\n};\n\ngetAllFieldsInForm = function getAllFieldsInForm(template) {\n  // Get all elements with `data-schema-key` attribute, unless disabled\n  return template.$('[data-schema-key]').not('[disabled]'); // Exclude fields in sub-forms, since they will belong to a different AutoForm and schema.\n  // TODO need some selector/filter that actually works correctly for excluding subforms\n  // return template.$('[data-schema-key]').not(\"[disabled]\").not(template.$('form form [data-schema-key]'));\n};","map":{"version":3,"sources":["packages/aldeed:autoform/autoform-inputs.js"],"names":["getFlatDocOfFieldValues","fields","ss","doc","each","fieldName","val","AutoForm","getInputValue","$","attr","atts","value","mDoc","schemaDefaultValue","fieldDefaultValue","typeDefs","valueInfo","getInfoForKey","name","valueIsArray","_","isArray","split","valueIn","getInputData","defs","hash","label","formType","inputAtts","omit","required","optional","placeholder","booleanProp","has","inputTypeContext","schemaType","type","min","max","selectOptions","Utility","getSelectOptions","data","extend","ftd","getFormTypeDef","adjustInputContext","markChanged","template","setTimeout","view","_domrange","isDestroyed","formValues","changed","requestInProgress","updateTrackedFieldValue","Tracker","Dependency","dotPos","lastIndexOf","slice","updateAllTrackedFieldValues","o","getAllFieldsInForm","not"],"mappings":"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","sourcesContent":["/* global AutoForm, getInputValue:true, getAllFieldsInForm:true, getInputData:true, updateTrackedFieldValue:true, updateAllTrackedFieldValues:true, getFlatDocOfFieldValues:true */\n\ngetFlatDocOfFieldValues = function getFlatDocOfFieldValues(fields, ss) {\n  var doc = {};\n  fields.each(function () {\n    var fieldName, val = AutoForm.getInputValue(this, ss);\n    if (val !== void 0) {\n      // Get the field/schema key name\n      fieldName = $(this).attr('data-schema-key');\n      doc[fieldName] = val;\n    }\n  });\n  return doc;\n};\n\n/*\n * package scope functions\n */\n\n/*\n * Gets the value that should be shown/selected in the input. Returns\n * a string, a boolean, or an array of strings. The value used,\n * in order of preference, is one of:\n * * The `value` attribute provided\n * * The value that is set in the `doc` provided on the containing autoForm\n * * The `defaultValue` from the schema\n */\ngetInputValue = function getInputValue(atts, value, mDoc, schemaDefaultValue, fieldDefaultValue, typeDefs) {\n\n  if (typeof value === 'undefined') {\n    // Get the value for this key in the current document\n    if (mDoc) {\n      var valueInfo = mDoc.getInfoForKey(atts.name);\n      if (valueInfo) {\n        value = valueInfo.value;\n      } else {\n        value = fieldDefaultValue;\n      }\n    }\n\n    // Only if there is no current document, use the schema defaultValue\n    else {\n      // Use the field default value if provided\n      if (typeof fieldDefaultValue !== 'undefined') {\n        value = fieldDefaultValue;\n      }\n      // Or use the defaultValue in the schema\n      else {\n        value = schemaDefaultValue;\n      }\n    }\n  }\n\n  // Change null or undefined to an empty string\n  value = (value === null || value === void 0) ? '' : value;\n\n  // If the component expects the value to be an array, and it's not, make it one\n  if (typeDefs.valueIsArray && !_.isArray(value)) {\n    if (typeof value === 'string') {\n      value = value.split(',');\n    } else {\n      value = [value];\n    }\n  }\n\n  // At this point we have a value or an array of values.\n  // Run through the components valueIn function if we have one.\n  // It should then be in whatever format the component expects.\n  if (typeof typeDefs.valueIn === 'function') {\n    value = typeDefs.valueIn(value, atts);\n  }\n\n  return value;\n};\n\n/*\n * Builds the data context that the input component will have.\n */\ngetInputData = function getInputData(defs, hash, value, label, formType) {\n\n  /*\n   * Get HTML attributes\n   */\n\n  // We don't want to alter the original hash, so we clone it and\n  // remove some stuff that should not be HTML attributes.\n  var inputAtts = _.omit(hash,\n    'type',\n    'value',\n    'noselect',\n    'options',\n    'template',\n    'defaultValue',\n    'data');\n\n  // Add required if required\n  if (typeof inputAtts.required === 'undefined' && !defs.optional) {\n    inputAtts.required = '';\n  }\n\n   // Add data-schema-key to every type of element\n  inputAtts['data-schema-key'] = inputAtts.name;\n\n  // Set placeholder to label from schema if requested.\n  // We check hash.placeholder instead of inputAtts.placeholder because\n  // we're setting inputAtts.placeholder, so it wouldn't be the same on\n  // subsequent reactive runs of this function.\n  if (hash.placeholder === 'schemaLabel') {\n    inputAtts.placeholder = label;\n  }\n\n  // To enable reactively toggling boolean attributes\n  // in a simple way, we add the attributes to the HTML\n  // only if their value is `true`. That is, unlike in\n  // HTML, their mere presence does not matter.\n  _.each(['disabled', 'readonly', 'checked', 'required', 'autofocus'], function (booleanProp) {\n    if (!_.has(hash, booleanProp)) {\n      return;\n    }\n\n    // For historical reasons, we treat the string \"true\" and an empty string as `true`, too.\n    // But an empty string value results in the cleanest rendered output for boolean props,\n    // so we standardize as that.\n    if (hash[booleanProp] === true || hash[booleanProp] === 'true' || hash[booleanProp] === '') {\n      inputAtts[booleanProp] = '';\n    } else {\n      // If the value is anything else, we don't render it\n      delete inputAtts[booleanProp];\n    }\n  });\n\n  /*\n   * Set up the context. This is the object that becomes `this` in the\n   * input type template.\n   */\n\n  var inputTypeContext = {\n    name: inputAtts.name,\n    schemaType: defs.type,\n    min: defs.min,\n    max: defs.max,\n    value: value,\n    atts: inputAtts,\n    selectOptions: AutoForm.Utility.getSelectOptions(defs, hash)\n  };\n\n  /*\n   * Merge data property from the field schema with the context.\n   * We do not want these turned into HTML attributes.\n   */\n  if (hash.data) _.extend(inputTypeContext, hash.data);\n\n  // Before returning the context, we allow the registered form type to\n  // adjust it if necessary.\n  var ftd = Utility.getFormTypeDef(formType);\n  if (typeof ftd.adjustInputContext === 'function') {\n    inputTypeContext = ftd.adjustInputContext(inputTypeContext);\n  }\n\n  return inputTypeContext;\n};\n\nfunction markChanged(template, fieldName) {\n  // We always want to be sure to wait for DOM updates to\n  // finish before we indicate that values have changed.\n  // Using a value of 0 here did not work, but 100 seems to\n  // work in testing. We'll need to keep an eye on this.\n  // Not an ideal solution.\n  setTimeout(function () {\n    // Template or view may have disappeared while\n    // we waited to run this\n    if (template &&\n        template.view &&\n        template.view._domrange &&\n        !template.view.isDestroyed &&\n        template.formValues[fieldName]) {\n\n      template.formValues[fieldName].changed();\n      template.formValues[fieldName].requestInProgress = false;\n\n    }\n  }, 100);\n}\n\nupdateTrackedFieldValue = function updateTrackedFieldValue(template, fieldName) {\n  if (!template) return;\n\n  template.formValues = template.formValues || {};\n  if (!template.formValues[fieldName]) {\n    template.formValues[fieldName] = new Tracker.Dependency();\n  }\n  // In case we call updateTrackedFieldValue from multiple places at once,\n  // call .changed() only once\n  if (template.formValues[fieldName].requestInProgress) {\n    return;\n  }\n  template.formValues[fieldName].requestInProgress = true;\n\n  markChanged(template, fieldName);\n\n  // To properly handle array fields, we'll mark the ancestors as changed, too\n  // XXX Might be a more elegant way to handle this\n  var dotPos = fieldName.lastIndexOf('.');\n  while (dotPos !== -1) {\n    fieldName = fieldName.slice(0, dotPos);\n\n    if (!template.formValues[fieldName]) {\n      template.formValues[fieldName] = new Tracker.Dependency();\n    }\n\n    markChanged(template, fieldName);\n\n    dotPos = fieldName.lastIndexOf('.');\n  }\n};\n\nupdateAllTrackedFieldValues = function updateAllTrackedFieldValues(template) {\n  if (template && template.formValues) {\n    _.each(template.formValues, function (o, fieldName) {\n      updateTrackedFieldValue(template, fieldName);\n    });\n  }\n};\n\ngetAllFieldsInForm = function getAllFieldsInForm(template) {\n  // Get all elements with `data-schema-key` attribute, unless disabled\n  return template.$('[data-schema-key]').not('[disabled]');\n  // Exclude fields in sub-forms, since they will belong to a different AutoForm and schema.\n  // TODO need some selector/filter that actually works correctly for excluding subforms\n  // return template.$('[data-schema-key]').not(\"[disabled]\").not(template.$('form form [data-schema-key]'));\n};\n"]},"sourceType":"script","hash":"45776696bc5a86ac67c69797a2166cd739fc26be"}
