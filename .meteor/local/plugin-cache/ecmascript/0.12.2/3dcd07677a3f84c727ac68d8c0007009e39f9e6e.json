{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"FunctionExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"ForInStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$6","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"ArrowFunctionExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"BlockStatement":{"enter":[null]},"SwitchCase":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$4","visitor":{"VariableDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"_exploded":true,"BlockStatement":{"enter":[null]},"SwitchStatement":{"enter":[null]},"Program":{"enter":[null]},"_verified":true,"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$5","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$6","visitor":{"ObjectExpression":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$7","visitor":{"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"VariableDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$9","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$11","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$12","visitor":{"ObjectMethod":{"enter":[null]},"ObjectProperty":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$13","visitor":{"ArrayExpression":{"enter":[null]},"CallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$14","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$15","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$16","visitor":{"UnaryExpression":{"enter":[null]},"_exploded":true,"_verified":true,"BlockStatement":{"enter":[null]},"CatchClause":{"enter":[null]},"DoWhileStatement":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForStatement":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"Program":{"enter":[null]},"ObjectMethod":{"enter":[null]},"SwitchStatement":{"enter":[null]},"WhileStatement":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"ForOfStatement":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$17","visitor":{"RegExpLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$18","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$19","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$20","visitor":{"ObjectProperty":{"exit":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$21","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$22","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$23","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"regenerator-transform","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{}}],"presets":[],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/autoform-events.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser.legacy"},"sourceFileName":"packages/aldeed:autoform/autoform-events.js","filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/autoform-events.js","passPerPreset":false,"envName":"development","cwd":"/home/wangziguan/wzg/EnergyMaster","root":"/home/wangziguan/wzg/EnergyMaster","generatorOpts":{"filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/autoform-events.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/aldeed:autoform/autoform-events.js"}},"code":"/* global AutoForm, Hooks, validateField, updateTrackedFieldValue, arrayTracker, updateAllTrackedFieldValues */\n// all form events handled here\nvar lastAutoSaveElement = null;\nvar lastKeyVals = {};\n\nfunction beginSubmit(formId, template, hookContext) {\n  if (!Utility.checkTemplate(template)) return; // Get user-defined hooks\n\n  var hooks = Hooks.getHooks(formId, 'beginSubmit');\n\n  if (hooks.length) {\n    _.each(hooks, function () {\n      function beginSubmitHooks(hook) {\n        hook.call(hookContext);\n      }\n\n      return beginSubmitHooks;\n    }());\n  } else {\n    // If there are no user-defined hooks, by default we disable the submit button during submission\n    var submitButton = template.find(\"button[type=submit]\") || template.find(\"input[type=submit]\");\n\n    if (submitButton) {\n      submitButton.disabled = true;\n    }\n  }\n}\n\nfunction endSubmit(formId, template, hookContext) {\n  if (!Utility.checkTemplate(template)) return; // Try to avoid incorrect reporting of which input caused autosave\n\n  lastAutoSaveElement = null; // Get user-defined hooks\n\n  var hooks = Hooks.getHooks(formId, 'endSubmit');\n\n  if (hooks.length) {\n    _.each(hooks, function () {\n      function endSubmitHooks(hook) {\n        hook.call(hookContext);\n      }\n\n      return endSubmitHooks;\n    }());\n  } else {\n    // If there are no user-defined hooks, by default we disable the submit button during submission\n    var submitButton = template.find(\"button[type=submit]\") || template.find(\"input[type=submit]\");\n\n    if (submitButton) {\n      submitButton.disabled = false;\n    }\n  }\n}\n\nfunction adjustKeyForArrays(key) {\n  var gKey = AutoForm.Utility.makeKeyGeneric(key);\n\n  if (gKey.slice(-2) === '.$' || gKey.indexOf('.$.') !== -1) {\n    key = gKey.slice(0, gKey.indexOf('.$'));\n  }\n\n  return key;\n}\n/**\n * Returns `true` if the specified validation type should\n * be revalidated only when the form is already invalid.\n * @param {String} validationType The validation type string.\n */\n\n\nfunction onlyIfAlreadyInvalid(validationType) {\n  return validationType === 'submitThenKeyup' || validationType === 'submitThenBlur';\n}\n/**\n * Given an element, returns the schema key for it, using the\n * `data-schema-key` attribute on the element or on the closest\n * element that has one.\n *\n * @param   {Element}          element The DOM element\n * @returns {String|undefined} The schema key\n */\n\n\nfunction getKeyForElement(element) {\n  var key = element.getAttribute(\"data-schema-key\");\n\n  if (!key) {\n    key = $(element).closest('[data-schema-key]').attr(\"data-schema-key\");\n  }\n\n  return key;\n} //throttle autosave, at most autosave every 500ms\n\n\nvar throttleAutosave = _.throttle(function (event) {\n  lastAutoSaveElement = event.target;\n  $(event.currentTarget).submit();\n}, 500, {\n  leading: false\n});\n\nTemplate.autoForm.events({\n  'submit form': function () {\n    function autoFormSubmitHandler(event, template) {\n      var formDoc; // Gather necessary form info\n\n      var formId = this.id;\n      var form = AutoForm.getCurrentDataForForm(formId);\n      var formType = form.type; // ss will be the schema for the `schema` attribute if present,\n      // else the schema for the collection\n\n      var ss = AutoForm.getFormSchema(formId);\n      var collection = AutoForm.getFormCollection(formId);\n      var ssIsOverride = !!(collection && form.schema);\n      var currentDoc = form.doc;\n      var docId = currentDoc ? currentDoc._id : null;\n      var isValid;\n      var validationOptions = {\n        validationContext: formId,\n        filter: form.filter,\n        autoConvert: form.autoConvert,\n        removeEmptyStrings: form.removeEmptyStrings,\n        trimStrings: form.trimStrings\n      }; // Get the form type definition\n\n      var ftd;\n\n      try {\n        ftd = Utility.getFormTypeDef(formType);\n      } catch (err) {\n        event.preventDefault();\n        throw err;\n      } // Gather hooks\n\n\n      var onSuccessHooks = Hooks.getHooks(formId, 'onSuccess');\n      var onErrorHooks = Hooks.getHooks(formId, 'onError');\n      var beforeHooks = Hooks.getHooks(formId, 'before', formType);\n      var afterHooks = Hooks.getHooks(formId, 'after', formType); // Prep context with which hooks are called\n\n      var hookContext = {\n        addStickyValidationError: function (key, type, value) {\n          AutoForm.addStickyValidationError(formId, key, type, value);\n        },\n        autoSaveChangedElement: lastAutoSaveElement,\n        collection: collection,\n        currentDoc: currentDoc,\n        docId: docId,\n        event: event,\n        formAttributes: form,\n        formId: formId,\n        formTypeDefinition: ftd,\n        removeStickyValidationError: function (key) {\n          AutoForm.removeStickyValidationError(formId, key);\n        },\n        resetForm: function () {\n          AutoForm.resetForm(formId, template);\n        },\n        ss: ss,\n        ssIsOverride: ssIsOverride,\n        template: template,\n        validationContext: AutoForm.getValidationContext(formId)\n      }; // Gather all form values\n\n      if (ftd.needsModifierAndDoc) {\n        formDoc = AutoForm.getFormValues(formId, template, ss);\n        hookContext.updateDoc = formDoc.updateDoc;\n        hookContext.insertDoc = formDoc.insertDoc;\n      } else if (ftd.usesModifier) {\n        formDoc = AutoForm.getFormValues(formId, template, ss, true);\n        hookContext.updateDoc = formDoc;\n      } else {\n        formDoc = AutoForm.getFormValues(formId, template, ss, false);\n        hookContext.insertDoc = formDoc;\n      } // It is pretty unlikely since we are submitting it, but if\n      // for some reason this form is not currently rendered, we exit.\n\n\n      if (!formDoc) {\n        event.preventDefault();\n        return;\n      }\n\n      function endSubmission() {\n        // Run endSubmit hooks (re-enabled submit button or form, etc.)\n        endSubmit(formId, template, hookContext);\n      }\n\n      function failedValidation() {\n        // add validationErrors array as a property\n        // of the Error object before we call\n        // onError hooks\n        var ec = ss.namedContext(formId);\n        var ik = ec.validationErrors(),\n            error;\n\n        if (ik) {\n          if (ik.length) {\n            error = new Error(ik[0].message || ec.keyErrorMessage(ik[0].name));\n          } else {\n            error = new Error('form failed validation');\n          }\n\n          error.validationErrors = ik;\n        } else {\n          error = new Error('form failed validation');\n        }\n\n        _.each(onErrorHooks, function () {\n          function onErrorEach(hook) {\n            hook.call(hookContext, 'pre-submit validation', error);\n          }\n\n          return onErrorEach;\n        }());\n\n        event.preventDefault();\n        event.stopPropagation();\n        endSubmission();\n      } // Prep function that calls before hooks.\n\n\n      function runBeforeHooks(doc, next) {\n        // We call the hooks recursively, in order added,\n        // passing the result of the first hook to the\n        // second hook, etc.\n        function runHook(i, doc) {\n          var hook = beforeHooks[i];\n\n          if (!hook) {\n            // We've run all hooks; continue submission\n            next(doc);\n            return;\n          } // Define a `result` function\n\n\n          var cb = function (d) {\n            // If the hook returns false, we cancel\n            if (d === false) {\n              endSubmission();\n            } else if (!_.isObject(d)) {\n              throw new Error(\"A 'before' hook must return an object\");\n            } else {\n              runHook(i + 1, d);\n            }\n          }; // Add the `result` function to the before hook context\n\n\n          var ctx = _.extend({\n            result: _.once(cb)\n          }, hookContext);\n\n          var result = hook.call(ctx, doc); // If the hook returns undefined, we wait for it\n          // to call this.result()\n\n          if (result !== void 0) {\n            ctx.result(result);\n          }\n        }\n\n        runHook(0, doc);\n      } // Prep function that calls after, onError, and onSuccess hooks.\n      // Also resets the form on success.\n\n\n      function resultCallback(error, result) {\n        if (error) {\n          if (onErrorHooks && onErrorHooks.length) {\n            _.each(onErrorHooks, function () {\n              function onErrorEach(hook) {\n                hook.call(hookContext, formType, error);\n              }\n\n              return onErrorEach;\n            }());\n          } else if ((!afterHooks || !afterHooks.length) && ss.namedContext(formId).isValid()) {\n            // if there are no onError or \"after\" hooks or validation errors, log the error\n            // because it must be some other error from the server\n            console.log(error);\n          }\n        } else {\n          // By default, we reset form after successful submit, but\n          // you can opt out. We should never reset after submit\n          // when autosaving.\n          if (form.resetOnSuccess !== false && form.autosave !== true) {\n            AutoForm.resetForm(formId, template);\n          } // Set docId in the context for insert forms, too\n\n\n          if (formType === \"insert\") {\n            hookContext.docId = result;\n          }\n\n          _.each(onSuccessHooks, function () {\n            function onSuccessEach(hook) {\n              hook.call(hookContext, formType, result);\n            }\n\n            return onSuccessEach;\n          }());\n        }\n\n        _.each(afterHooks, function () {\n          function afterHooksEach(hook) {\n            hook.call(hookContext, error, result);\n          }\n\n          return afterHooksEach;\n        }());\n\n        endSubmission();\n      } // Run beginSubmit hooks (disable submit button or form, etc.)\n      // NOTE: This needs to stay after getFormValues in case a\n      // beginSubmit hook disables inputs. We don't get values for\n      // disabled inputs, but if they are just disabling during submission,\n      // then we actually do want the values.\n      //\n      // Also keep this before prevalidation so that sticky errors can be\n      // removed in this hook.\n\n\n      beginSubmit(formId, template, hookContext); // Ask form type definition whether we should prevalidate. By default we do.\n\n      var shouldPrevalidate = ftd.shouldPrevalidate ? ftd.shouldPrevalidate.call(hookContext) : true;\n\n      if (shouldPrevalidate) {\n        // This validation pass happens before any \"before\" hooks run. We\n        // validate against the form schema. Then before hooks can add any missing\n        // properties before we validate against the full collection schema.\n        try {\n          isValid = form.validation === 'none' || ftd.validateForm.call({\n            form: form,\n            formDoc: formDoc,\n            useCollectionSchema: false\n          });\n        } catch (e) {\n          // Catch exceptions in validation functions which will bubble up here, cause a form with\n          // onSubmit() to submit prematurely and prevent the error from being reported\n          // (due to a page refresh).\n          console.error('Validation error', e);\n          isValid = false;\n        } // If we failed pre-submit validation, we stop submission.\n\n\n        if (isValid === false) {\n          failedValidation();\n          return;\n        }\n      } // Call onSubmit from the form type definition\n\n\n      ftd.onSubmit.call(_.extend({\n        runBeforeHooks: runBeforeHooks,\n        result: resultCallback,\n        endSubmission: endSubmission,\n        failedValidation: failedValidation,\n        validationOptions: validationOptions,\n        hookContext: hookContext\n      }, hookContext));\n    }\n\n    return autoFormSubmitHandler;\n  }(),\n  'keyup [data-schema-key]': function () {\n    function autoFormKeyUpHandler(event) {\n      // Ignore enter/return, shift, ctrl, cmd, tab, arrows, etc.\n      // Most of these are just optimizations, but without ignoring Enter, errors can fail to show up\n      // because of conflicts between running onSubmit handlers and this around the same time.\n      if (_.contains([13, 9, 16, 20, 17, 91, 37, 38, 39, 40], event.keyCode)) return; // validateField is throttled, so we need to get the nearest form's\n      // ID here, while we're still in the correct context\n\n      var formId = AutoForm.getFormId(); // Get current form data context\n\n      var form = AutoForm.getCurrentDataForForm(formId);\n      var validationType = form.validation;\n      var skipEmpty = !(event.keyCode === 8 || event.keyCode === 46); //if deleting or backspacing, don't skip empty\n\n      if (validationType === 'keyup' || validationType === 'submitThenKeyup') {\n        var key = getKeyForElement(event.currentTarget);\n        if (!key) return;\n        validateField(key, formId, skipEmpty, onlyIfAlreadyInvalid(validationType)); // If it's an array field, we also want to validate the entire topmost array\n        // in case there are minCount/maxCount errors, etc.\n\n        var arrayKey = adjustKeyForArrays(key);\n\n        if (arrayKey !== key) {\n          validateField(arrayKey, formId, skipEmpty, onlyIfAlreadyInvalid(validationType));\n        } // If the form should be auto-saved whenever updated, we do that on field\n        // changes instead of validating the field\n\n\n        if (form.autosaveOnKeyup === true) {\n          throttleAutosave(event);\n        }\n      }\n    }\n\n    return autoFormKeyUpHandler;\n  }(),\n  'blur [data-schema-key]': function () {\n    function autoFormBlurHandler(event) {\n      // validateField is throttled, so we need to get the nearest form's\n      // ID here, while we're still in the correct context\n      var formId = AutoForm.getFormId(); // Get current form data context\n\n      var form = AutoForm.getCurrentDataForForm(formId);\n      var validationType = form.validation;\n\n      if (validationType === 'keyup' || validationType === 'blur' || validationType === 'submitThenKeyup' || validationType === 'submitThenBlur') {\n        var key = getKeyForElement(event.currentTarget);\n\n        if (!key) {\n          return;\n        }\n\n        validateField(key, formId, false, onlyIfAlreadyInvalid(validationType)); // If it's an array field, we also want to validate the entire topmost array\n        // in case there are minCount/maxCount errors, etc.\n\n        var arrayKey = adjustKeyForArrays(key);\n\n        if (arrayKey !== key) {\n          validateField(arrayKey, formId, false, onlyIfAlreadyInvalid(validationType));\n        }\n      }\n    }\n\n    return autoFormBlurHandler;\n  }(),\n  'change form': function () {\n    function autoFormChangeHandler(event, template) {\n      var key = getKeyForElement(event.target);\n\n      if (!key) {\n        return;\n      }\n\n      var formId = this.id; // Some plugins, like jquery.inputmask, can cause infinite\n      // loops by continually saying the field changed when it did not,\n      // especially in an autosave situation. This is an attempt to\n      // prevent that from happening.\n\n      var $target = $(event.target);\n      var keyVal = $target.val();\n\n      if (event.target.type === 'checkbox') {\n        // Special handling for checkboxes, which always have the same value\n        keyVal = keyVal + '_' + $target.prop('checked');\n      }\n\n      keyVal = key + '___' + keyVal;\n\n      if (formId in lastKeyVals && keyVal === lastKeyVals[formId]) {\n        return;\n      }\n\n      lastKeyVals[formId] = keyVal; // Mark field value as changed for reactive updates\n\n      updateTrackedFieldValue(template, key); // Get current form data context\n\n      var form = AutoForm.getCurrentDataForForm(formId); // If the form should be auto-saved whenever updated, we do that on field\n      // changes instead of validating the field\n\n      if (form.autosave === true || form.autosaveOnKeyup === true) {\n        lastAutoSaveElement = event.target;\n        $(event.currentTarget).submit();\n        return;\n      }\n\n      var validationType = form.validation;\n\n      if (validationType === 'keyup' || validationType === 'blur' || validationType === 'submitThenKeyup' || validationType === 'submitThenBlur') {\n        validateField(key, formId, false, onlyIfAlreadyInvalid(validationType)); // If it's an array field, we also want to validate the entire topmost array\n        // in case there are minCount/maxCount errors, etc.\n\n        var arrayKey = adjustKeyForArrays(key);\n\n        if (arrayKey !== key) {\n          validateField(arrayKey, formId, false, onlyIfAlreadyInvalid(validationType));\n        }\n      }\n    }\n\n    return autoFormChangeHandler;\n  }(),\n  'reset form': function () {\n    function autoFormResetHandler(event, template) {\n      var formId = this.id;\n      AutoForm.formPreserve.clearDocument(formId); // Reset array counts\n\n      arrayTracker.resetForm(formId);\n      var vc = AutoForm.getValidationContext(formId);\n      if (vc) vc.reset();\n      event.preventDefault();\n\n      AutoForm._forceResetFormValues(formId); // Mark all fields as changed\n\n\n      updateAllTrackedFieldValues(template); // Focus the autofocus element\n\n      template.$(\"[autofocus]\").focus();\n    }\n\n    return autoFormResetHandler;\n  }(),\n  'keydown .autoform-array-item input': function (event) {\n    // When enter is pressed in an array item field, default behavior\n    // seems to be to \"click\" the remove item button. This doesn't make\n    // sense so we stop it.\n    if (event.keyCode === 13) {\n      event.preventDefault();\n    }\n  },\n  'click .autoform-remove-item': function () {\n    function autoFormClickRemoveItem(event, template) {\n      var self = this; // This type of button must be used within an afEachArrayItem block, so we know the context\n\n      event.preventDefault();\n      var name = self.arrayFieldName;\n      var minCount = self.minCount; // optional, overrides schema\n\n      var maxCount = self.maxCount; // optional, overrides schema\n\n      var index = self.index;\n      var data = template.data;\n      var formId = data && data.id;\n      var ss = AutoForm.getFormSchema(formId); // remove the item we clicked\n\n      arrayTracker.removeFromFieldAtIndex(formId, name, index, ss, minCount, maxCount);\n    }\n\n    return autoFormClickRemoveItem;\n  }(),\n  'click .autoform-add-item': function () {\n    function autoFormClickAddItem(event, template) {\n      event.preventDefault(); // We pull from data attributes because the button could be manually\n      // added anywhere, so we don't know the data context.\n\n      var btn = $(event.currentTarget);\n      var name = btn.attr(\"data-autoform-field\");\n      var minCount = btn.attr(\"data-autoform-minCount\"); // optional, overrides schema\n\n      var maxCount = btn.attr(\"data-autoform-maxCount\"); // optional, overrides schema\n\n      var data = template.data;\n      var formId = data && data.id;\n      var ss = AutoForm.getFormSchema(formId);\n      arrayTracker.addOneToField(formId, name, ss, minCount, maxCount);\n    }\n\n    return autoFormClickAddItem;\n  }()\n});","map":{"version":3,"sources":["packages/aldeed:autoform/autoform-events.js"],"names":["lastAutoSaveElement","lastKeyVals","beginSubmit","formId","template","hookContext","Utility","checkTemplate","hooks","Hooks","getHooks","length","_","each","beginSubmitHooks","hook","call","submitButton","find","disabled","endSubmit","endSubmitHooks","adjustKeyForArrays","key","gKey","AutoForm","makeKeyGeneric","slice","indexOf","onlyIfAlreadyInvalid","validationType","getKeyForElement","element","getAttribute","$","closest","attr","throttleAutosave","throttle","event","target","currentTarget","submit","leading","Template","autoForm","events","autoFormSubmitHandler","formDoc","id","form","getCurrentDataForForm","formType","type","ss","getFormSchema","collection","getFormCollection","ssIsOverride","schema","currentDoc","doc","docId","_id","isValid","validationOptions","validationContext","filter","autoConvert","removeEmptyStrings","trimStrings","ftd","getFormTypeDef","err","preventDefault","onSuccessHooks","onErrorHooks","beforeHooks","afterHooks","addStickyValidationError","value","autoSaveChangedElement","formAttributes","formTypeDefinition","removeStickyValidationError","resetForm","getValidationContext","needsModifierAndDoc","getFormValues","updateDoc","insertDoc","usesModifier","endSubmission","failedValidation","ec","namedContext","ik","validationErrors","error","Error","message","keyErrorMessage","name","onErrorEach","stopPropagation","runBeforeHooks","next","runHook","i","cb","d","isObject","ctx","extend","result","once","resultCallback","console","log","resetOnSuccess","autosave","onSuccessEach","afterHooksEach","shouldPrevalidate","validation","validateForm","useCollectionSchema","e","onSubmit","autoFormKeyUpHandler","contains","keyCode","getFormId","skipEmpty","validateField","arrayKey","autosaveOnKeyup","autoFormBlurHandler","autoFormChangeHandler","$target","keyVal","val","prop","updateTrackedFieldValue","autoFormResetHandler","formPreserve","clearDocument","arrayTracker","vc","reset","_forceResetFormValues","updateAllTrackedFieldValues","focus","autoFormClickRemoveItem","self","arrayFieldName","minCount","maxCount","index","data","removeFromFieldAtIndex","autoFormClickAddItem","btn","addOneToField"],"mappings":"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","sourcesContent":["/* global AutoForm, Hooks, validateField, updateTrackedFieldValue, arrayTracker, updateAllTrackedFieldValues */\n\n// all form events handled here\nvar lastAutoSaveElement = null;\nvar lastKeyVals = {};\n\nfunction beginSubmit(formId, template, hookContext) {\n  if (!Utility.checkTemplate(template)) return;\n\n  // Get user-defined hooks\n  var hooks = Hooks.getHooks(formId, 'beginSubmit');\n  if (hooks.length) {\n    _.each(hooks, function beginSubmitHooks(hook) {\n      hook.call(hookContext);\n    });\n  } else {\n    // If there are no user-defined hooks, by default we disable the submit button during submission\n    var submitButton = template.find(\"button[type=submit]\") || template.find(\"input[type=submit]\");\n    if (submitButton) {\n      submitButton.disabled = true;\n    }\n  }\n}\n\nfunction endSubmit(formId, template, hookContext) {\n  if (!Utility.checkTemplate(template)) return;\n\n  // Try to avoid incorrect reporting of which input caused autosave\n  lastAutoSaveElement = null;\n  // Get user-defined hooks\n  var hooks = Hooks.getHooks(formId, 'endSubmit');\n  if (hooks.length) {\n    _.each(hooks, function endSubmitHooks(hook) {\n      hook.call(hookContext);\n    });\n  } else {\n    // If there are no user-defined hooks, by default we disable the submit button during submission\n    var submitButton = template.find(\"button[type=submit]\") || template.find(\"input[type=submit]\");\n    if (submitButton) {\n      submitButton.disabled = false;\n    }\n  }\n}\n\nfunction adjustKeyForArrays(key) {\n  var gKey = AutoForm.Utility.makeKeyGeneric(key);\n  if (gKey.slice(-2) === '.$' || gKey.indexOf('.$.') !== -1) {\n    key = gKey.slice(0, gKey.indexOf('.$'));\n  }\n  return key;\n}\n\n/**\n * Returns `true` if the specified validation type should\n * be revalidated only when the form is already invalid.\n * @param {String} validationType The validation type string.\n */\nfunction onlyIfAlreadyInvalid(validationType) {\n  return validationType === 'submitThenKeyup' ||\n    validationType === 'submitThenBlur';\n}\n\n/**\n * Given an element, returns the schema key for it, using the\n * `data-schema-key` attribute on the element or on the closest\n * element that has one.\n *\n * @param   {Element}          element The DOM element\n * @returns {String|undefined} The schema key\n */\nfunction getKeyForElement(element) {\n  var key = element.getAttribute(\"data-schema-key\");\n  if (!key) {\n    key = $(element).closest('[data-schema-key]').attr(\"data-schema-key\");\n  }\n  return key;\n}\n\n//throttle autosave, at most autosave every 500ms\nvar throttleAutosave = _.throttle(function(event) {\n  lastAutoSaveElement = event.target;\n  $(event.currentTarget).submit();\n}, 500, {leading: false});\n\nTemplate.autoForm.events({\n  'submit form': function autoFormSubmitHandler(event, template) {\n    var formDoc;\n    // Gather necessary form info\n    var formId = this.id;\n    var form = AutoForm.getCurrentDataForForm(formId);\n    var formType = form.type;\n    // ss will be the schema for the `schema` attribute if present,\n    // else the schema for the collection\n    var ss = AutoForm.getFormSchema(formId);\n    var collection = AutoForm.getFormCollection(formId);\n    var ssIsOverride = !!(collection && form.schema);\n\n    var currentDoc = form.doc;\n    var docId = currentDoc ? currentDoc._id : null;\n    var isValid;\n\n    var validationOptions = {\n      validationContext: formId,\n      filter: form.filter,\n      autoConvert: form.autoConvert,\n      removeEmptyStrings: form.removeEmptyStrings,\n      trimStrings: form.trimStrings\n    };\n\n    // Get the form type definition\n    var ftd;\n    try {\n      ftd = Utility.getFormTypeDef(formType);\n    } catch (err) {\n      event.preventDefault();\n      throw err;\n    }\n\n    // Gather hooks\n    var onSuccessHooks = Hooks.getHooks(formId, 'onSuccess');\n    var onErrorHooks = Hooks.getHooks(formId, 'onError');\n    var beforeHooks = Hooks.getHooks(formId, 'before', formType);\n    var afterHooks = Hooks.getHooks(formId, 'after', formType);\n\n    // Prep context with which hooks are called\n    var hookContext = {\n      addStickyValidationError: function (key, type, value) {\n        AutoForm.addStickyValidationError(formId, key, type, value);\n      },\n      autoSaveChangedElement: lastAutoSaveElement,\n      collection: collection,\n      currentDoc: currentDoc,\n      docId: docId,\n      event: event,\n      formAttributes: form,\n      formId: formId,\n      formTypeDefinition: ftd,\n      removeStickyValidationError: function (key) {\n        AutoForm.removeStickyValidationError(formId, key);\n      },\n      resetForm: function () {\n        AutoForm.resetForm(formId, template);\n      },\n      ss: ss,\n      ssIsOverride: ssIsOverride,\n      template: template,\n      validationContext: AutoForm.getValidationContext(formId)\n    };\n\n    // Gather all form values\n    if (ftd.needsModifierAndDoc) {\n      formDoc = AutoForm.getFormValues(formId, template, ss);\n      hookContext.updateDoc = formDoc.updateDoc;\n      hookContext.insertDoc = formDoc.insertDoc;\n    } else if (ftd.usesModifier) {\n      formDoc = AutoForm.getFormValues(formId, template, ss, true);\n      hookContext.updateDoc = formDoc;\n    } else {\n      formDoc = AutoForm.getFormValues(formId, template, ss, false);\n      hookContext.insertDoc = formDoc;\n    }\n\n    // It is pretty unlikely since we are submitting it, but if\n    // for some reason this form is not currently rendered, we exit.\n    if (!formDoc) {\n      event.preventDefault();\n      return;\n    }\n\n    function endSubmission() {\n      // Run endSubmit hooks (re-enabled submit button or form, etc.)\n      endSubmit(formId, template, hookContext);\n    }\n\n    function failedValidation() {\n      // add validationErrors array as a property\n      // of the Error object before we call\n      // onError hooks\n      var ec = ss.namedContext(formId);\n      var ik = ec.validationErrors(), error;\n      if (ik) {\n        if (ik.length) {\n          error = new Error(ik[0].message || ec.keyErrorMessage(ik[0].name));\n        } else {\n          error = new Error('form failed validation');\n        }\n        error.validationErrors = ik;\n      } else {\n        error = new Error('form failed validation');\n      }\n      _.each(onErrorHooks, function onErrorEach(hook) {\n        hook.call(hookContext, 'pre-submit validation', error);\n      });\n      event.preventDefault();\n      event.stopPropagation();\n      endSubmission();\n    }\n\n    // Prep function that calls before hooks.\n    function runBeforeHooks(doc, next) {\n      // We call the hooks recursively, in order added,\n      // passing the result of the first hook to the\n      // second hook, etc.\n      function runHook(i, doc) {\n        var hook = beforeHooks[i];\n\n        if (!hook) {\n          // We've run all hooks; continue submission\n          next(doc);\n          return;\n        }\n\n        // Define a `result` function\n        var cb = function (d) {\n          // If the hook returns false, we cancel\n          if (d === false) {\n            endSubmission();\n          } else if (!_.isObject(d)) {\n            throw new Error(\"A 'before' hook must return an object\");\n          } else {\n            runHook(i+1, d);\n          }\n        };\n\n        // Add the `result` function to the before hook context\n        var ctx = _.extend({\n          result: _.once(cb)\n        }, hookContext);\n\n        var result = hook.call(ctx, doc);\n\n        // If the hook returns undefined, we wait for it\n        // to call this.result()\n        if (result !== void 0) {\n          ctx.result(result);\n        }\n      }\n\n      runHook(0, doc);\n    }\n\n    // Prep function that calls after, onError, and onSuccess hooks.\n    // Also resets the form on success.\n    function resultCallback(error, result) {\n      if (error) {\n        if (onErrorHooks && onErrorHooks.length) {\n          _.each(onErrorHooks, function onErrorEach(hook) {\n            hook.call(hookContext, formType, error);\n          });\n        } else if ((!afterHooks || !afterHooks.length) && ss.namedContext(formId).isValid()) {\n          // if there are no onError or \"after\" hooks or validation errors, log the error\n          // because it must be some other error from the server\n          console.log(error);\n        }\n      } else {\n        // By default, we reset form after successful submit, but\n        // you can opt out. We should never reset after submit\n        // when autosaving.\n        if (form.resetOnSuccess !== false && form.autosave !== true) {\n          AutoForm.resetForm(formId, template);\n        }\n        // Set docId in the context for insert forms, too\n        if (formType === \"insert\") {\n          hookContext.docId = result;\n        }\n        _.each(onSuccessHooks, function onSuccessEach(hook) {\n          hook.call(hookContext, formType, result);\n        });\n      }\n      _.each(afterHooks, function afterHooksEach(hook) {\n        hook.call(hookContext, error, result);\n      });\n      endSubmission();\n    }\n\n    // Run beginSubmit hooks (disable submit button or form, etc.)\n    // NOTE: This needs to stay after getFormValues in case a\n    // beginSubmit hook disables inputs. We don't get values for\n    // disabled inputs, but if they are just disabling during submission,\n    // then we actually do want the values.\n    //\n    // Also keep this before prevalidation so that sticky errors can be\n    // removed in this hook.\n    beginSubmit(formId, template, hookContext);\n\n    // Ask form type definition whether we should prevalidate. By default we do.\n    var shouldPrevalidate = ftd.shouldPrevalidate ? ftd.shouldPrevalidate.call(hookContext) : true;\n\n    if (shouldPrevalidate) {\n      // This validation pass happens before any \"before\" hooks run. We\n      // validate against the form schema. Then before hooks can add any missing\n      // properties before we validate against the full collection schema.\n      try {\n        isValid = (form.validation === 'none') ||\n          ftd.validateForm.call({\n            form: form,\n            formDoc: formDoc,\n            useCollectionSchema: false\n          });\n      } catch (e) {\n        // Catch exceptions in validation functions which will bubble up here, cause a form with\n        // onSubmit() to submit prematurely and prevent the error from being reported\n        // (due to a page refresh).\n        console.error('Validation error', e);\n        isValid = false;\n      }\n      // If we failed pre-submit validation, we stop submission.\n      if (isValid === false) {\n        failedValidation();\n        return;\n      }\n    }\n\n    // Call onSubmit from the form type definition\n    ftd.onSubmit.call(_.extend({\n      runBeforeHooks: runBeforeHooks,\n      result: resultCallback,\n      endSubmission: endSubmission,\n      failedValidation: failedValidation,\n      validationOptions: validationOptions,\n      hookContext: hookContext\n    }, hookContext));\n  },\n  'keyup [data-schema-key]': function autoFormKeyUpHandler(event) {\n    // Ignore enter/return, shift, ctrl, cmd, tab, arrows, etc.\n    // Most of these are just optimizations, but without ignoring Enter, errors can fail to show up\n    // because of conflicts between running onSubmit handlers and this around the same time.\n    if (_.contains([13, 9, 16, 20, 17, 91, 37, 38, 39, 40], event.keyCode)) return;\n\n    // validateField is throttled, so we need to get the nearest form's\n    // ID here, while we're still in the correct context\n    var formId = AutoForm.getFormId();\n\n    // Get current form data context\n    var form = AutoForm.getCurrentDataForForm(formId);\n\n    var validationType = form.validation;\n    var skipEmpty = !(event.keyCode === 8 || event.keyCode === 46); //if deleting or backspacing, don't skip empty\n\n    if ((validationType === 'keyup' || validationType === 'submitThenKeyup')) {\n      var key = getKeyForElement(event.currentTarget);\n      if (!key) return;\n\n      validateField(key, formId, skipEmpty, onlyIfAlreadyInvalid(validationType));\n\n      // If it's an array field, we also want to validate the entire topmost array\n      // in case there are minCount/maxCount errors, etc.\n      var arrayKey = adjustKeyForArrays(key);\n      if (arrayKey !== key) {\n        validateField(arrayKey, formId, skipEmpty, onlyIfAlreadyInvalid(validationType));\n      }\n\n      // If the form should be auto-saved whenever updated, we do that on field\n      // changes instead of validating the field\n      if (form.autosaveOnKeyup === true) {\n        throttleAutosave(event);\n      }\n    }\n  },\n  'blur [data-schema-key]': function autoFormBlurHandler(event) {\n    // validateField is throttled, so we need to get the nearest form's\n    // ID here, while we're still in the correct context\n    var formId = AutoForm.getFormId();\n\n    // Get current form data context\n    var form = AutoForm.getCurrentDataForForm(formId);\n    var validationType = form.validation;\n\n    if (validationType === 'keyup' ||\n        validationType === 'blur' ||\n        validationType === 'submitThenKeyup' ||\n        validationType === 'submitThenBlur') {\n      var key = getKeyForElement(event.currentTarget);\n      if (!key) {return;}\n\n      validateField(key, formId, false, onlyIfAlreadyInvalid(validationType));\n\n      // If it's an array field, we also want to validate the entire topmost array\n      // in case there are minCount/maxCount errors, etc.\n      var arrayKey = adjustKeyForArrays(key);\n      if (arrayKey !== key) {\n        validateField(arrayKey, formId, false, onlyIfAlreadyInvalid(validationType));\n      }\n    }\n  },\n  'change form': function autoFormChangeHandler(event, template) {\n    var key = getKeyForElement(event.target);\n    if (!key) {return;}\n\n    var formId = this.id;\n\n    // Some plugins, like jquery.inputmask, can cause infinite\n    // loops by continually saying the field changed when it did not,\n    // especially in an autosave situation. This is an attempt to\n    // prevent that from happening.\n    var $target = $(event.target);\n    var keyVal = $target.val();\n    if (event.target.type === 'checkbox') {\n      // Special handling for checkboxes, which always have the same value\n      keyVal = keyVal + '_' + $target.prop('checked');\n    }\n\n    keyVal = key + '___' + keyVal;\n\n    if (formId in lastKeyVals && keyVal === lastKeyVals[formId]) {\n      return;\n    }\n    lastKeyVals[formId] = keyVal;\n\n    // Mark field value as changed for reactive updates\n    updateTrackedFieldValue(template, key);\n\n    // Get current form data context\n    var form = AutoForm.getCurrentDataForForm(formId);\n\n    // If the form should be auto-saved whenever updated, we do that on field\n    // changes instead of validating the field\n    if (form.autosave === true || form.autosaveOnKeyup === true) {\n      lastAutoSaveElement = event.target;\n      $(event.currentTarget).submit();\n      return;\n    }\n\n    var validationType = form.validation;\n\n    if (validationType === 'keyup' ||\n        validationType === 'blur' ||\n        validationType === 'submitThenKeyup' ||\n        validationType === 'submitThenBlur') {\n\n      validateField(key, formId, false, onlyIfAlreadyInvalid(validationType));\n\n      // If it's an array field, we also want to validate the entire topmost array\n      // in case there are minCount/maxCount errors, etc.\n      var arrayKey = adjustKeyForArrays(key);\n      if (arrayKey !== key) {\n        validateField(arrayKey, formId, false, onlyIfAlreadyInvalid(validationType));\n      }\n    }\n  },\n  'reset form': function autoFormResetHandler(event, template) {\n    var formId = this.id;\n\n    AutoForm.formPreserve.clearDocument(formId);\n\n    // Reset array counts\n    arrayTracker.resetForm(formId);\n\n    var vc = AutoForm.getValidationContext(formId);\n    if (vc) vc.reset();\n\n    event.preventDefault();\n    AutoForm._forceResetFormValues(formId);\n\n    // Mark all fields as changed\n    updateAllTrackedFieldValues(template);\n    // Focus the autofocus element\n    template.$(\"[autofocus]\").focus();\n\n  },\n  'keydown .autoform-array-item input': function (event) {\n    // When enter is pressed in an array item field, default behavior\n    // seems to be to \"click\" the remove item button. This doesn't make\n    // sense so we stop it.\n    if (event.keyCode === 13) {\n      event.preventDefault();\n    }\n  },\n  'click .autoform-remove-item': function autoFormClickRemoveItem(event, template) {\n    var self = this; // This type of button must be used within an afEachArrayItem block, so we know the context\n\n    event.preventDefault();\n\n    var name = self.arrayFieldName;\n    var minCount = self.minCount; // optional, overrides schema\n    var maxCount = self.maxCount; // optional, overrides schema\n    var index = self.index;\n    var data = template.data;\n    var formId = data && data.id;\n    var ss = AutoForm.getFormSchema(formId);\n\n    // remove the item we clicked\n    arrayTracker.removeFromFieldAtIndex(formId, name, index, ss, minCount, maxCount);\n  },\n  'click .autoform-add-item': function autoFormClickAddItem(event, template) {\n    event.preventDefault();\n\n    // We pull from data attributes because the button could be manually\n    // added anywhere, so we don't know the data context.\n    var btn = $(event.currentTarget);\n    var name = btn.attr(\"data-autoform-field\");\n    var minCount = btn.attr(\"data-autoform-minCount\"); // optional, overrides schema\n    var maxCount = btn.attr(\"data-autoform-maxCount\"); // optional, overrides schema\n\n    var data = template.data;\n    var formId = data && data.id;\n    var ss = AutoForm.getFormSchema(formId);\n\n    arrayTracker.addOneToField(formId, name, ss, minCount, maxCount);\n  }\n});\n"]},"sourceType":"script","hash":"3dcd07677a3f84c727ac68d8c0007009e39f9e6e"}
