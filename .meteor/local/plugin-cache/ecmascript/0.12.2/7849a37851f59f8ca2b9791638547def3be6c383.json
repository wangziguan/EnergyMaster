{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$4","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$5","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$6","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$7","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$9","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/autoform-helpers.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/aldeed:autoform/autoform-helpers.js","filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/autoform-helpers.js","passPerPreset":false,"envName":"development","cwd":"/home/wangziguan/wzg/EnergyMaster","root":"/home/wangziguan/wzg/EnergyMaster","generatorOpts":{"filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/autoform-helpers.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/aldeed:autoform/autoform-helpers.js"}},"code":"/* global arrayTracker, AutoForm */\nfunction parseOptions(options) {\n  var hash = (options || {}).hash || {}; // Find the form's schema\n\n  var ss = AutoForm.getFormSchema();\n  return _.extend({}, hash, {\n    ss: ss\n  });\n}\n/*\n * Global template helpers (exported to app)\n */\n\n/*\n * afFieldMessage\n */\n\n\nTemplate.registerHelper('afFieldMessage', function autoFormFieldMessage(options) {\n  options = parseOptions(options, 'afFieldMessage');\n  var formId = AutoForm.getFormId();\n  return options.ss.namedContext(formId).keyErrorMessage(options.name);\n});\n/*\n * afFieldIsInvalid\n */\n\nTemplate.registerHelper('afFieldIsInvalid', function autoFormFieldIsInvalid(options) {\n  options = parseOptions(options, 'afFieldIsInvalid');\n  var formId = AutoForm.getFormId();\n  return options.ss.namedContext(formId).keyIsInvalid(options.name);\n});\n/*\n * afArrayFieldHasMoreThanMinimum\n */\n\nTemplate.registerHelper('afArrayFieldHasMoreThanMinimum', function autoFormArrayFieldHasMoreThanMinimum(options) {\n  options = parseOptions(options, 'afArrayFieldHasMoreThanMinimum');\n  var form = AutoForm.getCurrentDataPlusExtrasForForm(); // Registered form types can disable adding/removing array items\n\n  if (form.formTypeDef.hideArrayItemButtons) {\n    return false;\n  }\n\n  var range = arrayTracker.getMinMax(options.ss, options.name, options.minCount, options.maxCount);\n  var visibleCount = arrayTracker.getVisibleCount(form.id, options.name);\n  return visibleCount > range.minCount;\n});\n/*\n * afArrayFieldHasLessThanMaximum\n */\n\nTemplate.registerHelper('afArrayFieldHasLessThanMaximum', function autoFormArrayFieldHasLessThanMaximum(options) {\n  options = parseOptions(options, 'afArrayFieldHasLessThanMaximum');\n  var form = AutoForm.getCurrentDataPlusExtrasForForm(); // Registered form types can disable adding/removing array items\n\n  if (form.formTypeDef.hideArrayItemButtons) {\n    return false;\n  }\n\n  var range = arrayTracker.getMinMax(options.ss, options.name, options.minCount, options.maxCount);\n  var visibleCount = arrayTracker.getVisibleCount(form.id, options.name);\n  return visibleCount < range.maxCount;\n});\n/*\n * afFieldValueIs\n */\n\nTemplate.registerHelper('afFieldValueIs', function autoFormFieldValueIs(options) {\n  options = parseOptions(options, 'afFieldValueIs');\n  var currentValue = AutoForm.getFieldValue(options.name, options.formId);\n  return currentValue === options.value;\n});\n/*\n * afFieldValue\n */\n\nTemplate.registerHelper('afFieldValue', function autoFormFieldValue(options) {\n  options = parseOptions(options, 'afFieldValue');\n  return AutoForm.getFieldValue(options.name, options.formId || AutoForm.getFormId());\n});\n/*\n * afArrayFieldIsFirstVisible\n */\n\nTemplate.registerHelper('afArrayFieldIsFirstVisible', function autoFormArrayFieldIsFirstVisible() {\n  var context = this;\n  return arrayTracker.isFirstFieldlVisible(context.formId, context.arrayFieldName, context.index);\n});\n/*\n * afArrayFieldIsLastVisible\n */\n\nTemplate.registerHelper('afArrayFieldIsLastVisible', function autoFormArrayFieldIsLastVisible() {\n  var context = this;\n  return arrayTracker.isLastFieldlVisible(context.formId, context.arrayFieldName, context.index);\n});\n/*\n * afFieldValueContains\n */\n\nTemplate.registerHelper('afFieldValueContains', function autoFormFieldValueContains(options) {\n  options = parseOptions(options, 'afFieldValueContains');\n  var currentValue = AutoForm.getFieldValue(options.name, options.formId);\n  return _.isArray(currentValue) && (_.contains(currentValue, options.value) || options.values && _.intersection(currentValue, options.values.split(',')));\n});\n/*\n * afFieldLabelText\n */\n\nTemplate.registerHelper('afFieldLabelText', function autoFormFieldLabelText(options) {\n  options = parseOptions(options, 'afFieldLabelText');\n  return AutoForm.getLabelForField(options.name);\n});\n/*\n * afFieldNames\n */\n\nTemplate.registerHelper('afFieldNames', function autoFormFieldNames(options) {\n  options = parseOptions(options, 'afFieldNames');\n  var ss = options.ss,\n      name = options.name,\n      namePlusDot,\n      genericName,\n      genericNamePlusDot;\n  var form = AutoForm.getCurrentDataForForm();\n\n  if (name) {\n    namePlusDot = name + '.';\n    genericName = AutoForm.Utility.makeKeyGeneric(name);\n    genericNamePlusDot = genericName + '.';\n  } // Get the list of fields we want included\n\n\n  var fieldList = options.fields,\n      usedAncestorFieldList = false;\n\n  if (fieldList) {\n    fieldList = AutoForm.Utility.stringToArray(fieldList, 'AutoForm: fields attribute must be an array or a string containing a comma-delimited list of fields');\n  }\n\n  var ancestorFieldList = AutoForm.findAttribute('fields');\n\n  if (ancestorFieldList) {\n    ancestorFieldList = AutoForm.Utility.stringToArray(ancestorFieldList, 'AutoForm: fields attribute must be an array or a string containing a comma-delimited list of fields'); // Use the ancestor field list as backup, unless there is\n    // a name and that name is listed in the ancestor field list\n\n    if (!fieldList) {\n      fieldList = ancestorFieldList;\n      usedAncestorFieldList = true;\n    }\n  }\n\n  if (fieldList) {\n    // Take only those fields in the fieldList that are descendants of the `name` field\n    if (name) {\n      // Replace generic name with real name. We assume that field names\n      // with $ apply to all array items. Field list will now have the\n      // correct array field item number instead of $.\n      if (genericName !== name) {\n        fieldList = _.map(fieldList, function (field) {\n          if (field.indexOf(genericNamePlusDot) === 0) {\n            return namePlusDot + field.slice(genericNamePlusDot.length);\n          }\n\n          return field;\n        });\n      }\n\n      fieldList = _.filter(fieldList, function filterFieldsByName(field) {\n        return field.indexOf(namePlusDot) === 0;\n      });\n    } // If top level fields, be sure to remove any with $ in them\n    else {\n        fieldList = _.filter(fieldList, function filterArrayFields(field) {\n          return field.slice(-2) !== '.$' && field.indexOf('.$.') === -1;\n        });\n      } // First we filter out any fields that are subobjects where the\n    // parent object is also in the fieldList and is NOT the current\n    // field name.\n    // This means that if you do `fields=\"address,address.city\"` we\n    // will use an afObjectField for address and include only the\n    // \"city\" field within that, but if you instead do `fields=\"address.city\"`\n    // we will use a single field for the city, with no afObjectField\n    // template around it.\n\n\n    fieldList = _.reject(fieldList, function (field) {\n      var lastDotPos = field.lastIndexOf('.');\n\n      if (lastDotPos === -1) {\n        return false; // keep\n      }\n\n      var parentField = field.slice(0, lastDotPos);\n\n      if (parentField.slice(-2) === '.$') {\n        parentField = parentField.slice(0, -2);\n      }\n\n      return _.contains(fieldList, parentField) && parentField !== name && parentField !== genericName;\n    });\n  }\n\n  if (!fieldList || fieldList.length === 0 && usedAncestorFieldList) {\n    // Get list of field names that are descendants of this field's name.\n    // If name/genericName is undefined, this will return top-level\n    // schema keys.\n    fieldList = ss.objectKeys(genericName);\n\n    if (name) {\n      // Tack child field name on to end of parent field name. This\n      // ensures that we keep the desired array index for array items.\n      fieldList = _.map(fieldList, function (field) {\n        return name + '.' + field;\n      });\n    }\n  } // If user wants to omit some fields, remove those from the array\n\n\n  var omitFields = options.omitFields || AutoForm.findAttribute('omitFields');\n\n  if (omitFields) {\n    omitFields = AutoForm.Utility.stringToArray(omitFields, 'AutoForm: omitFields attribute must be an array or a string containing a comma-delimited list of fields');\n    fieldList = _.difference(fieldList, omitFields); // If omitFields contains generic field names (with $) we omit those too\n\n    fieldList = _.reject(fieldList, function (f) {\n      return _.contains(omitFields, AutoForm.Utility.makeKeyGeneric(f));\n    });\n  } // Filter out fields we never want\n\n\n  fieldList = _.filter(fieldList, function shouldIncludeField(field) {\n    var fieldDefs = AutoForm.Utility.getFieldDefinition(ss, field); // Don't include fields that are not in the schema\n\n    if (!fieldDefs) {\n      return false;\n    } // Don't include fields with autoform.omit=true\n\n\n    if (fieldDefs.autoform && fieldDefs.autoform.omit === true) {\n      return false;\n    } // Don't include fields with denyInsert=true when it's an insert form\n\n\n    if (fieldDefs.denyInsert && form.type === 'insert') {\n      return false;\n    } // Don't include fields with denyUpdate=true when it's an update form\n\n\n    if (fieldDefs.denyUpdate && form.type === 'update') {\n      return false;\n    }\n\n    return true;\n  }); // Ensure fields are not added more than once\n\n  fieldList = _.unique(fieldList); // We return it as an array of objects because that\n  // works better with Blaze contexts\n\n  fieldList = _.map(fieldList, function (name) {\n    return {\n      name: name\n    };\n  });\n  return fieldList;\n});\n/*\n * afSelectOptionAtts\n */\n\nTemplate.registerHelper('afSelectOptionAtts', function afSelectOptionAtts() {\n  var atts = _.pick(this, 'value');\n\n  if (this.selected) {\n    atts.selected = '';\n  }\n\n  if (this.htmlAtts) {\n    _.extend(atts, this.htmlAtts);\n  }\n\n  return atts;\n}); // Expects to be called with this.name available\n\nTemplate.registerHelper('afOptionsFromSchema', function afOptionsFromSchema() {\n  return AutoForm._getOptionsForField(this.name);\n});","map":{"version":3,"sources":["packages/aldeed:autoform/autoform-helpers.js"],"names":["parseOptions","options","hash","ss","AutoForm","getFormSchema","_","extend","Template","registerHelper","autoFormFieldMessage","formId","getFormId","namedContext","keyErrorMessage","name","autoFormFieldIsInvalid","keyIsInvalid","autoFormArrayFieldHasMoreThanMinimum","form","getCurrentDataPlusExtrasForForm","formTypeDef","hideArrayItemButtons","range","arrayTracker","getMinMax","minCount","maxCount","visibleCount","getVisibleCount","id","autoFormArrayFieldHasLessThanMaximum","autoFormFieldValueIs","currentValue","getFieldValue","value","autoFormFieldValue","autoFormArrayFieldIsFirstVisible","context","isFirstFieldlVisible","arrayFieldName","index","autoFormArrayFieldIsLastVisible","isLastFieldlVisible","autoFormFieldValueContains","isArray","contains","values","intersection","split","autoFormFieldLabelText","getLabelForField","autoFormFieldNames","namePlusDot","genericName","genericNamePlusDot","getCurrentDataForForm","Utility","makeKeyGeneric","fieldList","fields","usedAncestorFieldList","stringToArray","ancestorFieldList","findAttribute","map","field","indexOf","slice","length","filter","filterFieldsByName","filterArrayFields","reject","lastDotPos","lastIndexOf","parentField","objectKeys","omitFields","difference","f","shouldIncludeField","fieldDefs","getFieldDefinition","autoform","omit","denyInsert","type","denyUpdate","unique","afSelectOptionAtts","atts","pick","selected","htmlAtts","afOptionsFromSchema","_getOptionsForField"],"mappings":"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","sourcesContent":["/* global arrayTracker, AutoForm */\n\nfunction parseOptions(options) {\n  var hash = (options || {}).hash || {};\n  // Find the form's schema\n  var ss = AutoForm.getFormSchema();\n  return _.extend({}, hash, { ss: ss });\n}\n\n/*\n * Global template helpers (exported to app)\n */\n\n/*\n * afFieldMessage\n */\nTemplate.registerHelper('afFieldMessage', function autoFormFieldMessage(options) {\n  options = parseOptions(options, 'afFieldMessage');\n  var formId = AutoForm.getFormId();\n\n  return options.ss.namedContext(formId).keyErrorMessage(options.name);\n});\n\n/*\n * afFieldIsInvalid\n */\nTemplate.registerHelper('afFieldIsInvalid', function autoFormFieldIsInvalid(options) {\n  options = parseOptions(options, 'afFieldIsInvalid');\n  var formId = AutoForm.getFormId();\n\n  return options.ss.namedContext(formId).keyIsInvalid(options.name);\n});\n\n/*\n * afArrayFieldHasMoreThanMinimum\n */\nTemplate.registerHelper('afArrayFieldHasMoreThanMinimum', function autoFormArrayFieldHasMoreThanMinimum(options) {\n  options = parseOptions(options, 'afArrayFieldHasMoreThanMinimum');\n  var form = AutoForm.getCurrentDataPlusExtrasForForm();\n\n  // Registered form types can disable adding/removing array items\n  if (form.formTypeDef.hideArrayItemButtons) {\n    return false;\n  }\n\n  var range = arrayTracker.getMinMax(options.ss, options.name, options.minCount, options.maxCount);\n  var visibleCount = arrayTracker.getVisibleCount(form.id, options.name);\n  return (visibleCount > range.minCount);\n});\n\n/*\n * afArrayFieldHasLessThanMaximum\n */\nTemplate.registerHelper('afArrayFieldHasLessThanMaximum', function autoFormArrayFieldHasLessThanMaximum(options) {\n  options = parseOptions(options, 'afArrayFieldHasLessThanMaximum');\n  var form = AutoForm.getCurrentDataPlusExtrasForForm();\n\n  // Registered form types can disable adding/removing array items\n  if (form.formTypeDef.hideArrayItemButtons) {\n    return false;\n  }\n\n  var range = arrayTracker.getMinMax(options.ss, options.name, options.minCount, options.maxCount);\n  var visibleCount = arrayTracker.getVisibleCount(form.id, options.name);\n  return (visibleCount < range.maxCount);\n});\n\n/*\n * afFieldValueIs\n */\nTemplate.registerHelper('afFieldValueIs', function autoFormFieldValueIs(options) {\n  options = parseOptions(options, 'afFieldValueIs');\n\n  var currentValue = AutoForm.getFieldValue(options.name, options.formId);\n  return currentValue === options.value;\n});\n\n/*\n * afFieldValue\n */\nTemplate.registerHelper('afFieldValue', function autoFormFieldValue(options) {\n  options = parseOptions(options, 'afFieldValue');\n\n  return AutoForm.getFieldValue(options.name, options.formId || AutoForm.getFormId());\n});\n\n/*\n * afArrayFieldIsFirstVisible\n */\nTemplate.registerHelper('afArrayFieldIsFirstVisible', function autoFormArrayFieldIsFirstVisible() {\n  var context = this;\n  return arrayTracker.isFirstFieldlVisible(context.formId, context.arrayFieldName, context.index);\n});\n\n/*\n * afArrayFieldIsLastVisible\n */\nTemplate.registerHelper('afArrayFieldIsLastVisible', function autoFormArrayFieldIsLastVisible() {\n  var context = this;\n  return arrayTracker.isLastFieldlVisible(context.formId, context.arrayFieldName, context.index);\n});\n\n/*\n * afFieldValueContains\n */\nTemplate.registerHelper('afFieldValueContains', function autoFormFieldValueContains(options) {\n  options = parseOptions(options, 'afFieldValueContains');\n\n  var currentValue = AutoForm.getFieldValue(options.name, options.formId);\n  return _.isArray(currentValue) && (_.contains(currentValue, options.value) || options.values && _.intersection(currentValue, options.values.split(',')));\n});\n\n/*\n * afFieldLabelText\n */\nTemplate.registerHelper('afFieldLabelText', function autoFormFieldLabelText(options) {\n  options = parseOptions(options, 'afFieldLabelText');\n  return AutoForm.getLabelForField(options.name);\n});\n\n/*\n * afFieldNames\n */\nTemplate.registerHelper('afFieldNames', function autoFormFieldNames(options) {\n  options = parseOptions(options, 'afFieldNames');\n  var ss = options.ss, name = options.name, namePlusDot, genericName, genericNamePlusDot;\n  var form = AutoForm.getCurrentDataForForm();\n\n  if (name) {\n    namePlusDot = name + '.';\n    genericName = AutoForm.Utility.makeKeyGeneric(name);\n    genericNamePlusDot = genericName + '.';\n  }\n\n  // Get the list of fields we want included\n  var fieldList = options.fields, usedAncestorFieldList = false;\n  if (fieldList) {\n    fieldList = AutoForm.Utility.stringToArray(fieldList, 'AutoForm: fields attribute must be an array or a string containing a comma-delimited list of fields');\n  }\n\n  var ancestorFieldList = AutoForm.findAttribute('fields');\n  if (ancestorFieldList) {\n    ancestorFieldList = AutoForm.Utility.stringToArray(ancestorFieldList, 'AutoForm: fields attribute must be an array or a string containing a comma-delimited list of fields');\n\n    // Use the ancestor field list as backup, unless there is\n    // a name and that name is listed in the ancestor field list\n    if (!fieldList) {\n      fieldList = ancestorFieldList;\n      usedAncestorFieldList = true;\n    }\n  }\n\n  if (fieldList) {\n\n    // Take only those fields in the fieldList that are descendants of the `name` field\n    if (name) {\n      // Replace generic name with real name. We assume that field names\n      // with $ apply to all array items. Field list will now have the\n      // correct array field item number instead of $.\n      if (genericName !== name) {\n        fieldList = _.map(fieldList, function (field) {\n          if (field.indexOf(genericNamePlusDot) === 0) {\n            return namePlusDot + field.slice(genericNamePlusDot.length);\n          }\n          return field;\n        });\n      }\n\n      fieldList = _.filter(fieldList, function filterFieldsByName(field) {\n        return field.indexOf(namePlusDot) === 0;\n      });\n    }\n\n    // If top level fields, be sure to remove any with $ in them\n    else {\n      fieldList = _.filter(fieldList, function filterArrayFields(field) {\n        return (field.slice(-2) !== '.$' && field.indexOf('.$.') === -1);\n      });\n    }\n\n    // First we filter out any fields that are subobjects where the\n    // parent object is also in the fieldList and is NOT the current\n    // field name.\n    // This means that if you do `fields=\"address,address.city\"` we\n    // will use an afObjectField for address and include only the\n    // \"city\" field within that, but if you instead do `fields=\"address.city\"`\n    // we will use a single field for the city, with no afObjectField\n    // template around it.\n    fieldList = _.reject(fieldList, function (field) {\n      var lastDotPos = field.lastIndexOf('.');\n      if (lastDotPos === -1) {\n        return false; // keep\n      }\n\n      var parentField = field.slice(0, lastDotPos);\n      if (parentField.slice(-2) === '.$') {\n        parentField = parentField.slice(0, -2);\n      }\n      return _.contains(fieldList, parentField) && parentField !== name && parentField !== genericName;\n    });\n  }\n\n  if (!fieldList || (fieldList.length === 0 && usedAncestorFieldList)) {\n    // Get list of field names that are descendants of this field's name.\n    // If name/genericName is undefined, this will return top-level\n    // schema keys.\n    fieldList = ss.objectKeys(genericName);\n\n    if (name) {\n      // Tack child field name on to end of parent field name. This\n      // ensures that we keep the desired array index for array items.\n      fieldList = _.map(fieldList, function (field) {\n        return name + '.' + field;\n      });\n    }\n  }\n\n  // If user wants to omit some fields, remove those from the array\n  var omitFields = options.omitFields || AutoForm.findAttribute('omitFields');\n  if (omitFields) {\n    omitFields = AutoForm.Utility.stringToArray(omitFields, 'AutoForm: omitFields attribute must be an array or a string containing a comma-delimited list of fields');\n    fieldList = _.difference(fieldList, omitFields);\n    // If omitFields contains generic field names (with $) we omit those too\n    fieldList = _.reject(fieldList, function (f) {\n      return _.contains(omitFields, AutoForm.Utility.makeKeyGeneric(f));\n    });\n  }\n\n  // Filter out fields we never want\n  fieldList = _.filter(fieldList, function shouldIncludeField(field) {\n    var fieldDefs = AutoForm.Utility.getFieldDefinition(ss, field);\n\n    // Don't include fields that are not in the schema\n    if (!fieldDefs) {\n      return false;\n    }\n\n    // Don't include fields with autoform.omit=true\n    if (fieldDefs.autoform && fieldDefs.autoform.omit === true) {\n      return false;\n    }\n\n    // Don't include fields with denyInsert=true when it's an insert form\n    if (fieldDefs.denyInsert && form.type === 'insert') {\n      return false;\n    }\n\n    // Don't include fields with denyUpdate=true when it's an update form\n    if (fieldDefs.denyUpdate && form.type === 'update') {\n      return false;\n    }\n\n    return true;\n  });\n\n  // Ensure fields are not added more than once\n  fieldList = _.unique(fieldList);\n\n  // We return it as an array of objects because that\n  // works better with Blaze contexts\n  fieldList = _.map(fieldList, function (name) {\n    return { name: name };\n  });\n\n  return fieldList;\n});\n\n\n/*\n * afSelectOptionAtts\n */\nTemplate.registerHelper('afSelectOptionAtts', function afSelectOptionAtts() {\n  var atts = _.pick(this, 'value');\n  if (this.selected) {\n    atts.selected = '';\n  }\n  if (this.htmlAtts) {\n    _.extend(atts, this.htmlAtts);\n  }\n  return atts;\n});\n\n// Expects to be called with this.name available\nTemplate.registerHelper('afOptionsFromSchema', function afOptionsFromSchema() {\n  return AutoForm._getOptionsForField(this.name);\n});\n"]},"sourceType":"script","hash":"7849a37851f59f8ca2b9791638547def3be6c383"}
