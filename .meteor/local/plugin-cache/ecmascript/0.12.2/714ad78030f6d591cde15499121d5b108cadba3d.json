{"metadata":{},"options":{"plugins":[{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$2","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}},{"key":"base$0$4","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$0$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$2","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$3","visitor":{"ForOfStatement":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"loose":true}},{"key":"base$0$0$4","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$5","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$6","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]}},"options":{}},{"key":"base$0$0$7","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"base$0$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$0$9","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0$10","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}}],"presets":[],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/autoform-events.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","dynamicImport","classProperties","classPrivateProperties","jsx",["flow",{}],"asyncGenerators","objectRestSpread","objectRestSpread",["flow",{}],"asyncGenerators"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"web.browser"},"sourceFileName":"packages/aldeed:autoform/autoform-events.js","filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/autoform-events.js","passPerPreset":false,"envName":"development","cwd":"/home/wangziguan/wzg/EnergyMaster","root":"/home/wangziguan/wzg/EnergyMaster","generatorOpts":{"filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:autoform/autoform-events.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/aldeed:autoform/autoform-events.js"}},"code":"/* global AutoForm, Hooks, validateField, updateTrackedFieldValue, arrayTracker, updateAllTrackedFieldValues */\n// all form events handled here\nvar lastAutoSaveElement = null;\nvar lastKeyVals = {};\n\nfunction beginSubmit(formId, template, hookContext) {\n  if (!Utility.checkTemplate(template)) return; // Get user-defined hooks\n\n  var hooks = Hooks.getHooks(formId, 'beginSubmit');\n\n  if (hooks.length) {\n    _.each(hooks, function beginSubmitHooks(hook) {\n      hook.call(hookContext);\n    });\n  } else {\n    // If there are no user-defined hooks, by default we disable the submit button during submission\n    var submitButton = template.find(\"button[type=submit]\") || template.find(\"input[type=submit]\");\n\n    if (submitButton) {\n      submitButton.disabled = true;\n    }\n  }\n}\n\nfunction endSubmit(formId, template, hookContext) {\n  if (!Utility.checkTemplate(template)) return; // Try to avoid incorrect reporting of which input caused autosave\n\n  lastAutoSaveElement = null; // Get user-defined hooks\n\n  var hooks = Hooks.getHooks(formId, 'endSubmit');\n\n  if (hooks.length) {\n    _.each(hooks, function endSubmitHooks(hook) {\n      hook.call(hookContext);\n    });\n  } else {\n    // If there are no user-defined hooks, by default we disable the submit button during submission\n    var submitButton = template.find(\"button[type=submit]\") || template.find(\"input[type=submit]\");\n\n    if (submitButton) {\n      submitButton.disabled = false;\n    }\n  }\n}\n\nfunction adjustKeyForArrays(key) {\n  var gKey = AutoForm.Utility.makeKeyGeneric(key);\n\n  if (gKey.slice(-2) === '.$' || gKey.indexOf('.$.') !== -1) {\n    key = gKey.slice(0, gKey.indexOf('.$'));\n  }\n\n  return key;\n}\n/**\n * Returns `true` if the specified validation type should\n * be revalidated only when the form is already invalid.\n * @param {String} validationType The validation type string.\n */\n\n\nfunction onlyIfAlreadyInvalid(validationType) {\n  return validationType === 'submitThenKeyup' || validationType === 'submitThenBlur';\n}\n/**\n * Given an element, returns the schema key for it, using the\n * `data-schema-key` attribute on the element or on the closest\n * element that has one.\n *\n * @param   {Element}          element The DOM element\n * @returns {String|undefined} The schema key\n */\n\n\nfunction getKeyForElement(element) {\n  var key = element.getAttribute(\"data-schema-key\");\n\n  if (!key) {\n    key = $(element).closest('[data-schema-key]').attr(\"data-schema-key\");\n  }\n\n  return key;\n} //throttle autosave, at most autosave every 500ms\n\n\nvar throttleAutosave = _.throttle(function (event) {\n  lastAutoSaveElement = event.target;\n  $(event.currentTarget).submit();\n}, 500, {\n  leading: false\n});\n\nTemplate.autoForm.events({\n  'submit form': function autoFormSubmitHandler(event, template) {\n    var formDoc; // Gather necessary form info\n\n    var formId = this.id;\n    var form = AutoForm.getCurrentDataForForm(formId);\n    var formType = form.type; // ss will be the schema for the `schema` attribute if present,\n    // else the schema for the collection\n\n    var ss = AutoForm.getFormSchema(formId);\n    var collection = AutoForm.getFormCollection(formId);\n    var ssIsOverride = !!(collection && form.schema);\n    var currentDoc = form.doc;\n    var docId = currentDoc ? currentDoc._id : null;\n    var isValid;\n    var validationOptions = {\n      validationContext: formId,\n      filter: form.filter,\n      autoConvert: form.autoConvert,\n      removeEmptyStrings: form.removeEmptyStrings,\n      trimStrings: form.trimStrings\n    }; // Get the form type definition\n\n    var ftd;\n\n    try {\n      ftd = Utility.getFormTypeDef(formType);\n    } catch (err) {\n      event.preventDefault();\n      throw err;\n    } // Gather hooks\n\n\n    var onSuccessHooks = Hooks.getHooks(formId, 'onSuccess');\n    var onErrorHooks = Hooks.getHooks(formId, 'onError');\n    var beforeHooks = Hooks.getHooks(formId, 'before', formType);\n    var afterHooks = Hooks.getHooks(formId, 'after', formType); // Prep context with which hooks are called\n\n    var hookContext = {\n      addStickyValidationError: function (key, type, value) {\n        AutoForm.addStickyValidationError(formId, key, type, value);\n      },\n      autoSaveChangedElement: lastAutoSaveElement,\n      collection: collection,\n      currentDoc: currentDoc,\n      docId: docId,\n      event: event,\n      formAttributes: form,\n      formId: formId,\n      formTypeDefinition: ftd,\n      removeStickyValidationError: function (key) {\n        AutoForm.removeStickyValidationError(formId, key);\n      },\n      resetForm: function () {\n        AutoForm.resetForm(formId, template);\n      },\n      ss: ss,\n      ssIsOverride: ssIsOverride,\n      template: template,\n      validationContext: AutoForm.getValidationContext(formId)\n    }; // Gather all form values\n\n    if (ftd.needsModifierAndDoc) {\n      formDoc = AutoForm.getFormValues(formId, template, ss);\n      hookContext.updateDoc = formDoc.updateDoc;\n      hookContext.insertDoc = formDoc.insertDoc;\n    } else if (ftd.usesModifier) {\n      formDoc = AutoForm.getFormValues(formId, template, ss, true);\n      hookContext.updateDoc = formDoc;\n    } else {\n      formDoc = AutoForm.getFormValues(formId, template, ss, false);\n      hookContext.insertDoc = formDoc;\n    } // It is pretty unlikely since we are submitting it, but if\n    // for some reason this form is not currently rendered, we exit.\n\n\n    if (!formDoc) {\n      event.preventDefault();\n      return;\n    }\n\n    function endSubmission() {\n      // Run endSubmit hooks (re-enabled submit button or form, etc.)\n      endSubmit(formId, template, hookContext);\n    }\n\n    function failedValidation() {\n      // add validationErrors array as a property\n      // of the Error object before we call\n      // onError hooks\n      var ec = ss.namedContext(formId);\n      var ik = ec.validationErrors(),\n          error;\n\n      if (ik) {\n        if (ik.length) {\n          error = new Error(ik[0].message || ec.keyErrorMessage(ik[0].name));\n        } else {\n          error = new Error('form failed validation');\n        }\n\n        error.validationErrors = ik;\n      } else {\n        error = new Error('form failed validation');\n      }\n\n      _.each(onErrorHooks, function onErrorEach(hook) {\n        hook.call(hookContext, 'pre-submit validation', error);\n      });\n\n      event.preventDefault();\n      event.stopPropagation();\n      endSubmission();\n    } // Prep function that calls before hooks.\n\n\n    function runBeforeHooks(doc, next) {\n      // We call the hooks recursively, in order added,\n      // passing the result of the first hook to the\n      // second hook, etc.\n      function runHook(i, doc) {\n        var hook = beforeHooks[i];\n\n        if (!hook) {\n          // We've run all hooks; continue submission\n          next(doc);\n          return;\n        } // Define a `result` function\n\n\n        var cb = function (d) {\n          // If the hook returns false, we cancel\n          if (d === false) {\n            endSubmission();\n          } else if (!_.isObject(d)) {\n            throw new Error(\"A 'before' hook must return an object\");\n          } else {\n            runHook(i + 1, d);\n          }\n        }; // Add the `result` function to the before hook context\n\n\n        var ctx = _.extend({\n          result: _.once(cb)\n        }, hookContext);\n\n        var result = hook.call(ctx, doc); // If the hook returns undefined, we wait for it\n        // to call this.result()\n\n        if (result !== void 0) {\n          ctx.result(result);\n        }\n      }\n\n      runHook(0, doc);\n    } // Prep function that calls after, onError, and onSuccess hooks.\n    // Also resets the form on success.\n\n\n    function resultCallback(error, result) {\n      if (error) {\n        if (onErrorHooks && onErrorHooks.length) {\n          _.each(onErrorHooks, function onErrorEach(hook) {\n            hook.call(hookContext, formType, error);\n          });\n        } else if ((!afterHooks || !afterHooks.length) && ss.namedContext(formId).isValid()) {\n          // if there are no onError or \"after\" hooks or validation errors, log the error\n          // because it must be some other error from the server\n          console.log(error);\n        }\n      } else {\n        // By default, we reset form after successful submit, but\n        // you can opt out. We should never reset after submit\n        // when autosaving.\n        if (form.resetOnSuccess !== false && form.autosave !== true) {\n          AutoForm.resetForm(formId, template);\n        } // Set docId in the context for insert forms, too\n\n\n        if (formType === \"insert\") {\n          hookContext.docId = result;\n        }\n\n        _.each(onSuccessHooks, function onSuccessEach(hook) {\n          hook.call(hookContext, formType, result);\n        });\n      }\n\n      _.each(afterHooks, function afterHooksEach(hook) {\n        hook.call(hookContext, error, result);\n      });\n\n      endSubmission();\n    } // Run beginSubmit hooks (disable submit button or form, etc.)\n    // NOTE: This needs to stay after getFormValues in case a\n    // beginSubmit hook disables inputs. We don't get values for\n    // disabled inputs, but if they are just disabling during submission,\n    // then we actually do want the values.\n    //\n    // Also keep this before prevalidation so that sticky errors can be\n    // removed in this hook.\n\n\n    beginSubmit(formId, template, hookContext); // Ask form type definition whether we should prevalidate. By default we do.\n\n    var shouldPrevalidate = ftd.shouldPrevalidate ? ftd.shouldPrevalidate.call(hookContext) : true;\n\n    if (shouldPrevalidate) {\n      // This validation pass happens before any \"before\" hooks run. We\n      // validate against the form schema. Then before hooks can add any missing\n      // properties before we validate against the full collection schema.\n      try {\n        isValid = form.validation === 'none' || ftd.validateForm.call({\n          form: form,\n          formDoc: formDoc,\n          useCollectionSchema: false\n        });\n      } catch (e) {\n        // Catch exceptions in validation functions which will bubble up here, cause a form with\n        // onSubmit() to submit prematurely and prevent the error from being reported\n        // (due to a page refresh).\n        console.error('Validation error', e);\n        isValid = false;\n      } // If we failed pre-submit validation, we stop submission.\n\n\n      if (isValid === false) {\n        failedValidation();\n        return;\n      }\n    } // Call onSubmit from the form type definition\n\n\n    ftd.onSubmit.call(_.extend({\n      runBeforeHooks: runBeforeHooks,\n      result: resultCallback,\n      endSubmission: endSubmission,\n      failedValidation: failedValidation,\n      validationOptions: validationOptions,\n      hookContext: hookContext\n    }, hookContext));\n  },\n  'keyup [data-schema-key]': function autoFormKeyUpHandler(event) {\n    // Ignore enter/return, shift, ctrl, cmd, tab, arrows, etc.\n    // Most of these are just optimizations, but without ignoring Enter, errors can fail to show up\n    // because of conflicts between running onSubmit handlers and this around the same time.\n    if (_.contains([13, 9, 16, 20, 17, 91, 37, 38, 39, 40], event.keyCode)) return; // validateField is throttled, so we need to get the nearest form's\n    // ID here, while we're still in the correct context\n\n    var formId = AutoForm.getFormId(); // Get current form data context\n\n    var form = AutoForm.getCurrentDataForForm(formId);\n    var validationType = form.validation;\n    var skipEmpty = !(event.keyCode === 8 || event.keyCode === 46); //if deleting or backspacing, don't skip empty\n\n    if (validationType === 'keyup' || validationType === 'submitThenKeyup') {\n      var key = getKeyForElement(event.currentTarget);\n      if (!key) return;\n      validateField(key, formId, skipEmpty, onlyIfAlreadyInvalid(validationType)); // If it's an array field, we also want to validate the entire topmost array\n      // in case there are minCount/maxCount errors, etc.\n\n      var arrayKey = adjustKeyForArrays(key);\n\n      if (arrayKey !== key) {\n        validateField(arrayKey, formId, skipEmpty, onlyIfAlreadyInvalid(validationType));\n      } // If the form should be auto-saved whenever updated, we do that on field\n      // changes instead of validating the field\n\n\n      if (form.autosaveOnKeyup === true) {\n        throttleAutosave(event);\n      }\n    }\n  },\n  'blur [data-schema-key]': function autoFormBlurHandler(event) {\n    // validateField is throttled, so we need to get the nearest form's\n    // ID here, while we're still in the correct context\n    var formId = AutoForm.getFormId(); // Get current form data context\n\n    var form = AutoForm.getCurrentDataForForm(formId);\n    var validationType = form.validation;\n\n    if (validationType === 'keyup' || validationType === 'blur' || validationType === 'submitThenKeyup' || validationType === 'submitThenBlur') {\n      var key = getKeyForElement(event.currentTarget);\n\n      if (!key) {\n        return;\n      }\n\n      validateField(key, formId, false, onlyIfAlreadyInvalid(validationType)); // If it's an array field, we also want to validate the entire topmost array\n      // in case there are minCount/maxCount errors, etc.\n\n      var arrayKey = adjustKeyForArrays(key);\n\n      if (arrayKey !== key) {\n        validateField(arrayKey, formId, false, onlyIfAlreadyInvalid(validationType));\n      }\n    }\n  },\n  'change form': function autoFormChangeHandler(event, template) {\n    var key = getKeyForElement(event.target);\n\n    if (!key) {\n      return;\n    }\n\n    var formId = this.id; // Some plugins, like jquery.inputmask, can cause infinite\n    // loops by continually saying the field changed when it did not,\n    // especially in an autosave situation. This is an attempt to\n    // prevent that from happening.\n\n    var $target = $(event.target);\n    var keyVal = $target.val();\n\n    if (event.target.type === 'checkbox') {\n      // Special handling for checkboxes, which always have the same value\n      keyVal = keyVal + '_' + $target.prop('checked');\n    }\n\n    keyVal = key + '___' + keyVal;\n\n    if (formId in lastKeyVals && keyVal === lastKeyVals[formId]) {\n      return;\n    }\n\n    lastKeyVals[formId] = keyVal; // Mark field value as changed for reactive updates\n\n    updateTrackedFieldValue(template, key); // Get current form data context\n\n    var form = AutoForm.getCurrentDataForForm(formId); // If the form should be auto-saved whenever updated, we do that on field\n    // changes instead of validating the field\n\n    if (form.autosave === true || form.autosaveOnKeyup === true) {\n      lastAutoSaveElement = event.target;\n      $(event.currentTarget).submit();\n      return;\n    }\n\n    var validationType = form.validation;\n\n    if (validationType === 'keyup' || validationType === 'blur' || validationType === 'submitThenKeyup' || validationType === 'submitThenBlur') {\n      validateField(key, formId, false, onlyIfAlreadyInvalid(validationType)); // If it's an array field, we also want to validate the entire topmost array\n      // in case there are minCount/maxCount errors, etc.\n\n      var arrayKey = adjustKeyForArrays(key);\n\n      if (arrayKey !== key) {\n        validateField(arrayKey, formId, false, onlyIfAlreadyInvalid(validationType));\n      }\n    }\n  },\n  'reset form': function autoFormResetHandler(event, template) {\n    var formId = this.id;\n    AutoForm.formPreserve.clearDocument(formId); // Reset array counts\n\n    arrayTracker.resetForm(formId);\n    var vc = AutoForm.getValidationContext(formId);\n    if (vc) vc.reset();\n    event.preventDefault();\n\n    AutoForm._forceResetFormValues(formId); // Mark all fields as changed\n\n\n    updateAllTrackedFieldValues(template); // Focus the autofocus element\n\n    template.$(\"[autofocus]\").focus();\n  },\n  'keydown .autoform-array-item input': function (event) {\n    // When enter is pressed in an array item field, default behavior\n    // seems to be to \"click\" the remove item button. This doesn't make\n    // sense so we stop it.\n    if (event.keyCode === 13) {\n      event.preventDefault();\n    }\n  },\n  'click .autoform-remove-item': function autoFormClickRemoveItem(event, template) {\n    var self = this; // This type of button must be used within an afEachArrayItem block, so we know the context\n\n    event.preventDefault();\n    var name = self.arrayFieldName;\n    var minCount = self.minCount; // optional, overrides schema\n\n    var maxCount = self.maxCount; // optional, overrides schema\n\n    var index = self.index;\n    var data = template.data;\n    var formId = data && data.id;\n    var ss = AutoForm.getFormSchema(formId); // remove the item we clicked\n\n    arrayTracker.removeFromFieldAtIndex(formId, name, index, ss, minCount, maxCount);\n  },\n  'click .autoform-add-item': function autoFormClickAddItem(event, template) {\n    event.preventDefault(); // We pull from data attributes because the button could be manually\n    // added anywhere, so we don't know the data context.\n\n    var btn = $(event.currentTarget);\n    var name = btn.attr(\"data-autoform-field\");\n    var minCount = btn.attr(\"data-autoform-minCount\"); // optional, overrides schema\n\n    var maxCount = btn.attr(\"data-autoform-maxCount\"); // optional, overrides schema\n\n    var data = template.data;\n    var formId = data && data.id;\n    var ss = AutoForm.getFormSchema(formId);\n    arrayTracker.addOneToField(formId, name, ss, minCount, maxCount);\n  }\n});","map":{"version":3,"sources":["packages/aldeed:autoform/autoform-events.js"],"names":["lastAutoSaveElement","lastKeyVals","beginSubmit","formId","template","hookContext","Utility","checkTemplate","hooks","Hooks","getHooks","length","_","each","beginSubmitHooks","hook","call","submitButton","find","disabled","endSubmit","endSubmitHooks","adjustKeyForArrays","key","gKey","AutoForm","makeKeyGeneric","slice","indexOf","onlyIfAlreadyInvalid","validationType","getKeyForElement","element","getAttribute","$","closest","attr","throttleAutosave","throttle","event","target","currentTarget","submit","leading","Template","autoForm","events","autoFormSubmitHandler","formDoc","id","form","getCurrentDataForForm","formType","type","ss","getFormSchema","collection","getFormCollection","ssIsOverride","schema","currentDoc","doc","docId","_id","isValid","validationOptions","validationContext","filter","autoConvert","removeEmptyStrings","trimStrings","ftd","getFormTypeDef","err","preventDefault","onSuccessHooks","onErrorHooks","beforeHooks","afterHooks","addStickyValidationError","value","autoSaveChangedElement","formAttributes","formTypeDefinition","removeStickyValidationError","resetForm","getValidationContext","needsModifierAndDoc","getFormValues","updateDoc","insertDoc","usesModifier","endSubmission","failedValidation","ec","namedContext","ik","validationErrors","error","Error","message","keyErrorMessage","name","onErrorEach","stopPropagation","runBeforeHooks","next","runHook","i","cb","d","isObject","ctx","extend","result","once","resultCallback","console","log","resetOnSuccess","autosave","onSuccessEach","afterHooksEach","shouldPrevalidate","validation","validateForm","useCollectionSchema","e","onSubmit","autoFormKeyUpHandler","contains","keyCode","getFormId","skipEmpty","validateField","arrayKey","autosaveOnKeyup","autoFormBlurHandler","autoFormChangeHandler","$target","keyVal","val","prop","updateTrackedFieldValue","autoFormResetHandler","formPreserve","clearDocument","arrayTracker","vc","reset","_forceResetFormValues","updateAllTrackedFieldValues","focus","autoFormClickRemoveItem","self","arrayFieldName","minCount","maxCount","index","data","removeFromFieldAtIndex","autoFormClickAddItem","btn","addOneToField"],"mappings":"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","sourcesContent":["/* global AutoForm, Hooks, validateField, updateTrackedFieldValue, arrayTracker, updateAllTrackedFieldValues */\n\n// all form events handled here\nvar lastAutoSaveElement = null;\nvar lastKeyVals = {};\n\nfunction beginSubmit(formId, template, hookContext) {\n  if (!Utility.checkTemplate(template)) return;\n\n  // Get user-defined hooks\n  var hooks = Hooks.getHooks(formId, 'beginSubmit');\n  if (hooks.length) {\n    _.each(hooks, function beginSubmitHooks(hook) {\n      hook.call(hookContext);\n    });\n  } else {\n    // If there are no user-defined hooks, by default we disable the submit button during submission\n    var submitButton = template.find(\"button[type=submit]\") || template.find(\"input[type=submit]\");\n    if (submitButton) {\n      submitButton.disabled = true;\n    }\n  }\n}\n\nfunction endSubmit(formId, template, hookContext) {\n  if (!Utility.checkTemplate(template)) return;\n\n  // Try to avoid incorrect reporting of which input caused autosave\n  lastAutoSaveElement = null;\n  // Get user-defined hooks\n  var hooks = Hooks.getHooks(formId, 'endSubmit');\n  if (hooks.length) {\n    _.each(hooks, function endSubmitHooks(hook) {\n      hook.call(hookContext);\n    });\n  } else {\n    // If there are no user-defined hooks, by default we disable the submit button during submission\n    var submitButton = template.find(\"button[type=submit]\") || template.find(\"input[type=submit]\");\n    if (submitButton) {\n      submitButton.disabled = false;\n    }\n  }\n}\n\nfunction adjustKeyForArrays(key) {\n  var gKey = AutoForm.Utility.makeKeyGeneric(key);\n  if (gKey.slice(-2) === '.$' || gKey.indexOf('.$.') !== -1) {\n    key = gKey.slice(0, gKey.indexOf('.$'));\n  }\n  return key;\n}\n\n/**\n * Returns `true` if the specified validation type should\n * be revalidated only when the form is already invalid.\n * @param {String} validationType The validation type string.\n */\nfunction onlyIfAlreadyInvalid(validationType) {\n  return validationType === 'submitThenKeyup' ||\n    validationType === 'submitThenBlur';\n}\n\n/**\n * Given an element, returns the schema key for it, using the\n * `data-schema-key` attribute on the element or on the closest\n * element that has one.\n *\n * @param   {Element}          element The DOM element\n * @returns {String|undefined} The schema key\n */\nfunction getKeyForElement(element) {\n  var key = element.getAttribute(\"data-schema-key\");\n  if (!key) {\n    key = $(element).closest('[data-schema-key]').attr(\"data-schema-key\");\n  }\n  return key;\n}\n\n//throttle autosave, at most autosave every 500ms\nvar throttleAutosave = _.throttle(function(event) {\n  lastAutoSaveElement = event.target;\n  $(event.currentTarget).submit();\n}, 500, {leading: false});\n\nTemplate.autoForm.events({\n  'submit form': function autoFormSubmitHandler(event, template) {\n    var formDoc;\n    // Gather necessary form info\n    var formId = this.id;\n    var form = AutoForm.getCurrentDataForForm(formId);\n    var formType = form.type;\n    // ss will be the schema for the `schema` attribute if present,\n    // else the schema for the collection\n    var ss = AutoForm.getFormSchema(formId);\n    var collection = AutoForm.getFormCollection(formId);\n    var ssIsOverride = !!(collection && form.schema);\n\n    var currentDoc = form.doc;\n    var docId = currentDoc ? currentDoc._id : null;\n    var isValid;\n\n    var validationOptions = {\n      validationContext: formId,\n      filter: form.filter,\n      autoConvert: form.autoConvert,\n      removeEmptyStrings: form.removeEmptyStrings,\n      trimStrings: form.trimStrings\n    };\n\n    // Get the form type definition\n    var ftd;\n    try {\n      ftd = Utility.getFormTypeDef(formType);\n    } catch (err) {\n      event.preventDefault();\n      throw err;\n    }\n\n    // Gather hooks\n    var onSuccessHooks = Hooks.getHooks(formId, 'onSuccess');\n    var onErrorHooks = Hooks.getHooks(formId, 'onError');\n    var beforeHooks = Hooks.getHooks(formId, 'before', formType);\n    var afterHooks = Hooks.getHooks(formId, 'after', formType);\n\n    // Prep context with which hooks are called\n    var hookContext = {\n      addStickyValidationError: function (key, type, value) {\n        AutoForm.addStickyValidationError(formId, key, type, value);\n      },\n      autoSaveChangedElement: lastAutoSaveElement,\n      collection: collection,\n      currentDoc: currentDoc,\n      docId: docId,\n      event: event,\n      formAttributes: form,\n      formId: formId,\n      formTypeDefinition: ftd,\n      removeStickyValidationError: function (key) {\n        AutoForm.removeStickyValidationError(formId, key);\n      },\n      resetForm: function () {\n        AutoForm.resetForm(formId, template);\n      },\n      ss: ss,\n      ssIsOverride: ssIsOverride,\n      template: template,\n      validationContext: AutoForm.getValidationContext(formId)\n    };\n\n    // Gather all form values\n    if (ftd.needsModifierAndDoc) {\n      formDoc = AutoForm.getFormValues(formId, template, ss);\n      hookContext.updateDoc = formDoc.updateDoc;\n      hookContext.insertDoc = formDoc.insertDoc;\n    } else if (ftd.usesModifier) {\n      formDoc = AutoForm.getFormValues(formId, template, ss, true);\n      hookContext.updateDoc = formDoc;\n    } else {\n      formDoc = AutoForm.getFormValues(formId, template, ss, false);\n      hookContext.insertDoc = formDoc;\n    }\n\n    // It is pretty unlikely since we are submitting it, but if\n    // for some reason this form is not currently rendered, we exit.\n    if (!formDoc) {\n      event.preventDefault();\n      return;\n    }\n\n    function endSubmission() {\n      // Run endSubmit hooks (re-enabled submit button or form, etc.)\n      endSubmit(formId, template, hookContext);\n    }\n\n    function failedValidation() {\n      // add validationErrors array as a property\n      // of the Error object before we call\n      // onError hooks\n      var ec = ss.namedContext(formId);\n      var ik = ec.validationErrors(), error;\n      if (ik) {\n        if (ik.length) {\n          error = new Error(ik[0].message || ec.keyErrorMessage(ik[0].name));\n        } else {\n          error = new Error('form failed validation');\n        }\n        error.validationErrors = ik;\n      } else {\n        error = new Error('form failed validation');\n      }\n      _.each(onErrorHooks, function onErrorEach(hook) {\n        hook.call(hookContext, 'pre-submit validation', error);\n      });\n      event.preventDefault();\n      event.stopPropagation();\n      endSubmission();\n    }\n\n    // Prep function that calls before hooks.\n    function runBeforeHooks(doc, next) {\n      // We call the hooks recursively, in order added,\n      // passing the result of the first hook to the\n      // second hook, etc.\n      function runHook(i, doc) {\n        var hook = beforeHooks[i];\n\n        if (!hook) {\n          // We've run all hooks; continue submission\n          next(doc);\n          return;\n        }\n\n        // Define a `result` function\n        var cb = function (d) {\n          // If the hook returns false, we cancel\n          if (d === false) {\n            endSubmission();\n          } else if (!_.isObject(d)) {\n            throw new Error(\"A 'before' hook must return an object\");\n          } else {\n            runHook(i+1, d);\n          }\n        };\n\n        // Add the `result` function to the before hook context\n        var ctx = _.extend({\n          result: _.once(cb)\n        }, hookContext);\n\n        var result = hook.call(ctx, doc);\n\n        // If the hook returns undefined, we wait for it\n        // to call this.result()\n        if (result !== void 0) {\n          ctx.result(result);\n        }\n      }\n\n      runHook(0, doc);\n    }\n\n    // Prep function that calls after, onError, and onSuccess hooks.\n    // Also resets the form on success.\n    function resultCallback(error, result) {\n      if (error) {\n        if (onErrorHooks && onErrorHooks.length) {\n          _.each(onErrorHooks, function onErrorEach(hook) {\n            hook.call(hookContext, formType, error);\n          });\n        } else if ((!afterHooks || !afterHooks.length) && ss.namedContext(formId).isValid()) {\n          // if there are no onError or \"after\" hooks or validation errors, log the error\n          // because it must be some other error from the server\n          console.log(error);\n        }\n      } else {\n        // By default, we reset form after successful submit, but\n        // you can opt out. We should never reset after submit\n        // when autosaving.\n        if (form.resetOnSuccess !== false && form.autosave !== true) {\n          AutoForm.resetForm(formId, template);\n        }\n        // Set docId in the context for insert forms, too\n        if (formType === \"insert\") {\n          hookContext.docId = result;\n        }\n        _.each(onSuccessHooks, function onSuccessEach(hook) {\n          hook.call(hookContext, formType, result);\n        });\n      }\n      _.each(afterHooks, function afterHooksEach(hook) {\n        hook.call(hookContext, error, result);\n      });\n      endSubmission();\n    }\n\n    // Run beginSubmit hooks (disable submit button or form, etc.)\n    // NOTE: This needs to stay after getFormValues in case a\n    // beginSubmit hook disables inputs. We don't get values for\n    // disabled inputs, but if they are just disabling during submission,\n    // then we actually do want the values.\n    //\n    // Also keep this before prevalidation so that sticky errors can be\n    // removed in this hook.\n    beginSubmit(formId, template, hookContext);\n\n    // Ask form type definition whether we should prevalidate. By default we do.\n    var shouldPrevalidate = ftd.shouldPrevalidate ? ftd.shouldPrevalidate.call(hookContext) : true;\n\n    if (shouldPrevalidate) {\n      // This validation pass happens before any \"before\" hooks run. We\n      // validate against the form schema. Then before hooks can add any missing\n      // properties before we validate against the full collection schema.\n      try {\n        isValid = (form.validation === 'none') ||\n          ftd.validateForm.call({\n            form: form,\n            formDoc: formDoc,\n            useCollectionSchema: false\n          });\n      } catch (e) {\n        // Catch exceptions in validation functions which will bubble up here, cause a form with\n        // onSubmit() to submit prematurely and prevent the error from being reported\n        // (due to a page refresh).\n        console.error('Validation error', e);\n        isValid = false;\n      }\n      // If we failed pre-submit validation, we stop submission.\n      if (isValid === false) {\n        failedValidation();\n        return;\n      }\n    }\n\n    // Call onSubmit from the form type definition\n    ftd.onSubmit.call(_.extend({\n      runBeforeHooks: runBeforeHooks,\n      result: resultCallback,\n      endSubmission: endSubmission,\n      failedValidation: failedValidation,\n      validationOptions: validationOptions,\n      hookContext: hookContext\n    }, hookContext));\n  },\n  'keyup [data-schema-key]': function autoFormKeyUpHandler(event) {\n    // Ignore enter/return, shift, ctrl, cmd, tab, arrows, etc.\n    // Most of these are just optimizations, but without ignoring Enter, errors can fail to show up\n    // because of conflicts between running onSubmit handlers and this around the same time.\n    if (_.contains([13, 9, 16, 20, 17, 91, 37, 38, 39, 40], event.keyCode)) return;\n\n    // validateField is throttled, so we need to get the nearest form's\n    // ID here, while we're still in the correct context\n    var formId = AutoForm.getFormId();\n\n    // Get current form data context\n    var form = AutoForm.getCurrentDataForForm(formId);\n\n    var validationType = form.validation;\n    var skipEmpty = !(event.keyCode === 8 || event.keyCode === 46); //if deleting or backspacing, don't skip empty\n\n    if ((validationType === 'keyup' || validationType === 'submitThenKeyup')) {\n      var key = getKeyForElement(event.currentTarget);\n      if (!key) return;\n\n      validateField(key, formId, skipEmpty, onlyIfAlreadyInvalid(validationType));\n\n      // If it's an array field, we also want to validate the entire topmost array\n      // in case there are minCount/maxCount errors, etc.\n      var arrayKey = adjustKeyForArrays(key);\n      if (arrayKey !== key) {\n        validateField(arrayKey, formId, skipEmpty, onlyIfAlreadyInvalid(validationType));\n      }\n\n      // If the form should be auto-saved whenever updated, we do that on field\n      // changes instead of validating the field\n      if (form.autosaveOnKeyup === true) {\n        throttleAutosave(event);\n      }\n    }\n  },\n  'blur [data-schema-key]': function autoFormBlurHandler(event) {\n    // validateField is throttled, so we need to get the nearest form's\n    // ID here, while we're still in the correct context\n    var formId = AutoForm.getFormId();\n\n    // Get current form data context\n    var form = AutoForm.getCurrentDataForForm(formId);\n    var validationType = form.validation;\n\n    if (validationType === 'keyup' ||\n        validationType === 'blur' ||\n        validationType === 'submitThenKeyup' ||\n        validationType === 'submitThenBlur') {\n      var key = getKeyForElement(event.currentTarget);\n      if (!key) {return;}\n\n      validateField(key, formId, false, onlyIfAlreadyInvalid(validationType));\n\n      // If it's an array field, we also want to validate the entire topmost array\n      // in case there are minCount/maxCount errors, etc.\n      var arrayKey = adjustKeyForArrays(key);\n      if (arrayKey !== key) {\n        validateField(arrayKey, formId, false, onlyIfAlreadyInvalid(validationType));\n      }\n    }\n  },\n  'change form': function autoFormChangeHandler(event, template) {\n    var key = getKeyForElement(event.target);\n    if (!key) {return;}\n\n    var formId = this.id;\n\n    // Some plugins, like jquery.inputmask, can cause infinite\n    // loops by continually saying the field changed when it did not,\n    // especially in an autosave situation. This is an attempt to\n    // prevent that from happening.\n    var $target = $(event.target);\n    var keyVal = $target.val();\n    if (event.target.type === 'checkbox') {\n      // Special handling for checkboxes, which always have the same value\n      keyVal = keyVal + '_' + $target.prop('checked');\n    }\n\n    keyVal = key + '___' + keyVal;\n\n    if (formId in lastKeyVals && keyVal === lastKeyVals[formId]) {\n      return;\n    }\n    lastKeyVals[formId] = keyVal;\n\n    // Mark field value as changed for reactive updates\n    updateTrackedFieldValue(template, key);\n\n    // Get current form data context\n    var form = AutoForm.getCurrentDataForForm(formId);\n\n    // If the form should be auto-saved whenever updated, we do that on field\n    // changes instead of validating the field\n    if (form.autosave === true || form.autosaveOnKeyup === true) {\n      lastAutoSaveElement = event.target;\n      $(event.currentTarget).submit();\n      return;\n    }\n\n    var validationType = form.validation;\n\n    if (validationType === 'keyup' ||\n        validationType === 'blur' ||\n        validationType === 'submitThenKeyup' ||\n        validationType === 'submitThenBlur') {\n\n      validateField(key, formId, false, onlyIfAlreadyInvalid(validationType));\n\n      // If it's an array field, we also want to validate the entire topmost array\n      // in case there are minCount/maxCount errors, etc.\n      var arrayKey = adjustKeyForArrays(key);\n      if (arrayKey !== key) {\n        validateField(arrayKey, formId, false, onlyIfAlreadyInvalid(validationType));\n      }\n    }\n  },\n  'reset form': function autoFormResetHandler(event, template) {\n    var formId = this.id;\n\n    AutoForm.formPreserve.clearDocument(formId);\n\n    // Reset array counts\n    arrayTracker.resetForm(formId);\n\n    var vc = AutoForm.getValidationContext(formId);\n    if (vc) vc.reset();\n\n    event.preventDefault();\n    AutoForm._forceResetFormValues(formId);\n\n    // Mark all fields as changed\n    updateAllTrackedFieldValues(template);\n    // Focus the autofocus element\n    template.$(\"[autofocus]\").focus();\n\n  },\n  'keydown .autoform-array-item input': function (event) {\n    // When enter is pressed in an array item field, default behavior\n    // seems to be to \"click\" the remove item button. This doesn't make\n    // sense so we stop it.\n    if (event.keyCode === 13) {\n      event.preventDefault();\n    }\n  },\n  'click .autoform-remove-item': function autoFormClickRemoveItem(event, template) {\n    var self = this; // This type of button must be used within an afEachArrayItem block, so we know the context\n\n    event.preventDefault();\n\n    var name = self.arrayFieldName;\n    var minCount = self.minCount; // optional, overrides schema\n    var maxCount = self.maxCount; // optional, overrides schema\n    var index = self.index;\n    var data = template.data;\n    var formId = data && data.id;\n    var ss = AutoForm.getFormSchema(formId);\n\n    // remove the item we clicked\n    arrayTracker.removeFromFieldAtIndex(formId, name, index, ss, minCount, maxCount);\n  },\n  'click .autoform-add-item': function autoFormClickAddItem(event, template) {\n    event.preventDefault();\n\n    // We pull from data attributes because the button could be manually\n    // added anywhere, so we don't know the data context.\n    var btn = $(event.currentTarget);\n    var name = btn.attr(\"data-autoform-field\");\n    var minCount = btn.attr(\"data-autoform-minCount\"); // optional, overrides schema\n    var maxCount = btn.attr(\"data-autoform-maxCount\"); // optional, overrides schema\n\n    var data = template.data;\n    var formId = data && data.id;\n    var ss = AutoForm.getFormSchema(formId);\n\n    arrayTracker.addOneToField(formId, name, ss, minCount, maxCount);\n  }\n});\n"]},"sourceType":"script","hash":"714ad78030f6d591cde15499121d5b108cadba3d"}
