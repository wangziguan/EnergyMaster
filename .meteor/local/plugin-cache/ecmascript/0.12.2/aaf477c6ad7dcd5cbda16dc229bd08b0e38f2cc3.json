{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:tabular/server/main.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.linux.x86_64"},"sourceFileName":"packages/aldeed:tabular/server/main.js","filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:tabular/server/main.js","passPerPreset":false,"envName":"development","cwd":"/home/wangziguan/wzg/EnergyMaster","root":"/home/wangziguan/wzg/EnergyMaster","presets":[],"generatorOpts":{"filename":"/home/wangziguan/wzg/EnergyMaster/packages/aldeed:tabular/server/main.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/aldeed:tabular/server/main.js"}},"code":"let Meteor;\nmodule.link(\"meteor/meteor\", {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet check, Match;\nmodule.link(\"meteor/check\", {\n  check(v) {\n    check = v;\n  },\n\n  Match(v) {\n    Match = v;\n  }\n\n}, 1);\n\nlet _;\n\nmodule.link(\"meteor/underscore\", {\n  _(v) {\n    _ = v;\n  }\n\n}, 2);\nlet Tabular;\nmodule.link(\"../common/Tabular\", {\n  default(v) {\n    Tabular = v;\n  }\n\n}, 3);\n\n/*\n * These are the two publications used by TabularTable.\n *\n * The genericPub one can be overridden by supplying a `pub`\n * property with a different publication name. This publication\n * is given only the list of ids and requested fields. You may\n * want to override it if you need to publish documents from\n * related collections along with the table collection documents.\n *\n * The getInfo one runs first and handles all the complex logic\n * required by this package, so that you don't have to duplicate\n * this logic when overriding the genericPub function.\n *\n * Having two publications also allows fine-grained control of\n * reactivity on the client.\n */\nMeteor.publish('tabular_genericPub', function (tableName, ids, fields) {\n  check(tableName, String);\n  check(ids, Array);\n  check(fields, Match.Optional(Object));\n  const table = Tabular.tablesByName[tableName];\n\n  if (!table) {\n    // We throw an error in the other pub, so no need to throw one here\n    this.ready();\n    return;\n  } // Check security. We call this in both publications.\n\n\n  if (typeof table.allow === 'function' && !table.allow(this.userId, fields)) {\n    this.ready();\n    return;\n  } // Check security for fields. We call this only in this publication\n\n\n  if (typeof table.allowFields === 'function' && !table.allowFields(this.userId, fields)) {\n    this.ready();\n    return;\n  }\n\n  return table.collection.find({\n    _id: {\n      $in: ids\n    }\n  }, {\n    fields: fields\n  });\n});\nMeteor.publish('tabular_getInfo', function (tableName, selector, sort, skip, limit) {\n  check(tableName, String);\n  check(selector, Match.Optional(Match.OneOf(Object, null)));\n  check(sort, Match.Optional(Match.OneOf(Array, null)));\n  check(skip, Number);\n  check(limit, Match.Optional(Match.OneOf(Number, null)));\n  const table = Tabular.tablesByName[tableName];\n\n  if (!table) {\n    throw new Error(`No TabularTable defined with the name \"${tableName}\". Make sure you are defining your TabularTable in common code.`);\n  } // Check security. We call this in both publications.\n  // Even though we're only publishing _ids and counts\n  // from this function, with sensitive data, there is\n  // a chance someone could do a query and learn something\n  // just based on whether a result is found or not.\n\n\n  if (typeof table.allow === 'function' && !table.allow(this.userId)) {\n    this.ready();\n    return;\n  }\n\n  selector = selector || {}; // Allow the user to modify the selector before we use it\n\n  if (typeof table.changeSelector === 'function') {\n    selector = table.changeSelector(selector, this.userId);\n  } // Apply the server side selector specified in the tabular\n  // table constructor. Both must be met, so we join\n  // them using $and, allowing both selectors to have\n  // the same keys.\n\n\n  if (typeof table.selector === 'function') {\n    const tableSelector = table.selector(this.userId);\n\n    if (_.isEmpty(selector)) {\n      selector = tableSelector;\n    } else {\n      selector = {\n        $and: [tableSelector, selector]\n      };\n    }\n  }\n\n  const findOptions = {\n    skip: skip,\n    fields: {\n      _id: 1\n    }\n  }; // `limit` may be `null`\n\n  if (limit > 0) {\n    findOptions.limit = limit;\n  } // `sort` may be `null`\n\n\n  if (_.isArray(sort)) {\n    findOptions.sort = sort;\n  }\n\n  const filteredCursor = table.collection.find(selector, findOptions);\n  let filteredRecordIds = filteredCursor.map(doc => doc._id); // If we are not going to count for real, in order to improve performance, then we will fake\n  // the count to ensure the Next button is always available.\n\n  const fakeCount = filteredRecordIds.length + skip + 1;\n  const countCursor = table.collection.find(selector, {\n    fields: {\n      _id: 1\n    }\n  });\n  let recordReady = false;\n\n  let updateRecords = () => {\n    let currentCount;\n\n    if (!table.skipCount) {\n      if (typeof table.alternativeCount === 'function') {\n        currentCount = table.alternativeCount(selector);\n      } else {\n        currentCount = countCursor.count();\n      }\n    } // From https://datatables.net/manual/server-side\n    // recordsTotal: Total records, before filtering (i.e. the total number of records in the database)\n    // recordsFiltered: Total records, after filtering (i.e. the total number of records after filtering has been applied - not just the number of records being returned for this page of data).\n\n\n    const record = {\n      ids: filteredRecordIds,\n      // count() will give us the updated total count\n      // every time. It does not take the find options\n      // limit into account.\n      recordsTotal: table.skipCount ? fakeCount : currentCount,\n      recordsFiltered: table.skipCount ? fakeCount : currentCount\n    };\n\n    if (recordReady) {\n      //console.log('changed', tableName, record);\n      this.changed('tabular_records', tableName, record);\n    } else {\n      //console.log('added', tableName, record);\n      this.added('tabular_records', tableName, record);\n      recordReady = true;\n    }\n  };\n\n  if (table.throttleRefresh) {\n    // Why Meteor.bindEnvironment? See https://github.com/aldeed/meteor-tabular/issues/278#issuecomment-217318112\n    updateRecords = _.throttle(Meteor.bindEnvironment(updateRecords), table.throttleRefresh);\n  }\n\n  updateRecords();\n  this.ready(); // Handle docs being added or removed from the result set.\n\n  let initializing = true;\n  const handle = filteredCursor.observeChanges({\n    added: function (id) {\n      if (initializing) return; //console.log('ADDED');\n\n      filteredRecordIds.push(id);\n      updateRecords();\n    },\n    removed: function (id) {\n      //console.log('REMOVED');\n      // _.findWhere is used to support Mongo ObjectIDs\n      filteredRecordIds = _.without(filteredRecordIds, _.findWhere(filteredRecordIds, id));\n      updateRecords();\n    }\n  });\n  initializing = false; // It is too inefficient to use an observe without any limits to track count perfectly\n  // accurately when, for example, the selector is {} and there are a million documents.\n  // Instead we will update the count every 10 seconds, in addition to whenever the limited\n  // result set changes.\n\n  const interval = Meteor.setInterval(updateRecords, 10000); // Stop observing the cursors when client unsubs.\n  // Stopping a subscription automatically takes\n  // care of sending the client any removed messages.\n\n  this.onStop(() => {\n    Meteor.clearInterval(interval);\n    handle.stop();\n  });\n});\nmodule.exportDefault(Tabular);","map":{"version":3,"sources":["packages/aldeed:tabular/server/main.js"],"names":["Meteor","module","link","v","check","Match","_","Tabular","default","publish","tableName","ids","fields","String","Array","Optional","Object","table","tablesByName","ready","allow","userId","allowFields","collection","find","_id","$in","selector","sort","skip","limit","OneOf","Number","Error","changeSelector","tableSelector","isEmpty","$and","findOptions","isArray","filteredCursor","filteredRecordIds","map","doc","fakeCount","length","countCursor","recordReady","updateRecords","currentCount","skipCount","alternativeCount","count","record","recordsTotal","recordsFiltered","changed","added","throttleRefresh","throttle","bindEnvironment","initializing","handle","observeChanges","id","push","removed","without","findWhere","interval","setInterval","onStop","clearInterval","stop","exportDefault"],"mappings":"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","sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { check, Match } from 'meteor/check';\nimport { _ } from 'meteor/underscore';\nimport Tabular from '../common/Tabular';\n\n/*\n * These are the two publications used by TabularTable.\n *\n * The genericPub one can be overridden by supplying a `pub`\n * property with a different publication name. This publication\n * is given only the list of ids and requested fields. You may\n * want to override it if you need to publish documents from\n * related collections along with the table collection documents.\n *\n * The getInfo one runs first and handles all the complex logic\n * required by this package, so that you don't have to duplicate\n * this logic when overriding the genericPub function.\n *\n * Having two publications also allows fine-grained control of\n * reactivity on the client.\n */\n\nMeteor.publish('tabular_genericPub', function (tableName, ids, fields) {\n  check(tableName, String);\n  check(ids, Array);\n  check(fields, Match.Optional(Object));\n\n  const table = Tabular.tablesByName[tableName];\n  if (!table) {\n    // We throw an error in the other pub, so no need to throw one here\n    this.ready();\n    return;\n  }\n\n  // Check security. We call this in both publications.\n  if (typeof table.allow === 'function' && !table.allow(this.userId, fields)) {\n    this.ready();\n    return;\n  }\n\n  // Check security for fields. We call this only in this publication\n  if (typeof table.allowFields === 'function' && !table.allowFields(this.userId, fields)) {\n    this.ready();\n    return;\n  }\n\n  return table.collection.find({_id: {$in: ids}}, {fields: fields});\n});\n\nMeteor.publish('tabular_getInfo', function (tableName, selector, sort, skip, limit) {\n  check(tableName, String);\n  check(selector, Match.Optional(Match.OneOf(Object, null)));\n  check(sort, Match.Optional(Match.OneOf(Array, null)));\n  check(skip, Number);\n  check(limit, Match.Optional(Match.OneOf(Number, null)));\n\n  const table = Tabular.tablesByName[tableName];\n  if (!table) {\n    throw new Error(`No TabularTable defined with the name \"${tableName}\". Make sure you are defining your TabularTable in common code.`);\n  }\n\n  // Check security. We call this in both publications.\n  // Even though we're only publishing _ids and counts\n  // from this function, with sensitive data, there is\n  // a chance someone could do a query and learn something\n  // just based on whether a result is found or not.\n  if (typeof table.allow === 'function' && !table.allow(this.userId)) {\n    this.ready();\n    return;\n  }\n\n  selector = selector || {};\n\n  // Allow the user to modify the selector before we use it\n  if (typeof table.changeSelector === 'function') {\n    selector = table.changeSelector(selector, this.userId);\n  }\n\n  // Apply the server side selector specified in the tabular\n  // table constructor. Both must be met, so we join\n  // them using $and, allowing both selectors to have\n  // the same keys.\n  if (typeof table.selector === 'function') {\n    const tableSelector = table.selector(this.userId);\n    if (_.isEmpty(selector)) {\n      selector = tableSelector;\n    } else {\n      selector = {$and: [tableSelector, selector]};\n    }\n  }\n\n  const findOptions = {\n    skip: skip,\n    fields: {_id: 1}\n  };\n\n  // `limit` may be `null`\n  if (limit > 0) {\n    findOptions.limit = limit;\n  }\n\n  // `sort` may be `null`\n  if (_.isArray(sort)) {\n    findOptions.sort = sort;\n  }\n\n  const filteredCursor = table.collection.find(selector, findOptions);\n\n  let filteredRecordIds = filteredCursor.map(doc => doc._id);\n\n  // If we are not going to count for real, in order to improve performance, then we will fake\n  // the count to ensure the Next button is always available.\n  const fakeCount = filteredRecordIds.length + skip + 1;\n\n  const countCursor = table.collection.find(selector, {fields: {_id: 1}});\n\n  let recordReady = false;\n  let updateRecords = () => {\n    let currentCount;\n    if (!table.skipCount) {\n      if (typeof table.alternativeCount === 'function') {\n        currentCount = table.alternativeCount(selector);\n      } else {\n        currentCount = countCursor.count();\n      }\n    }\n\n    // From https://datatables.net/manual/server-side\n    // recordsTotal: Total records, before filtering (i.e. the total number of records in the database)\n    // recordsFiltered: Total records, after filtering (i.e. the total number of records after filtering has been applied - not just the number of records being returned for this page of data).\n\n    const record = {\n      ids: filteredRecordIds,\n      // count() will give us the updated total count\n      // every time. It does not take the find options\n      // limit into account.\n      recordsTotal: table.skipCount ? fakeCount : currentCount,\n      recordsFiltered: table.skipCount ? fakeCount : currentCount\n    };\n\n    if (recordReady) {\n      //console.log('changed', tableName, record);\n      this.changed('tabular_records', tableName, record);\n    } else {\n      //console.log('added', tableName, record);\n      this.added('tabular_records', tableName, record);\n      recordReady = true;\n    }\n  }\n\n  if (table.throttleRefresh) {\n    // Why Meteor.bindEnvironment? See https://github.com/aldeed/meteor-tabular/issues/278#issuecomment-217318112\n    updateRecords = _.throttle(Meteor.bindEnvironment(updateRecords), table.throttleRefresh);\n  }\n\n  updateRecords();\n\n  this.ready();\n\n  // Handle docs being added or removed from the result set.\n  let initializing = true;\n  const handle = filteredCursor.observeChanges({\n    added: function (id) {\n      if (initializing) return;\n\n      //console.log('ADDED');\n      filteredRecordIds.push(id);\n      updateRecords();\n    },\n    removed: function (id) {\n      //console.log('REMOVED');\n      // _.findWhere is used to support Mongo ObjectIDs\n      filteredRecordIds = _.without(filteredRecordIds, _.findWhere(filteredRecordIds, id));\n      updateRecords();\n    }\n  });\n  initializing = false;\n\n  // It is too inefficient to use an observe without any limits to track count perfectly\n  // accurately when, for example, the selector is {} and there are a million documents.\n  // Instead we will update the count every 10 seconds, in addition to whenever the limited\n  // result set changes.\n  const interval = Meteor.setInterval(updateRecords, 10000);\n\n  // Stop observing the cursors when client unsubs.\n  // Stopping a subscription automatically takes\n  // care of sending the client any removed messages.\n  this.onStop(() => {\n    Meteor.clearInterval(interval);\n    handle.stop();\n  });\n});\n\nexport default Tabular;\n"]},"sourceType":"script","hash":"aaf477c6ad7dcd5cbda16dc229bd08b0e38f2cc3"}
