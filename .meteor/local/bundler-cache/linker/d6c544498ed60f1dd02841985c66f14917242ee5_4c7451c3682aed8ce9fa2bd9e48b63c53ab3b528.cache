[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar _ = Package.underscore._;\nvar MongoInternals = Package.mongo.MongoInternals;\nvar Mongo = Package.mongo.Mongo;\nvar Blaze = Package.blaze.Blaze;\nvar UI = Package.blaze.UI;\nvar Handlebars = Package.blaze.Handlebars;\nvar ReactiveVar = Package['reactive-var'].ReactiveVar;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar HTML = Package.htmljs.HTML;\n\n/* Package-scope variables */\nvar Tabular;\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                      //\n// packages/aldeed_tabular/common.js                                                                    //\n//                                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                        //\n/* global Tabular:true, Mongo, _, Meteor, Template */\n\nTabular = {}; //exported\n\nTabular.tablesByName = {};\n\nif (Meteor.isClient) {\n  Template.registerHelper('TabularTables', Tabular.tablesByName);\n}\n\nTabular.Table = function (options) {\n  var self = this;\n\n  if (!options) {\n    throw new Error('Tabular.Table options argument is required');\n  }\n\n  if (!options.name) {\n    throw new Error('Tabular.Table options must specify name');\n  }\n  self.name = options.name;\n\n  if (!(options.collection instanceof Mongo.Collection)) {\n    throw new Error('Tabular.Table options must specify collection');\n  }\n  self.collection = options.collection;\n\n  self.pub = options.pub || 'tabular_genericPub';\n\n  // By default we use core `Meteor.subscribe`, but you can pass\n  // a subscription manager like `sub: new SubsManager({cacheLimit: 20, expireIn: 3})`\n  self.sub = options.sub || Meteor;\n\n  self.onUnload = options.onUnload;\n  self.allow = options.allow;\n  self.allowFields = options.allowFields;\n  self.changeSelector = options.changeSelector;\n  self.throttleRefresh = options.throttleRefresh;\n\n  if (_.isArray(options.extraFields)) {\n    var fields = {};\n    _.each(options.extraFields, function (fieldName) {\n      fields[fieldName] = 1;\n    });\n    self.extraFields = fields;\n  }\n\n  self.selector = options.selector;\n\n  if (!options.columns) {\n    throw new Error('Tabular.Table options must specify columns');\n  }\n\n  self.options = _.omit(options, 'collection', 'pub', 'sub', 'onUnload', 'allow', 'allowFields', 'extraFields', 'name', 'selector');\n\n  Tabular.tablesByName[self.name] = self;\n};\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                      //\n// packages/aldeed_tabular/server/tabular.js                                                            //\n//                                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                        //\n/* global check, Match, Meteor, _, Tabular */\n\n/*\n * These are the two publications used by TabularTable.\n *\n * The genericPub one can be overridden by supplying a `pub`\n * property with a different publication name. This publication\n * is given only the list of ids and requested fields. You may\n * want to override it if you need to publish documents from\n * related collections along with the table collection documents.\n *\n * The getInfo one runs first and handles all the complex logic\n * required by this package, so that you don't have to duplicate\n * this logic when overriding the genericPub function.\n *\n * Having two publications also allows fine-grained control of\n * reactivity on the client.\n */\n\nMeteor.publish(\"tabular_genericPub\", function (tableName, ids, fields) {\n  var self = this;\n\n  check(tableName, String);\n  check(ids, Array);\n  check(fields, Match.Optional(Object));\n\n  var table = Tabular.tablesByName[tableName];\n  if (!table) {\n    // We throw an error in the other pub, so no need to throw one here\n    self.ready();\n    return;\n  }\n\n  // Check security. We call this in both publications.\n  if (typeof table.allow === 'function' && !table.allow(self.userId, fields)) {\n    self.ready();\n    return;\n  }\n\n  // Check security for fields. We call this only in this publication\n  if (typeof table.allowFields === 'function' && !table.allowFields(self.userId, fields)) {\n    self.ready();\n    return;\n  }\n\n  return table.collection.find({_id: {$in: ids}}, {fields: fields});\n});\n\nMeteor.publish(\"tabular_getInfo\", function(tableName, selector, sort, skip, limit) {\n  var self = this;\n\n  check(tableName, String);\n  check(selector, Match.Optional(Match.OneOf(Object, null)));\n  check(sort, Match.Optional(Match.OneOf(Array, null)));\n  check(skip, Number);\n  check(limit, Match.Optional(Match.OneOf(Number, null)));\n\n  var table = Tabular.tablesByName[tableName];\n  if (!table) {\n    throw new Error('No TabularTable defined with the name \"' + tableName + '\". Make sure you are defining your TabularTable in common code.');\n  }\n\n  // Check security. We call this in both publications.\n  // Even though we're only publishing _ids and counts\n  // from this function, with sensitive data, there is\n  // a chance someone could do a query and learn something\n  // just based on whether a result is found or not.\n  if (typeof table.allow === 'function' && !table.allow(self.userId)) {\n    self.ready();\n    return;\n  }\n\n  selector = selector || {};\n\n  // Allow the user to modify the selector before we use it\n  if (typeof table.changeSelector === 'function') {\n    selector = table.changeSelector(selector, self.userId);\n  }\n\n  // Apply the server side selector specified in the tabular\n  // table constructor. Both must be met, so we join\n  // them using $and, allowing both selectors to have\n  // the same keys.\n  if (typeof table.selector === 'function') {\n    var tableSelector = table.selector(self.userId);\n    if (_.isEmpty(selector)) {\n      selector = tableSelector;\n    } else {\n      selector = {$and: [tableSelector, selector]};\n    }\n  }\n\n  var findOptions = {\n    skip: skip,\n    fields: {_id: 1}\n  };\n\n  // `limit` may be `null`\n  if (limit > 0) {\n    findOptions.limit = limit;\n  }\n\n  // `sort` may be `null`\n  if (_.isArray(sort)) {\n    findOptions.sort = sort;\n  }\n\n  var filteredCursor = table.collection.find(selector, findOptions);\n\n  var filteredRecordIds = filteredCursor.map(function (doc) {\n    return doc._id;\n  });\n\n  var countCursor = table.collection.find(selector, {fields: {_id: 1}});\n\n  var recordReady = false;\n  var updateRecords = function updateRecords() {\n    var currentCount = countCursor.count();\n\n    // From https://datatables.net/manual/server-side\n    // recordsTotal: Total records, before filtering (i.e. the total number of records in the database)\n    // recordsFiltered: Total records, after filtering (i.e. the total number of records after filtering has been applied - not just the number of records being returned for this page of data).\n\n    var record = {\n      ids: filteredRecordIds,\n      // count() will give us the updated total count\n      // every time. It does not take the find options\n      // limit into account.\n      recordsTotal: currentCount,\n      recordsFiltered: currentCount\n    };\n\n    if (recordReady) {\n      //console.log(\"changed\", tableName, record);\n      self.changed('tabular_records', tableName, record);\n    } else {\n      //console.log(\"added\", tableName, record);\n      self.added(\"tabular_records\", tableName, record);\n      recordReady = true;\n    }\n  };\n\n  if (table.throttleRefresh) {\n    updateRecords = _.throttle(updateRecords, table.throttleRefresh);\n  }\n\n  updateRecords();\n\n  self.ready();\n\n  // Handle docs being added or removed from the result set.\n  var initializing = true;\n  var handle = filteredCursor.observeChanges({\n    added: function (id) {\n      if (initializing) return;\n\n      //console.log(\"ADDED\");\n      filteredRecordIds.push(id);\n      updateRecords();\n    },\n    removed: function (id) {\n      //console.log(\"REMOVED\");\n      // _.findWhere is used to support Mongo ObjectIDs\n      filteredRecordIds = _.without(filteredRecordIds, _.findWhere(filteredRecordIds, id));\n      updateRecords();\n    }\n  });\n  initializing = false;\n\n  // It is too inefficient to use an observe without any limits to track count perfectly\n  // accurately when, for example, the selector is {} and there are a million documents.\n  // Instead we will update the count every 10 seconds, in addition to whenever the limited\n  // result set changes.\n  var interval = Meteor.setInterval(updateRecords, 10000);\n\n  // Stop observing the cursors when client unsubs.\n  // Stopping a subscription automatically takes\n  // care of sending the client any removed messages.\n  self.onStop(function () {\n    Meteor.clearInterval(interval);\n    handle.stop();\n  });\n});\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"aldeed:tabular\", {\n  Tabular: Tabular\n});\n\n})();\n","servePath":"/packages/aldeed_tabular.js"}]